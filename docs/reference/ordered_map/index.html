<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  ordered_map.hpp
  #

Defines toml::ordered_map, which is used to maintain the order of values in a file.

  class ordered_map
  #

namespace toml
{
template<typename Key, typename Val, typename Cmp = std::equal_to<Key>,
         typename Allocator = std::allocator<std::pair<Key, Val>>>
class ordered_map;
}
The ordered_map is a map type that preserves the insertion order of values, allowing iteration in that order.
As a linear container, searches require O(n) time relative to the number of elements.
Use this when search operations are infrequent and maintaining the order of values is important."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://toruniina.github.io/toml11/docs/reference/ordered_map/"><meta property="og:site_name" content="toml11"><meta property="og:title" content="ordered_map.hpp"><meta property="og:description" content="ordered_map.hpp # Defines toml::ordered_map, which is used to maintain the order of values in a file.
class ordered_map # namespace toml { template<typename Key, typename Val, typename Cmp = std::equal_to<Key>, typename Allocator = std::allocator<std::pair<Key, Val>>> class ordered_map; } The ordered_map is a map type that preserves the insertion order of values, allowing iteration in that order.
As a linear container, searches require O(n) time relative to the number of elements. Use this when search operations are infrequent and maintaining the order of values is important."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>ordered_map.hpp | toml11</title><link rel=manifest href=/toml11/manifest.json><link rel=icon href=/toml11/favicon.png><link rel=canonical href=https://toruniina.github.io/toml11/docs/reference/ordered_map/><link rel=alternate hreflang=ja href=https://toruniina.github.io/toml11/ja/docs/reference/ordered_map/ title=ordered_map.hpp><link rel=stylesheet href=/toml11/book.min.6d8037b375fe949eee1b70501c5fb9478914c9c5eb3ef7696163fd3031c69421.css integrity="sha256-bYA3s3X+lJ7uG3BQHF+5R4kUycXrPvdpYWP9MDHGlCE=" crossorigin=anonymous><script defer src=/toml11/fuse.min.js></script><script defer src=/toml11/en.search.min.87bec23503963d7026bfa3a917b92707789d315c9c9e005e23226b35dce643f5.js integrity="sha256-h77CNQOWPXAmv6OpF7knB3idMVycngBeIyJrNdzmQ/U=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/toml11/><span>toml11</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/toml11/svg/translate.svg class=book-icon alt=Languages>
English</a></label><ul><li><a href=https://toruniina.github.io/toml11/ja/docs/reference/ordered_map/>日本語</a></li></ul></li></ul><ul><li><a href=/toml11/docs/installation/>installation</a><ul></ul></li><li><input type=checkbox id=section-291123c850af98d8b815ccdbb4c33657 class=toggle>
<label for=section-291123c850af98d8b815ccdbb4c33657 class="flex justify-between"><a href=/toml11/docs/features/>features</a></label><ul><li><a href=/toml11/docs/features/parsing_files/>parsing files</a></li><li><a href=/toml11/docs/features/value/>getting values</a></li><li><a href=/toml11/docs/features/error_message/>error message</a></li><li><a href=/toml11/docs/features/serialize/>serializing values</a></li><li><a href=/toml11/docs/features/configure_types/>configuring types</a></li><li><a href=/toml11/docs/features/literal/>toml literal</a></li><li><a href=/toml11/docs/features/toml_spec/>toml spec</a></li><li><a href=/toml11/docs/features/extension/>extension</a></li></ul></li><li><input type=checkbox id=section-e2e812e55021b82e114feaae98f1a02e class=toggle checked>
<label for=section-e2e812e55021b82e114feaae98f1a02e class="flex justify-between"><a href=/toml11/docs/reference/>reference</a></label><ul><li><a href=/toml11/docs/reference/color/>color.hpp</a></li><li><a href=/toml11/docs/reference/comments/>comments.hpp</a></li><li><a href=/toml11/docs/reference/conversion/>conversion.hpp</a></li><li><a href=/toml11/docs/reference/datetime/>datetime.hpp</a></li><li><a href=/toml11/docs/reference/error_info/>error_info.hpp</a></li><li><a href=/toml11/docs/reference/exception/>exception.hpp</a></li><li><a href=/toml11/docs/reference/find/>find.hpp</a></li><li><a href=/toml11/docs/reference/format/>format.hpp</a></li><li><a href=/toml11/docs/reference/from/>from.hpp</a></li><li><a href=/toml11/docs/reference/get/>get.hpp</a></li><li><a href=/toml11/docs/reference/into/>into.hpp</a></li><li><a href=/toml11/docs/reference/literal/>literal.hpp</a></li><li><a href=/toml11/docs/reference/ordered_map/ class=active>ordered_map.hpp</a></li><li><a href=/toml11/docs/reference/parser/>parser.hpp</a></li><li><a href=/toml11/docs/reference/result/>result.hpp</a></li><li><a href=/toml11/docs/reference/serializer/>serializer.hpp</a></li><li><a href=/toml11/docs/reference/source_location/>source_location.hpp</a></li><li><a href=/toml11/docs/reference/spec/>spec.hpp</a></li><li><a href=/toml11/docs/reference/toml_fwd/>toml_fwd.hpp</a></li><li><a href=/toml11/docs/reference/toml/>toml.hpp</a></li><li><a href=/toml11/docs/reference/types/>types.hpp</a></li><li><a href=/toml11/docs/reference/value_t/>value_t.hpp</a></li><li><a href=/toml11/docs/reference/value/>value.hpp</a></li><li><a href=/toml11/docs/reference/version/>version.hpp</a></li><li><a href=/toml11/docs/reference/visit/>visit.hpp</a></li></ul></li><li><a href=/toml11/docs/changelog/>changelog</a><ul></ul></li></ul><ul><li><a href=https://github.com/ToruNiina/toml11 target=_blank rel=noopener>GitHub</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/toml11/svg/menu.svg class=book-icon alt=Menu>
</label><strong>ordered_map.hpp</strong>
<label for=toc-control><img src=/toml11/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#ordered_maphpp>ordered_map.hpp</a></li><li><a href=#class-ordered_map><code>class ordered_map</code></a><ul><li><a href=#non-member-types>Non-Member Types</a></li><li><a href=#member-types>Member Types</a></li><li><a href=#member-functions>Member Functions</a><ul><li><a href=#constructors>Constructors</a></li><li><a href=#constructors-comparator-allocator>Constructors (Comparator, Allocator)</a></li><li><a href=#copy-and-move-constructors>Copy and Move Constructors</a></li><li><a href=#constructors-iterator>Constructors (Iterator)</a></li><li><a href=#constructors-stdinitializer_list>Constructors (std::initializer_list)</a></li><li><a href=#copy-and-move-assignment-operators>Copy and Move Assignment Operators</a></li><li><a href=#assignment-operator-stdinitializer_list>Assignment Operator (std::initializer_list)</a></li><li><a href=#destructor>Destructor</a></li><li><a href=#begin-end><code>begin()</code>, <code>end()</code></a></li><li><a href=#empty><code>empty()</code></a></li><li><a href=#size><code>size()</code></a></li><li><a href=#max_size><code>max_size()</code></a></li><li><a href=#clear><code>clear()</code></a></li><li><a href=#push_backkv><code>push_back(kv)</code></a></li><li><a href=#emplace_backk-v><code>emplace_back(k, v)</code></a></li><li><a href=#pop_back><code>pop_back()</code></a></li><li><a href=#insertkv><code>insert(kv)</code></a></li><li><a href=#emplacek-v><code>emplace(k, v)</code></a></li><li><a href=#countk><code>count(k)</code></a></li><li><a href=#containsk><code>contains(k)</code></a></li><li><a href=#findk><code>find(k)</code></a></li><li><a href=#atk><code>at(k)</code></a></li><li><a href=#operatork><code>operator[](k)</code></a></li><li><a href=#erase><code>erase(...)</code></a></li><li><a href=#key_comp><code>key_comp()</code></a></li></ul></li><li><a href=#notes>Notes</a><ul><li><a href=#key-modification>Key Modification</a></li><li><a href=#order-preservation-details>Order Preservation Details</a></li></ul></li><li><a href=#related>Related</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ordered_maphpp>ordered_map.hpp
<a class=anchor href=#ordered_maphpp>#</a></h1><p>Defines <code>toml::ordered_map</code>, which is used to maintain the order of values in a file.</p><h1 id=class-ordered_map><code>class ordered_map</code>
<a class=anchor href=#class-ordered_map>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>namespace</span> toml
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Key, <span style=color:#66d9ef>typename</span> Val, <span style=color:#66d9ef>typename</span> Cmp <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>equal_to<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>typename</span> Allocator <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>allocator<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>Key, Val<span style=color:#f92672>&gt;&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ordered_map</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>ordered_map</code> is a <code>map</code> type that preserves the insertion order of values, allowing iteration in that order.</p><p>As a linear container, searches require <code>O(n)</code> time relative to the number of elements.
Use this when search operations are infrequent and maintaining the order of values is important.</p><h2 id=non-member-types>Non-Member Types
<a class=anchor href=#non-member-types>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>namespace</span> toml
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ordered_type_config</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ordered_value <span style=color:#f92672>=</span> basic_value<span style=color:#f92672>&lt;</span>ordered_type_config<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ordered_table <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> ordered_value<span style=color:#f92672>::</span>table_type;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ordered_array <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> ordered_value<span style=color:#f92672>::</span>array_type;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Use these in place of <code>toml::type_config</code> and <code>toml::value</code>.</p><blockquote class="book-hint info"><p>Since <code>toml::parse</code> defaults to using <code>type_config</code>, specify</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> input <span style=color:#f92672>=</span> toml<span style=color:#f92672>::</span>parse<span style=color:#f92672>&lt;</span>toml<span style=color:#f92672>::</span>ordered_type_config<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;input.toml&#34;</span>);
</span></span></code></pre></div><p>when parsing.</p></blockquote><h2 id=member-types>Member Types
<a class=anchor href=#member-types>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> key_type       <span style=color:#f92672>=</span> Key;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> mapped_type    <span style=color:#f92672>=</span> Val;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> value_type     <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>Key, Val<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> key_compare    <span style=color:#f92672>=</span> Cmp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> allocator_type <span style=color:#f92672>=</span> Allocator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> container_type  <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>value_type, Allocator<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> reference       <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>reference;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> pointer         <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>pointer;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> const_reference <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>const_reference;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> const_pointer   <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>const_pointer;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> iterator        <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>iterator;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> const_iterator  <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>const_iterator;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> size_type       <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>size_type;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> difference_type <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>difference_type;
</span></span></code></pre></div><h2 id=member-functions>Member Functions
<a class=anchor href=#member-functions>#</a></h2><h3 id=constructors>Constructors
<a class=anchor href=#constructors>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span></code></pre></div><p>Constructs an empty <code>ordered_map</code>.</p><h3 id=constructors-comparator-allocator>Constructors (Comparator, Allocator)
<a class=anchor href=#constructors-comparator-allocator>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>ordered_map</span>(<span style=color:#66d9ef>const</span> Cmp<span style=color:#f92672>&amp;</span> cmp, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc <span style=color:#f92672>=</span> Allocator());
</span></span><span style=display:flex><span><span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>ordered_map</span>(<span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc);
</span></span></code></pre></div><p>Constructs an <code>ordered_map</code> with a specified comparator for key comparison and an allocator for memory management.</p><h3 id=copy-and-move-constructors>Copy and Move Constructors
<a class=anchor href=#copy-and-move-constructors>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map(<span style=color:#66d9ef>const</span> ordered_map<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>ordered_map(ordered_map<span style=color:#f92672>&amp;&amp;</span>)      <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ordered_map(<span style=color:#66d9ef>const</span> ordered_map<span style=color:#f92672>&amp;</span> other, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc);
</span></span><span style=display:flex><span>ordered_map(ordered_map<span style=color:#f92672>&amp;&amp;</span> other, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc);
</span></span></code></pre></div><p>Constructs an <code>ordered_map</code> by copying or moving the contents from another <code>ordered_map</code>.
An allocator can also be specified for memory management.</p><h3 id=constructors-iterator>Constructors (Iterator)
<a class=anchor href=#constructors-iterator>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> InputIterator<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>ordered_map(InputIterator first, InputIterator last, <span style=color:#66d9ef>const</span> Cmp<span style=color:#f92672>&amp;</span> cmp <span style=color:#f92672>=</span> Cmp(), <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc <span style=color:#f92672>=</span> Allocator());
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> InputIterator<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>ordered_map(InputIterator first, InputIterator last, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc <span style=color:#f92672>=</span> Allocator());
</span></span></code></pre></div><p>Constructs an <code>ordered_map</code> with a range represented by iterators.
The order of the elements follows the order of the iterators.</p><h3 id=constructors-stdinitializer_list>Constructors (std::initializer_list)
<a class=anchor href=#constructors-stdinitializer_list>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map(std<span style=color:#f92672>::</span>initializer_list<span style=color:#f92672>&lt;</span>value_type<span style=color:#f92672>&gt;</span> v, <span style=color:#66d9ef>const</span> Cmp<span style=color:#f92672>&amp;</span> cmp <span style=color:#f92672>=</span> Cmp(), <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc <span style=color:#f92672>=</span> Allocator());
</span></span><span style=display:flex><span>ordered_map(std<span style=color:#f92672>::</span>initializer_list<span style=color:#f92672>&lt;</span>value_type<span style=color:#f92672>&gt;</span> v, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc);
</span></span></code></pre></div><p>Initializes the <code>ordered_map</code> using an initializer list.</p><h3 id=copy-and-move-assignment-operators>Copy and Move Assignment Operators
<a class=anchor href=#copy-and-move-assignment-operators>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> ordered_map<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>ordered_map<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(ordered_map<span style=color:#f92672>&amp;&amp;</span>)      <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span></code></pre></div><p>Assigns the contents of another <code>ordered_map</code> to this one, using copy or move semantics.</p><h3 id=assignment-operator-stdinitializer_list>Assignment Operator (std::initializer_list)
<a class=anchor href=#assignment-operator-stdinitializer_list>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(std<span style=color:#f92672>::</span>initializer_list<span style=color:#f92672>&lt;</span>value_type<span style=color:#f92672>&gt;</span> v);
</span></span></code></pre></div><p>Assigns the contents of an initializer list to the <code>ordered_map</code>.</p><h3 id=destructor>Destructor
<a class=anchor href=#destructor>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>~</span>ordered_map() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span></code></pre></div><p>Destroys the <code>ordered_map</code>.</p><h3 id=begin-end><code>begin()</code>, <code>end()</code>
<a class=anchor href=#begin-end>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>iterator       <span style=color:#a6e22e>begin</span>()        <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>iterator       <span style=color:#a6e22e>end</span>()          <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>begin</span>()  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>end</span>()    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>cbegin</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>cend</span>()   <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>Returns iterators to the beginning and end of the container, allowing iteration over its contents in order.</p><h3 id=empty><code>empty()</code>
<a class=anchor href=#empty>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>empty</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>Returns <code>true</code> if the <code>ordered_map</code> is empty, <code>false</code> otherwise.</p><h3 id=size><code>size()</code>
<a class=anchor href=#size>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t size() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>Returns the number of elements in the <code>ordered_map</code>.</p><h3 id=max_size><code>max_size()</code>
<a class=anchor href=#max_size>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t max_size() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>Returns the maximum number of elements the <code>ordered_map</code> can hold.</p><h3 id=clear><code>clear()</code>
<a class=anchor href=#clear>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clear</span>();
</span></span></code></pre></div><p>Clears all elements from the <code>ordered_map</code>.</p><h3 id=push_backkv><code>push_back(kv)</code>
<a class=anchor href=#push_backkv>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push_back</span>(<span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push_back</span>(value_type<span style=color:#f92672>&amp;&amp;</span>);
</span></span></code></pre></div><p>Appends a key-value pair to the end of the <code>ordered_map</code>.</p><h3 id=emplace_backk-v><code>emplace_back(k, v)</code>
<a class=anchor href=#emplace_backk-v>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>emplace_back</span>(key_type, mapped_type);
</span></span></code></pre></div><p>Appends a key-value pair to the end of the <code>ordered_map</code> by constructing it in place.</p><h3 id=pop_back><code>pop_back()</code>
<a class=anchor href=#pop_back>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pop_back</span>();
</span></span></code></pre></div><p>Removes the last element from the <code>ordered_map</code>.</p><h3 id=insertkv><code>insert(kv)</code>
<a class=anchor href=#insertkv>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(value_type);
</span></span></code></pre></div><p>Inserts a key-value pair at the end of the <code>ordered_map</code>.</p><h3 id=emplacek-v><code>emplace(k, v)</code>
<a class=anchor href=#emplacek-v>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>emplace</span>(key_type, mapped_type);
</span></span></code></pre></div><p>Inserts a key-value pair at the end of the <code>ordered_map</code> by constructing it in place.</p><h3 id=countk><code>count(k)</code>
<a class=anchor href=#countk>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t count(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span>) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>Returns the number of elements with the specified key.
Since duplicate keys are not allowed, this will return either <code>1</code> if the key exists or <code>0</code> if it does not.</p><h3 id=containsk><code>contains(k)</code>
<a class=anchor href=#containsk>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>contains</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span>) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>Returns <code>true</code> if the <code>ordered_map</code> contains an element with the specified key, <code>false</code> otherwise.</p><h3 id=findk><code>find(k)</code>
<a class=anchor href=#findk>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>iterator       <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> key)       <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> key) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>Finds an element with the specified key and returns an iterator to it. If the key is not found, returns <code>end()</code>.</p><h3 id=atk><code>at(k)</code>
<a class=anchor href=#atk>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>mapped_type<span style=color:#f92672>&amp;</span>       at(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> k);
</span></span><span style=display:flex><span>mapped_type <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> at(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> k) <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><p>Finds an element with the specified key and returns a reference to its value. Throws <code>std::out_of_range</code> if the key is not found.</p><h3 id=operatork><code>operator[](k)</code>
<a class=anchor href=#operatork>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>mapped_type<span style=color:#f92672>&amp;</span>       <span style=color:#66d9ef>operator</span>[](<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> k);
</span></span><span style=display:flex><span>mapped_type <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span>[](<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> k) <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><p>Finds an element with the specified key and returns a reference to its value.
If the key is not found, a new value is constructed and returned.
If the <code>ordered_map</code> is <code>const</code>, throws <code>std::out_of_range</code> instead.</p><h3 id=erase><code>erase(...)</code>
<a class=anchor href=#erase>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>iterator <span style=color:#a6e22e>erase</span>(iterator pos);
</span></span><span style=display:flex><span>iterator <span style=color:#a6e22e>erase</span>(const_iterator pos);
</span></span><span style=display:flex><span>iterator <span style=color:#a6e22e>erase</span>(const_iterator first, const_iterator last);
</span></span><span style=display:flex><span>size_type <span style=color:#a6e22e>erase</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> key);
</span></span></code></pre></div><p>Removes values pointed by an iterator or a value corresponding to a key.</p><h3 id=key_comp><code>key_comp()</code>
<a class=anchor href=#key_comp>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>key_compare <span style=color:#a6e22e>key_comp</span>() <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><p>Returns the comparator used for key comparison.</p><h2 id=notes>Notes
<a class=anchor href=#notes>#</a></h2><h3 id=key-modification>Key Modification
<a class=anchor href=#key-modification>#</a></h3><blockquote class="book-hint warning"><p>Since <code>ordered_map</code> uses <code>std::pair&lt;Key, Val></code> for <code>value_type</code>, it is possible to modify the key through an iterator. However, this practice is not recommended.</p><p>If you modify a key this way and it conflicts with an existing key, one of the conflicting keys will become unsearchable.</p><p>When using <code>operator[]</code>, <code>push_back</code>, or <code>insert</code>, collisions with existing keys are detected.</p></blockquote><h3 id=order-preservation-details>Order Preservation Details
<a class=anchor href=#order-preservation-details>#</a></h3><blockquote class="book-hint warning"><p><code>ordered_map</code> maintains the order of keys, but this order preservation applies only to keys defined within the same table. Order across different tables is not maintained.</p><p>For example, the order in the following file will be preserved:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>apple.type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fruit&#34;</span>
</span></span><span style=display:flex><span>apple.skin <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;thin&#34;</span>
</span></span><span style=display:flex><span>apple.color <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;red&#34;</span>
</span></span><span style=display:flex><span>orange.type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fruit&#34;</span>
</span></span><span style=display:flex><span>orange.skin <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;thick&#34;</span>
</span></span><span style=display:flex><span>orange.color <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;orange&#34;</span>
</span></span></code></pre></div><p>In contrast, the order in the following file will not be preserved:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>apple.type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fruit&#34;</span>
</span></span><span style=display:flex><span>orange.type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fruit&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>apple.skin <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;thin&#34;</span>
</span></span><span style=display:flex><span>orange.skin <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;thick&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>apple.color <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;red&#34;</span>
</span></span><span style=display:flex><span>orange.color <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;orange&#34;</span>
</span></span></code></pre></div><p><code>ordered_map</code> preserves the order of the <code>apple</code> and <code>orange</code> definitions at the root table level, and the order of <code>type</code>, <code>skin</code>, <code>color</code> within each <code>apple</code> and <code>orange</code> table.</p></blockquote><h2 id=related>Related
<a class=anchor href=#related>#</a></h2><ul><li><a href=https://toruniina.github.io/toml11/docs/reference/parser/>parser.hpp</a></li><li><a href=https://toruniina.github.io/toml11/docs/reference/types/>types.hpp</a></li><li><a href=https://toruniina.github.io/toml11/docs/reference/value/>value.hpp</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#ordered_maphpp>ordered_map.hpp</a></li><li><a href=#class-ordered_map><code>class ordered_map</code></a><ul><li><a href=#non-member-types>Non-Member Types</a></li><li><a href=#member-types>Member Types</a></li><li><a href=#member-functions>Member Functions</a><ul><li><a href=#constructors>Constructors</a></li><li><a href=#constructors-comparator-allocator>Constructors (Comparator, Allocator)</a></li><li><a href=#copy-and-move-constructors>Copy and Move Constructors</a></li><li><a href=#constructors-iterator>Constructors (Iterator)</a></li><li><a href=#constructors-stdinitializer_list>Constructors (std::initializer_list)</a></li><li><a href=#copy-and-move-assignment-operators>Copy and Move Assignment Operators</a></li><li><a href=#assignment-operator-stdinitializer_list>Assignment Operator (std::initializer_list)</a></li><li><a href=#destructor>Destructor</a></li><li><a href=#begin-end><code>begin()</code>, <code>end()</code></a></li><li><a href=#empty><code>empty()</code></a></li><li><a href=#size><code>size()</code></a></li><li><a href=#max_size><code>max_size()</code></a></li><li><a href=#clear><code>clear()</code></a></li><li><a href=#push_backkv><code>push_back(kv)</code></a></li><li><a href=#emplace_backk-v><code>emplace_back(k, v)</code></a></li><li><a href=#pop_back><code>pop_back()</code></a></li><li><a href=#insertkv><code>insert(kv)</code></a></li><li><a href=#emplacek-v><code>emplace(k, v)</code></a></li><li><a href=#countk><code>count(k)</code></a></li><li><a href=#containsk><code>contains(k)</code></a></li><li><a href=#findk><code>find(k)</code></a></li><li><a href=#atk><code>at(k)</code></a></li><li><a href=#operatork><code>operator[](k)</code></a></li><li><a href=#erase><code>erase(...)</code></a></li><li><a href=#key_comp><code>key_comp()</code></a></li></ul></li><li><a href=#notes>Notes</a><ul><li><a href=#key-modification>Key Modification</a></li><li><a href=#order-preservation-details>Order Preservation Details</a></li></ul></li><li><a href=#related>Related</a></li></ul></li></ul></nav></div></aside></main></body></html>