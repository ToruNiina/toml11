[{"id":0,"href":"/toml11/ja/docs/installation/","title":"installation","section":"Docs","content":" installation # single_includeを使用する # single_include/toml.hppは、toml11が持つ全ての機能を単一のファイルにまとめたシングルファイル・ヘッダオンリーライブラリです。\nこれをINCLUDE_PATHが通っている箇所にコピーして#include \u0026lt;toml.hpp\u0026gt;とするのが最も単純な使用方法です。\nMITライセンスの許諾表示はコメントとtoml:license_notice()関数の両方に含まれます。 ソースコードを公開せずに再頒布する場合は、toml11のライセンスファイルをコピーして同梱するか、この関数を呼び出せるようにしておいてください。\ntoml11をクローンし、cmakeを使って使用する # toml11をgit submoduleなどによって自身のレポジトリ下に配置した場合、cmakeを使用している場合はadd_subdirectory(toml11)のようにすることで使用可能になります。\nadd_subdirectory(toml11) add_executable(main main.cpp) target_link_libraries(main PUBLIC toml11::toml11) toml11は自身がルートプロジェクトのときのみ、テストとインストールを行います。\nCMake FetchContent # CMakeの FetchContentを使用することで、buildディレクトリに自動でダウンロードすることができます。\ninclude(FetchContent) FetchContent_Declare( toml11 GIT_REPOSITORY https://github.com/ToruNiina/toml11.git GIT_TAG v4.4.0 ) FetchContent_MakeAvailable(toml11) add_executable(main main.cpp) target_link_libraries(main PRIVATE toml11::toml11) CMake Package Manager (CPM) # CMake package managerを導入すると、以下のようにして使用することができます。\ninclude(cmake/CPM.cmake) CPMAddPackage(\u0026#34;gh:ToruNiina/toml11@4.4.0\u0026#34;) # OR CPMAddPackage( NAME toml11 GITHUB_REPOSITORY \u0026#34;ToruNiina/toml11\u0026#34; VERSION 4.4.0 OPTIONS \u0026#34;TOML11_PRECOMPILE ON\u0026#34; # to pre-compile \u0026#34;TOML11_ENABLE_ACCESS_CHECK ON\u0026#34; # to use value.accessed() ) add_executable(main main.cpp) target_link_libraries(main PUBLIC toml11::toml11) cmakeを使用してインストールする # toml11をクローンしたのち、cmakeを使ってインストールすることができます。\n$ cmake -B ./build/ -DTOML11_BUILD_TESTS=ON $ cmake --install ./build/ --prefix=/opt/toml11 インストールの前にテストプログラムを実行する際は、最初に-DTOML11_BUILD_TESTS=ONを設定してください。\nインストールが完了すれば、以下のようにして使用できます。\nfind_package(toml11) add_executable(main main.cpp) target_link_libraries(main PRIVATE toml11::toml11) cmakeを使用してコンパイルし、静的ライブラリを作成する # cmakeの実行時に-DTOML11_PRECOMPILE=ONを定義することで、toml11の関数のうちコンパイルできるものを先にコンパイルして、全体のコンパイル時間を短縮することができます。\n$ cmake -B ./build/ -DTOML11_PRECOMPILE=ON ライブラリをリンクする場合は、CMakeで\ntarget_link_libraries(your_target PUBLIC toml11::toml11) とするか、ヘッダ内の関数のinline化を避けるためにコンパイラに-DTOML11_COMPILE_SOURCESを渡してください。\nただし、toml11は複数のC++バージョンに対応するため、__cplusplusの値などによって型を切り替えることがあります。 そのため、ビルドした際のバージョンと使用時のバージョンが異なる場合、リンクに失敗する可能性があります。 問題が生じた場合はCMAKE_CXX_STANDARDによって必要なバージョンを設定してコンパイルしてください。 それが難しい場合は、通常通りヘッダオンリーライブラリとして使用してください。\nfind_package(toml11)によってTOML11_INCLUDE_DIRが定義されます。 コンパイル済みライブラリとしてインストールした場合でも、 TOML11_INCLUDE_DIR を include_directories に追加した上で target_link_libraries を 使用しないようにすれば、ヘッダオンリーライブラリとして使用可能です。\nfind_package(toml11) add_executable(main main.cpp) # インクルードのみ可能にし、リンクを行わない target_include_directories(main PRIVATE ${TOML11_INCLUDE_DIR}) examplesをコンパイルする # -DTOML11_BUILD_EXAMPLES=ONとすることで、examples/をコンパイルできます。\n$ cmake -B ./build/ -DTOML11_BUILD_EXAMPLES=ON $ cmake --build ./build/ examplesの実行バイナリはexamples/に生成されます。\nテストを実行する # テストをビルドするためには、-DTOML11_BUILD_TESTS=ONとします。\n$ git submodule update --init --recursive $ cmake -B ./build/ -DTOML11_BUILD_TESTS=ON $ cmake --build ./build/ $ ctest --test_dir ./build/ toml-lang/toml-testsを実行するには、-DTOML11_BUILD_TOML_TESTS=ONとします。 すると、tests/にtoml11_decoderとtoml11_encoderがビルドされます。\n$ git submodule update --init --recursive $ cmake -B ./build/ -DTOML11_BUILD_TOML_TESTS=ON $ cmake --build ./build/ $ ctest --test_dir ./build/ "},{"id":1,"href":"/toml11/ja/docs/features/","title":"features","section":"Docs","content":" features # ここでは、toml11が提供する主な機能について、例を挙げながら説明します。\nファイル・文字列をパースする # ファイルや文字列をパースする関数と、それが出力するエラーの扱い方について説明します。\n以下の内容を含みます。\nファイルをパースする 文字列をパースする バイト列をパースする 例外を投げずにファイルをパースする 例外を投げずに文字列をパースする 例外を投げずにバイト列をパースする toml::valueから値を取り出す # toml::valueが持つデータの型を調べ、取り出す方法、型変換を行う方法について説明します。\n以下の内容を含みます。\nメンバ関数を使って値の型を調べる メンバ関数を使って値にアクセスする コメントにアクセスする インラインテーブル・ドットキーの取り扱い 日付情報の取り扱い toml::get\u0026lt;T\u0026gt;を使って変換する toml::get_orを使って失敗時の値を指定する toml::find\u0026lt;T\u0026gt;を使って検索と変換を行う toml::find_orを使って失敗時の値を指定する ユーザー定義型との変換を定義する toml::visitで関数を適用する toml::valueを構築する エラーメッセージを作る # toml::valueの値を使って、TOMLファイル中の位置情報つきのエラーメッセージを生成する方法について説明します。\n以下の内容を含みます。\ntoml::value の位置情報を取り出す エラーメッセージを構築する 出力に色を付ける TOMLファイルを出力する # toml::valueの値をフォーマットする方法と、可能なフォーマット指定について説明します。\n以下の内容を含みます。\ntoml::valueの値ごとにフォーマットを指定する toml::valueをフォーマットして文字列化する toml::valueの型を変更する # toml::valueが格納する型（integer_typeやtable_typeをカスタマイズする方法について説明します。\n以下の内容を含みます。\ntype_configの定義 ordered_type_configを使用する コメントを保存しないようにする std::dequeなどの異なるコンテナを使用する boost::multiprecisionなどの異なる数値型を使用する TOMLリテラル # C++内にTOMLファイルを埋め込むための_tomlリテラルについて説明します。\n以下の内容を含みます。\nTOMLリテラルを使用する TOML言語バージョン # toml11がサポートするTOML言語のバージョン、主にTOML-v1.1.0で追加された言語機能を制御する方法について説明します。\n以下の内容を含みます。\nTOML言語の1.1.0を使用する TOML言語の1.1.0の一部の機能のみ使用する TOML言語拡張 # toml11独自のTOML言語拡張について説明します。\n以下の内容を含みます。\nnull をサポートする 浮動小数点数の16進数フォーマットをサポートする 数値に単位を付けられるようにする "},{"id":2,"href":"/toml11/ja/docs/reference/","title":"reference","section":"Docs","content":" Reference # 以下では、toml11が公開するクラスと関数の効果を説明します。\nディレクトリ構造 # toml.hpp と toml_fwd.hpp は ${TOML11_INCLUDE_DIR} にあります。 他のファイルは、${TOML11_INCLUDE_DIR}/toml11 にあります。\nもし各機能のファイルを個別に #include したい場合は、 #include \u0026lt;toml11/color.hpp\u0026gt; としてください。 全てを一度に #include する場合は、 #include \u0026lt;toml.hpp\u0026gt; としてください。\ncolor.hpp # エラーメッセージの色付けに関する関数を定義します。\ncomments.hpp # コメントを持つpreserve_comment型とdiscard_comment型を定義します。\nconversion.hpp # toml::valueとユーザー定義クラスを自動的に変換するマクロを定義します。\ndatetime.hpp # 日時情報を持つクラスを定義します。\nerror_info.hpp # エラー情報を持つクラスを定義します。\nexception.hpp # toml11で使用される例外の基底クラス、toml::exceptionを定義します。\nfind.hpp # 値を探し変換するtoml::find関数を定義します。\nformat.hpp # 値のフォーマット情報を持つクラスを定義します。\nfrom.hpp # ユーザー定義型を変換するためのfrom\u0026lt;T\u0026gt;型の前方宣言です。\nget.hpp # toml::valueの値を取り出し変換するtoml::get\u0026lt;T\u0026gt;関数を定義します。\ninto.hpp # ユーザー定義型を変換するためのinto\u0026lt;T\u0026gt;型の前方宣言です。\nliteral.hpp # operator\u0026quot;\u0026quot; _tomlリテラルを定義します。\nordered_map.hpp # toml::ordered_mapを定義します。\nparser.hpp # ファイルまたは文字列をパースする関数を定義します。\nresult.hpp # 他の関数の返り値として使われる、成功値または失敗値を持つresult\u0026lt;T, E\u0026gt;型を定義します。\nserializer.hpp # シリアライズに用いるtoml::format関数とtoml::serializerを定義します。\nsource_location.hpp # エラー情報に用いられる、ファイル内のある領域を指すsource_location型を定義します。\nspec.hpp # TOML言語のバージョン情報と機能フラグを制御する、toml::semantic_version型とtoml::spec型を定義します。\ntoml.hpp # toml.hppは、他の全てのヘッダを include します。 toml11の全機能が使用可能になります。\ntoml_fwd.hpp # toml_fwd.hppは、toml11で定義される構造体の前方宣言と、マクロ定義を持ちます。\ntypes.hpp # toml::valueの持つ型を制御するためのtoml::type_config型を定義します。\nvalue.hpp # toml::value型を定義します。\nvalue_t.hpp # 列挙型toml::value_tを定義します。\nversion.hpp # toml11のバージョン情報を定義します。\nvisit.hpp # toml::valueの持つ値に関数を適用するtoml::visit関数を定義します。\n備考 # ここで明記されない関数（主にnamespace toml::detailやnamespace toml::cxx以下に定義されるもの）は、 ソースコードを見ることで利用可能ではあるものの、そのインターフェースは今後のいかなるバージョンアップでも（パッチバージョンアップを含む）維持される保証はありません。\n"},{"id":3,"href":"/toml11/ja/docs/changelog/","title":"changelog","section":"Docs","content":" Change Log # v4.4.0 # Added # toml::find_or_default() を追加 (by Ken Matsui @ken-matsui) ordered_mapから値を削除できるよう変更 (by Sunlight @SunPodder) 値がアクセス済みかを調べるbool basic_value::accessed() constを追加 TOML11_ENABLE_ACCESS_CHECKが定義されているときのみ有効 toml::specに比較演算子を追加 Fixed # is_same\u0026lt;T, void\u0026gt;ではなくis_voidを使用するように修正 (by Ken Matsui @ken-matsui) Changed # toml::parseのパフォーマンスを約2倍向上 GitHub ActionsでUbuntu 20のイメージの使用を終了 v4.3.0 # Added # toml::findでstd::optional\u0026lt;T\u0026gt;をサポート toml::visitで複数の引数をサポート Fixed # 初期化前に変数が使われるケースを修正 (by amatej @kontura) CMake 3.21以前を使用する際の修正 (by Severin Leonhardt @SeverinLeonhardt) 非常に巨大な文字列が作成されるケースを修正 (by @hayt) READMEのサンプルコードを修正、ToCを増強 (by somebody @oldoldtea) (by lz) 長い行のパースを高速化 MSVC 2017でのコンパイルエラーを修正 source_location::file_nameのヌルチェックを追加 Changed # hugo-bookテーマをアップデート MSVC 2017をappveyor buildに追加 v4.2.0 # Added # TOML11_DEFINE_CONVERSION_NON_INTRUSIVE で std::optional なメンバをサポート (by Ken Matsui @ken-matsui) thread_localだったcolor_modeをデフォルトでグローバルにし、thread_localにするオプションを追加 (by Ken Matsui @ken-matsui) CPMでの使い方をREADMEに追加 READMEにordered_mapへの言及を追加し、ドキュメントでの説明を追加 Fixed # ファイルサイズのstd::streamsizeへの変換で警告が出ることがある問題を修正 (by Pino Toscano @pinotree) table_formatに不正な値が与えられた際の出力のtypoを修正 arrayのフォーマットがarray_of_tablesと指定されていてかつ空の場合の出力を修正 特定の環境でincludeが足りずにコンパイルできない問題を修正 ドキュメントに含まれる文法エラーを修正 (by Jack W) toml::find_or を深くネストされたテーブルに使用した際にコンパイルが失敗する問題を修正 v4.1.0 # Added # std::get\u0026lt;std::u8string\u0026gt;をサポート toml::value(std::u8string)をサポート string_type = std::u8stringをサポート operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, toml::value)をサポート toml::integer_formatに、16進数表示で大文字を使うことを指定するbool uppercaseを追加 templateを使って実装された into_toml() をサポート (by 萧迩珀) Fixed # Windowsで\\r\\nが改行に使われた際、出力時に\\rが重複する問題を修正 (by Andreas Keller) Changed # CIで複数コアを使うことでビルドを高速化 v4.0.3 # Fixed # toml_fwd.hppを使用した際にデフォルト引数が重複する問題を修正 toml::valueを複数渡した際にtoml::make_error_infoが使えない問題を修正 std::reference_wrapperを持つtoml::resultをコピー・ムーブする際の問題を修正 hugoの最新版でドキュメントがビルドできない問題を修正 コンパイラによる軽微な警告を多数修正 CMakeの互換性に関する警告を抑制 Changed # CIビルドで-Werror, /WXを追加 CIビルドでMSVCのwarningレベルを/W3から/W4に変更 READMEでより多くの機能を紹介するよう更新 v4.0.2 # Fixed # parse(FILE*) 内の fread の結果をチェック toml11/version.hppのマクロを修正 コンパイルオプションに関するドキュメントの更新 ファイルオープンモードに関するドキュメントの更新 Changed # CMakeLists.txt内のバージョン番号をversion.hppから取得するように変更 v4.0.1 # Fixed # sematic_version::{major, minor} と \u0026lt;sys/sysmacro.h\u0026gt; 内で定義されるマクロの衝突を解消 discard_comments の operator\u0026lt;\u0026lt; の定義を修正 (by Egor Pugin) format_locationを使用した際に最初の空行が出ない問題を解決 改行文字のみを含む行を指すsource_locationでエラーメッセージを生成した際に、同じ行が二回表示される問題を解決 README.md内のリンクを修正 example/unicodeのREADMEのタイトルを修正 Added # mainに変更があったとき、single_include/toml.hppを自動生成するようCIを設定 v3からv4への変化 # 破壊的変更 # toml::basic_valueのtemplate引数を変更 # toml11 v3では、toml::basic_valueはコメントコンテナ、テーブル型コンテナ、配列型コンテナをそれぞれ取っていました。\ntemplate\u0026lt;typename Comment, template\u0026lt;typename ...\u0026gt; class Table = std::unordered_map, template\u0026lt;typename ...\u0026gt; class Array = std::vector\u0026gt; class basic_value; ですが、integer_typeなどを変更したいという場合にはこれでは対応できません。\ntoml11 v4では、toml::basic_valueは単一のTypeConfigを受け取り、より多くの型を変更可能にします。\ntemplate\u0026lt;typename TypeConfig\u0026gt; class basic_value; デフォルトではtoml::valueが格納する型は変わりません。\n型を変更する際は、 type_config を参照してください。\ntoml::basic_valueのstd::initializer_listサポートを削除 # toml11 v3では、 toml::value に std::initializer_list を取るオーバーロードが用意されていました。\nこれにより、 toml::value を配列やテーブルで初期化する際により直観的な書き方が可能でした。\n// toml11 v3 toml::value v{1,2,3,4,5}; toml::value v{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;b\u0026#34;, \u0026#34;foo\u0026#34;} }; しかし、これは同時に以下のような問題を引き起こしました。\n一つ目は、1要素の配列と通常の値の区別がつかず、常に配列になってしまうことです。\n// toml11 v3 toml::value v{1}; // 1 ではなく [1,] になってしまう 統一初期化記法が普及した現在、これは非常に不便です。\n二つ目は、値が全て文字列のテーブルと、ネストされた配列の区別がつかないことです。\n// toml11 v3 toml::value v{ {\u0026#34;a\u0026#34;, \u0026#34;foo\u0026#34;}, {\u0026#34;b\u0026#34;, \u0026#34;bar\u0026#34;} }; // {a = \u0026#34;foo\u0026#34;, b = \u0026#34;bar\u0026#34;} // [[\u0026#34;a\u0026#34;, \u0026#34;foo\u0026#34;], [\u0026#34;b\u0026#34;, \u0026#34;bar\u0026#34;]] // のどちらでもあり得る これらの問題は言語仕様上解決が困難です。\ntoml11 v4では、混乱を避けるため、std::initializer_listサポートを削除しました。\ntoml::value を配列で初期化する際はexplicitに toml::array を、 テーブルで初期化する際はexplicitに toml::table を指定する必要があります。\n// toml11 v4 toml::value v(toml::array{1,2,3,4,5}); toml::value v(toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;b\u0026#34;, \u0026#34;foo\u0026#34;} }); toml::value v{toml::array{1}}; // [1,] toml::value v{1} // 1 toml::value v{toml::table{{\u0026#34;a\u0026#34;, \u0026#34;foo\u0026#34;}, {\u0026#34;b\u0026#34;, \u0026#34;bar\u0026#34;}}}; toml::value v{toml::array{toml::array{\u0026#34;a\u0026#34;, \u0026#34;foo\u0026#34;}, toml::array{\u0026#34;b\u0026#34;, \u0026#34;bar\u0026#34;}}}; これにより toml::value をテーブルや配列で初期化する際に少し不便になりますが、 explicitに型情報を記述することにより予測不能な値になることは避けることができます。\ntoml::basic_value::is_uninitialized() を is_empty() に変更 # toml11 v3では、初期化されていない basic_value かどうかを判定する関数は is_uninitialized でした。\nしかし、toml11 v4では言語拡張で null をサポートするため、意図的に空にされた値が構築される可能性があります。 なので命名を変更し、 is_empty としました。\ntoml::string を廃止、フォーマット情報を陽に格納 # toml11 v3では、文字列が basic か literal かの情報を保持するため、 格納する文字列型に toml::string という std::string の薄いラッパーを使用していました。\n// toml11 v3 namespace toml { enum class string_t : std::uint8_t { basic = 0, literal = 1, }; struct string { string_t kind; std::string str; }; } // toml toml11 v4では、数値型の基数や配列を複数行にするかどうかなどのより多くのフォーマット情報を持たせるため、 全ての型に xxx_format 型を用意し、値とペアで格納することにしました。\n// toml11 v4 enum class string_format : std::uint8_t { basic = 0, literal = 1, multiline_basic = 2, multiline_literal = 3 }; struct string_format_info { string_format fmt = string_format::basic; bool start_with_newline = false; }; これにより、より細かいフォーマット情報を保持することができるようになり、 特に数値型や配列、テーブル型のフォーマット情報がパース後も維持できるようになりました。\ntoml::formatの引数を変更 # toml11 v3では、 toml::format が数値型の精度や幅などの値を受け取っていました。\nしかし、これでは細かなフォーマット指定ができず、予想したようなファイルにシリアライズできませんでした。\ntoml11 v4では、各 toml::value にそれぞれのフォーマット情報を格納したため、 より細かいフォーマット情報を toml::value 自体が持ち運べるようになりました。\nこれにより、 toml::format 自体はフォーマット指定を受け取らず、 フォーマット時に使用できる言語機能フラグを持つ toml::spec のみを取るようになりました。\ntoml::source_locationのメンバ関数を変更 # toml11 v3では、 toml::source_location のメンバ型は一行分だけを意識したものでした。\ntoml11 v4では、 toml::source_location のメンバ型は複数行が前提になります。\ntoml::format_underlineをtoml::format_locationに変更 # toml11 v3では、 toml::source_location を使用して位置情報を文字列化するとき、 toml::format_underline を使用していました。\nしかしこれは名称としてわかりにくいため、 toml::format_location に変更しました。\nformat_errorの引数を変更 # toml11 v3ではエラー情報を表すクラスがなかったため、toml::format_errorの引数が複雑になっていました。\ntemplate\u0026lt;typename C, template\u0026lt;typename ...\u0026gt; class T, template\u0026lt;typename ...\u0026gt; class A\u0026gt; std::string format_error(const std::string\u0026amp; err_msg, const basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v, const std::string\u0026amp; comment, std::vector\u0026lt;std::string\u0026gt; hints = {}, const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED); template\u0026lt;typename C, template\u0026lt;typename ...\u0026gt; class T, template\u0026lt;typename ...\u0026gt; class A\u0026gt; inline std::string format_error(const std::string\u0026amp; err_msg, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v1, const std::string\u0026amp; comment1, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v2, const std::string\u0026amp; comment2, std::vector\u0026lt;std::string\u0026gt; hints = {}, const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED); template\u0026lt;typename C, template\u0026lt;typename ...\u0026gt; class T, template\u0026lt;typename ...\u0026gt; class A\u0026gt; inline std::string format_error(const std::string\u0026amp; err_msg, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v1, const std::string\u0026amp; comment1, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v2, const std::string\u0026amp; comment2, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v3, const std::string\u0026amp; comment3, std::vector\u0026lt;std::string\u0026gt; hints = {}, const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED); toml11 v4では、class error_infoとmake_error_infoを導入し、format_errorの引数を簡略化しました。\nstd::string format_error(const error_info\u0026amp; err); std::string format_error(const std::string\u0026amp; errkind, const error_info\u0026amp; err); template\u0026lt;typename ... Ts\u0026gt; std::string format_error(std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); template\u0026lt;typename TC, typename ... Ts\u0026gt; std::string format_error(std::string title, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, std::string msg, Ts\u0026amp;\u0026amp; ... tail); toml::color の制御を変更 # toml11 v3では、出力に色を付けるかどうかに toml::colorize というマニピュレータを、 toml::color::enable/disable と並列で使用していました。\nマニピュレータはストリームごとに色を付けるかどうかを決定できるものでしたが、 v4でストリームを使用する頻度が下がったことと、内部で使用する std::ios_base::xalloc がC++11ではスレッドセーフではないことなどから、 toml::color::enable/disable のみを使用するようにし、 toml::colorize を削除しました。\n破壊的でない変更 # parse_strの追加 # toml11 v3では、文字列そのものを取るtoml::parse関数はありませんでした。 なので文字列をパースする際にはstd::istringstreamを使う必要がありました。\nこれは不便なので、toml::parse_strを追加し、文字列を直接パース出来るようにしました。\ntry_parseの追加 # toml11 v3では、パーサはエラーを発見した際にはtoml::syntax_errorを送出していました。\nしかし、例外を投げられない環境や、パフォーマンスの都合や記法の都合によって例外を投げたくない場合があります。\ntoml11 v4では toml::result を使用して、例外を投げずにパース失敗を伝える toml::try_parse を実装しました。\nこれも必ず例外を投げないというわけではなく、使用している標準ライブラリの内部でのエラー、 例えばメモリ不足によるアロケーション失敗での std::bad_alloc などは送出される可能性があります。\nバイト列のパースをサポート # ファイルなど以外の方法で得られたTOMLコンテンツをパース出来るようにするため、 std::vector\u0026lt;unsigned char\u0026gt; を受け取る toml::parse, toml::try_parse を追加しました。\ntoml::specの追加 # toml11 v3では、TOML言語側の新機能は全て取り込み、またTOML言語の新バージョンに導入されることが決定した機能も マクロ TOML11_USE_UNRELEASED_TOML_FEATURES によって制御していました。\nこれは、toml11 v3を開発していた時点では TOML言語は0.4.0から0.5.0で、1.0.0に到達していなかったためです。\n最新のTOML言語仕様に全てのユーザーが詳しいわけではないため、 古い言語使用に基づいたエラーメッセージを表示すると、コミュニティ全体を混乱させてしまいます。 よって、v1.0.0に達するまでは、できる限り素早く新しい言語仕様を提供し、かつユーザーにもアップデートを促す必要がありました。\nしかし、現在のTOML言語仕様はv1.0.0です。 そのため、TOML v1.1.0がリリースされた後でもv1.0.0を使用する、という選択肢に気を配る必要が生じました。\nよって、より柔軟にTOML言語仕様を選択できるよう、toml::specを導入して、TOML言語バージョンを実行時に変更できるようにしました。\nまた、toml::specでは言語機能ごとにフラグを設定し、特定の言語機能のみを試すこともできるようにしました。\nこれは、toml11 v4特有の言語拡張でも使用します。\nフォーマット情報の追加 # toml11 v3では、文字列を除いてフォーマット情報が保存されず、シリアライズ時に考慮できるのは幅と精度だけでした。\nしかし、これでは16進数整数がシリアライズ時に10進数になってしまったり、確実にinline tableにする方法がありませんでした。\ntoml11 v4では、全てのTOML型にフォーマット情報（integer_format etc）を追加し、 パース時とシリアライズ時に考慮するようにしました。\nこれによって、16進数整数や、インラインテーブル等のフォーマット情報をより細かく、値ごとに設定できるようになりました。\nデフォルトでコメントを維持するよう変更 # toml11 v3では、デフォルトではコメントがパースされず、シリアライズもされませんでした。\nこれは、コメントが後期に導入された機能で、特別なハックによって読み込まれていたためです。\ntoml11 v4では、デフォルトでコメントをパースし、保存し、シリアライズするようになりました。\nまた、パーサの実装も大幅に変更され、コメントが他の要素と同様にパースされるようになりました。\nsingle_include/toml.hpp の追加 # toml11は多機能なライブラリなので、開発効率のために機能ごとに異なるヘッダファイルを持っています。 ですが、これはインストールにある程度の手間が必要ということでもあります。\nそこで、toml11 v4から全てのヘッダファイルを適切な順序で結合した single_include/toml.hpp ファイルを追加し、 単一のファイルで完結するライブラリをコピーするだけで導入できるようにしました。\nコンパイル済みライブラリを選択可能に # toml11は template を多用しているため、コンパイル時間が長くなります。\ntoml11 v4では、できるだけコンパイル可能な関数を増やし、それらを先にライブラリとしてコンパイルできるようにしました。\nこれにより、大規模な開発で使用する際にコンパイル時間を短くできると期待できます。\nリファレンス・ドキュメントの追加 # これまでは、READMEにすべてのfeatureを記載しており、関数の詳細な定義を示すリファレンスや、また日本語での資料などがありませんでした。\ntoml11 v4では、リファレンスを追加したドキュメントを同梱し、また日本語・英語両方で同一の内容を記載します。\nただし、ライブラリ作者は日本語母語話者であるため、日本語の内容を第一とし、英語の内容がそれと異なっていた場合は日本語の内容が正しいものとします。\n"},{"id":4,"href":"/toml11/ja/docs/features/parsing_files/","title":"parsing files","section":"features","content":" ファイル・文字列をパースする # toml11では、toml::parse や toml::try_parse を使って、ファイルや文字列、バイト列をパースすることができます。\nこれらは成功時に toml::value を返します。 ファイルは常にテーブルになりますが、返り値が toml::table でないことに気を付けてください。 toml::value はファイルに関するメタデータを持っており、 toml::table は std::unordered_map\u0026lt;std::stirng, toml::value\u0026gt; のエイリアスでしかありません。 メタデータを返すために、 toml::table ではなく toml::value を返しています。 ファイルのルートに対応する toml::value は常に table_type を持ちます。\nファイルをパースする # ファイルをパースする際は、 toml::parse または toml::try_parse を使います。\ntoml::parse # std::stringでファイル名を指定する # toml::parse は、文字列でファイル名を受け取り、そのファイルを開いてパースします。\n以下のサンプルは、input.tomlというファイルをパースし、titleという変数を文字列として取り出し、出力するコードです。\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { const toml::value input = toml::parse(\u0026#34;input.toml\u0026#34;); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; return 0; } std::filesystem::pathでファイルを指定する # toml::parse には、std::filesystem::pathを渡すことも可能です。\n当然ですが、\u0026lt;filesystem\u0026gt;がサポートされるC++17以降でなければ使用できません。\nstd::istreamで入力ストリームを指定する # toml::parse には、std::istreamを渡すことも可能です。\n標準ライブラリが改行文字を自動変換することによるファイルサイズと文字数との不整合を避けるため、 std::ios::binaryを使ってバイナリモードで開いてください。\nその際、ファイル名の情報がなくなるため、エラーメッセージ中では \u0026quot;unknown file\u0026quot; となります。\nこれを避けるため、 std::istream を取る場合は第二引数に std::string でファイル名を取ることもできます。\nstd::ifstream 以外にも、 std::istringstream 等の別のistreamを受け取ることができます。 ただし、呼び出した時点で内容が全て読み込める必要があります。\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::string filename(\u0026#34;input.toml\u0026#34;); std::ifstream ifs(filename); const toml::value input = toml::parse(ifs, filename); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; return 0; } FILE*でファイルを指定する # toml::parse には、FILE*を渡すことも可能です。\n標準ライブラリによる改行文字の自動変換によるファイルサイズと文字数との不整合を避けるため、 fopen(\u0026quot;example.toml\u0026quot;, \u0026quot;rb\u0026quot;)のようにしてバイナリモードで開いてください。\nこの場合も、std::istreamのときと同様に、第二引数に文字列でファイル名を与える必要があります。\nFILE*を渡した場合、ファイルの読み込みに失敗した際にはerrnoが報告されます。\nエラー時の挙動 # toml::parse は、文法エラーを発見した場合 toml::syntax_error を送出します。\ntoml::syntax_error は、 toml::exception から派生しており、またそれはstd::exceptionから派生します。\nよって、 toml::syntax_error からは what() メンバ関数を使ってエラーメッセージを取り出すことができます。\nまた、 toml::syntax_error は std::vector\u0026lt;toml::error_info\u0026gt; を持っており、errors()メンバ関数を使ってそれにアクセスすることもできます。\ntoml::parse はごく簡単なエラーならスキップして復帰し、複数のエラーを報告しようと努めます。 数値のフォーマットエラー程度なら復帰できることが多いですが、 配列やテーブルの中のエラーは復帰できずに似たようなエラーを複数回報告することもあります。 冗長であると感じた場合は、 std::vector\u0026lt;toml::error_info\u0026gt; の front() だけを使用するようにすると、 確実に問題のある個所に関するメッセージを得られます。\n#include \u0026lt;toml.hpp\u0026gt; int main() { // parse try { const toml::value input = toml::parse(\u0026#34;input.toml\u0026#34;); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; } catch(const toml::syntax_error\u0026amp; err) { // 全てのエラーを報告 std::cerr \u0026lt;\u0026lt; err.what() \u0026lt;\u0026lt; std::endl; // 最初のエラーのみ報告 std::cerr \u0026lt;\u0026lt; err.errors().front() \u0026lt;\u0026lt; std::endl; } } toml::try_parse # toml::parse は失敗時に例外を送出しますが、 toml::try_parse は失敗時に例外を投げません。\nその代わり、返り値が toml::value ではなく toml::result\u0026lt;toml::value, std::vector\u0026lt;toml::error_info\u0026gt;\u0026gt; になります。\nresult 型は成功値または失敗値のどちらかを持つ型です。 Rustの Result やHaskellの Either に相当します。\n#include \u0026lt;toml.hpp\u0026gt; int main() { const auto parse_result = toml::try_parse(\u0026#34;input.toml\u0026#34;); if(parse_result.is_ok()) { std::cout \u0026lt;\u0026lt; parse_result.unwrap().at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; } else { std::cerr \u0026lt;\u0026lt; parse_result.unwrap_err().at(0) \u0026lt;\u0026lt; std::endl; } return 0; } result 型がどちらの値を保持しているかは is_ok(), is_err() 関数を使って確認できます。 また、 unwrap(), unwrap_err() によって成功値、失敗値をそれぞれ取り出せます。 unwrap が失敗した場合は、 bad_result_access 例外が送出されます。 as_ok() と as_err() 関数を使用すると、失敗時には例外が送出されず、未定義動作となります。\ntry_parse は syntax_error や file_io_error を投げず、同じ toml::error_info を result の失敗型として返しますが、絶対に例外を投げないわけではありません。\n標準ライブラリ内部でエラーが発生した場合、例えばメモリ不足の際に vector の allocate が失敗した場合などには std::bad_alloc が送出されますが、 toml::try_parse はこれが送出された場合は catch せずに通します。 そのため、それらのような標準ライブラリの内部で発生する例外は送出される恐れがあります。\n文字列をパースする # toml::parse_str # toml::parse_str は、ファイル名ではなくパースする文字列そのものを受け取ります。\nまた、エラーメッセージのTOMLファイルの名前に相当する部分には、std::source_location 相当のコンパイラ拡張機能が使用できる場合、 parse_str を呼び出したC++ファイルの名前と行数が代わりに使用されます。\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { const toml::value input = toml::parse_str(\u0026#34;title = \\\u0026#34;parse_str\\\u0026#34;\u0026#34;); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; return 0; } toml::try_parse_str # toml::try_parse_str は、 parse_str と同じくパースする文字列そのものを受け取り、 try_parse と同じくエラーの報告に toml::result を使用します。\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { const auto parse_result = toml::try_parse_str(\u0026#34;title = \\\u0026#34;parse_str\\\u0026#34;\u0026#34;); if(parse_result.is_ok()) { std::cout \u0026lt;\u0026lt; parse_result.unwrap().at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; } else { std::cerr \u0026lt;\u0026lt; parse_result.unwrap_err().at(0) \u0026lt;\u0026lt; std::endl; } return 0; } バイト列をパースする # ファイルではなくバイト列をパースすることも可能です。\nUTF-8でエンコードされている必要があるため、unsigned charを使っています。\ntoml::parse(std::vector\u0026lt;unsigned char\u0026gt;) # 挙動は toml::parse と同一です。\nバイト列をパースする際は、 filename を要求します。\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::vector\u0026lt;unsigned char\u0026gt; bytes{/* ... */}; const toml::value input = toml::parse(bytes, \u0026#34;internal bytes\u0026#34;); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; return 0; } toml::try_parse(std::vector\u0026lt;unsigned char\u0026gt;) # 挙動は toml::try_parse と同一です。\nバイト列をパースする際は、 filename を要求します。\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::vector\u0026lt;unsigned char\u0026gt; bytes{/* ... */}; const auto parse_result = toml::try_parse(bytes, \u0026#34;internal bytes\u0026#34;); if(parse_result.is_ok()) { std::cout \u0026lt;\u0026lt; parse_result.unwrap().at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; } else { std::cerr \u0026lt;\u0026lt; parse_result.unwrap_err().at(0) \u0026lt;\u0026lt; std::endl; } return 0; } "},{"id":5,"href":"/toml11/ja/docs/features/value/","title":"getting values","section":"features","content":" 値を取り出す # ここでは、 toml::value が格納している値にアクセスする方法を説明します。\nメンバ関数を使って値にアクセスする # is_something と as_something # toml::value は is_boolean() や is_integer() などのメンバ関数を持っており、 これらを使うと持っている型を調べることができます。\nまた、 as_boolean(), as_integer() などのメンバ関数も持っており、 これらを使ってその型にアクセスすることができます。\n完全なリストは toml::value のリファレンス を参照してください。\ntoml::value v = /* ... */; if(v.is_integer()) { std::cout \u0026lt;\u0026lt; v.as_integer() \u0026lt;\u0026lt; std::endl; } 指定された値と異なる型が格納されていた場合、 toml::type_error が送出されます。\nその what() は以下のようなメッセージを含みます。\n[error] toml::value::as_string(): bad_cast to string --\u0026gt; input.toml | 1 | a = 123_456 | ^^^^^^^-- the actual type is integer toml::value_t # 型情報は enum class toml::value_t で識別できます。\ntype() メンバ関数は、現時点で格納している値の型情報を返します。\ntoml::value v = /* ... */; switch(v.type()) { case toml:value_t::empty : { /*...*/ break; } case toml:value_t::boolean : { /*...*/ break; } case toml:value_t::integer : { /*...*/ break; } case toml:value_t::floating : { /*...*/ break; } case toml:value_t::string : { /*...*/ break; } case toml:value_t::offset_datetime: { /*...*/ break; } case toml:value_t::local_datetime : { /*...*/ break; } case toml:value_t::local_date : { /*...*/ break; } case toml:value_t::local_time : { /*...*/ break; } case toml:value_t::array : { /*...*/ break; } case toml:value_t::table : { /*...*/ break; } default: {break;} } is(toml::value_t) メンバ関数は、渡された value_t と同じ型の値を格納している場合 true を、 それ以外の場合 false を返します。\ntoml::value v = /* ... */; if(v.is(toml::value_t::integer)) { std::cout \u0026lt;\u0026lt; v.as_integer() \u0026lt;\u0026lt; std::endl; } at, [], contains, size, push_back, emplace_back # 標準ライブラリコンテナが持つメンバ関数の一部は、 toml::value も提供しています。\nこれらは、内部で toml::value を対応する型に変換し、そのメンバ関数を呼び出します。\nat(std::size_t i), operator[](std::size_t i) # as_array().at(i), as_array()[i] と同等です。\ntoml::value はデフォルトで std::vector\u0026lt;toml::value\u0026gt; を array_type に使うので、 エラーが発生した際には at は std::out_of_range を送出し、operator[] は未定義動作となります。\ntoml::value v(toml::array{1,2,3}); std::cout \u0026lt;\u0026lt; v.at(1); 格納している型が array_type ではなかった場合、 type_error を送出します。\nat(std::string key), operator[](std::string key) # as_table().at(key), as_table()[key] と同等です。\ntoml::value はデフォルトで std::unordered_map\u0026lt;std::string, toml::value\u0026gt; を table_type に使うので、 対応する値が存在しない場合は at は std::out_of_range を送出し、 operator[] は新しく toml::value を構築してそれへの参照を返します。 そのため、operator[] に const 版はありません。\ntoml::value v(toml::table{}); v[\u0026#34;a\u0026#34;] = 42; 格納している型が table_type ではなかった場合、 type_error を送出します。\nsize() # 長さを返します。\narray_type または table_type の場合は要素数、 string_type の場合は文字数を返します。\n格納している型がどれでもなかった場合、 type_error を送出します。\npush_back(), emplace_back() # as_array().push_back(), as_array().emplace_back() と同一です。\n格納している型が array_type ではなかった場合、 type_error を送出します。\nコメントにアクセスする # toml11では、デフォルトでコメントがパースされ、対応する値に行ごとに保存されます。\n対応する値は、連続するコメント行の直後に来る値か、もしくはそのコメントと同じ行に描かれている値です。\n直前または直後に値がなければ、そのコメントはどこにも紐づけられず、無視されます。\n# input.toml # これはaに関するコメントです。 a = 42 b = 3.14 # これはbに関するコメントです。 # このコメントには対応する値がないため無視されます。 # これは1番目のcに関するコメントです。 # これは2番目のcに関するコメントです。 c = \u0026#34;foo\u0026#34; # これは最後のcに関するコメントです。 値に対応するコメントには、toml::value の comments() メンバ関数を使ってアクセスします。\ncomments() は std::vector\u0026lt;std::string\u0026gt; と同じメンバ関数を持つコンテナを返します。\nconst auto v = toml::parse(\u0026#34;input.toml\u0026#34;); const auto\u0026amp; a = v.at(\u0026#34;a\u0026#34;); const auto\u0026amp; b = v.at(\u0026#34;b\u0026#34;); const auto\u0026amp; c = v.at(\u0026#34;c\u0026#34;); assert(a.comments().size() == 1); assert(a.comments().at(0) == \u0026#34;# これはaに関するコメントです。\u0026#34;); assert(b.comments().size() == 1); assert(b.comments().at(0) == \u0026#34;# これはbに関するコメントです。\u0026#34;); assert(c.comments().size() == 3); assert(c.comments().at(0) == \u0026#34;# これは1番目のcに関するコメントです。\u0026#34;); assert(c.comments().at(1) == \u0026#34;# これは2番目のcに関するコメントです。\u0026#34;); assert(c.comments().at(2) == \u0026#34;# これは最後のcに関するコメントです。\u0026#34;); ファイル全体に対応するルートテーブルに関するコメントは、ファイルの先頭に書きます。\n# ルートテーブルに関するコメントです。 # これもルートテーブルに関するコメントです。 # これはaに関するコメントです。 a = 42 ただし、もしファイルの先頭のコメントの直後に値が来た場合、 そのコメントはその値に関するコメントと解釈され、ルートテーブルのコメントはなくなります。\n# これはaに関するコメントです。 # これもaに関するコメントです。 a = 42 インラインテーブル・ドットキーの取り扱い # インラインテーブルは単にテーブルで、C++コード上で他のテーブルと異なる点はありません。\na = {b = 42, c = \u0026#34;foo\u0026#34;} ドットキーも単にテーブルで、C++コード上で他のテーブルと異なる点はありません。\na.b = 42 a.c = \u0026#34;foo\u0026#34; これらは以下のファイルと全く同じ構造を持ちます。\n[a] b = 42 c = \u0026#34;foo\u0026#34; なので、どの記法でも以下の全く同一のコードで処理できます。\nconst auto input = toml::parse(\u0026#34;input.toml\u0026#34;); assert(input.at(\u0026#34;a\u0026#34;).at(\u0026#34;b\u0026#34;).as_integer() == 42); assert(input.at(\u0026#34;a\u0026#34;).at(\u0026#34;c\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); ただし、フォーマット情報によって区別することは可能です。\nconst auto input = toml::parse(\u0026#34;input.toml\u0026#34;); switch(input.at(\u0026#34;a\u0026#34;).as_table_fmt().fmt) { case toml::table_format::oneline: { std::cout \u0026lt;\u0026lt; \u0026#34;inline table\u0026#34; \u0026lt;\u0026lt; std::endl; break; } case toml::table_format::multiline: { std::cout \u0026lt;\u0026lt; \u0026#34;normal table\u0026#34; \u0026lt;\u0026lt; std::endl; break; } case toml::table_format::dotted: { std::cout \u0026lt;\u0026lt; \u0026#34;dotted keys\u0026#34; \u0026lt;\u0026lt; std::endl; break; } } このフォーマット情報は後述するシリアライズの際も考慮されます。\n日付情報の取り扱い # local_date, local_time, local_datetime, そして offset_datetime は、 toml11では対応するメンバ変数を持つ専用の構造体にパースされます。\n使用する際は、直接値を取り出す他にも、後述する toml::get や toml::find を使用して、 std::chrono::system_clock::time_point や std::tm 等の型に変換することができます。\ntoml::get\u0026lt;T\u0026gt;を使って変換する # toml::get\u0026lt;T\u0026gt; は、 toml::value の持つ値を変換して取り出す関数です。 T に変換先に指定したい型を指定します。\nconst toml::value v = /*...*/; std::cout \u0026lt;\u0026lt; toml::get\u0026lt;int\u0026gt;(v) \u0026lt;\u0026lt; std::endl; 後述する toml::find\u0026lt;T\u0026gt; も、型変換の部分は同一の機能を持ちます。\n格納されている型のそれぞれについて、 変換ができない型が指定された場合、 toml::type_error が送出されます。\n単純な変換 # boolean_type # boolean_type から変換が可能なのは、 bool のみです。\ninteger_type # bool 以外で std::is_integral\u0026lt;T\u0026gt; が true になる型は、 integer_type から変換できます。\ntoml::value v(42); const auto u32 = toml::get\u0026lt;std::uint32_t\u0026gt;(v); const auto i16 = toml::get\u0026lt;short\u0026gt;(v); floating_type # std::is_floating_point\u0026lt;T\u0026gt; が true になる型は、floating_type から変換できます。\ntoml::value v(3.14); const auto f64 = toml::get\u0026lt;double\u0026gt;(v); const auto f32 = toml::get\u0026lt;float \u0026gt;(v); string_type # string_type からは std::string へ変換できます。 また、C++17以降では、std::string_view へも変換できます。\ntoml::value v(\u0026#34;foo\u0026#34;); const auto s = toml::get\u0026lt;std::string\u0026gt;(v); // C++17以降 const auto sv = toml::get\u0026lt;std::string_view\u0026gt;(v); datetime variants # local_date, local_datetime, offset_datetime は ある日付と時刻を指しているため、 std::chrono::system_clock::time_point への変換が可能です。\nただし、local_time は 日付の情報がないため、0時0分からの経過時刻として std::chrono::duration への 変換をサポートします。\nまた、 local_date と local_datetime は実行中のマシンのタイムゾーンを取得して変換を行います。\ndate = 2024-01-23 time = 12:30:00 l_dt = 2024-01-23T12:30:00 o_dt = 2024-01-23T12:30:00+09:00 const auto input = toml::parse(\u0026#34;input.toml\u0026#34;); const auto date = toml::get\u0026lt;std::chrono::system_clock::time_point\u0026gt;(input.at(\u0026#34;date\u0026#34;)); const auto l_dt = toml::get\u0026lt;std::chrono::system_clock::time_point\u0026gt;(input.at(\u0026#34;l_dt\u0026#34;)); const auto o_dt = toml::get\u0026lt;std::chrono::system_clock::time_point\u0026gt;(input.at(\u0026#34;o_dt\u0026#34;)); const auto time = toml::get\u0026lt;std::chrono::minutes\u0026gt;(input.at(\u0026#34;time\u0026#34;)); // 12 * 60 + 30 min 参照を取得できる条件 # toml::get\u0026lt;T\u0026gt; は、 T が toml::value が格納する型そのものだった場合、参照を返すことができます。\n逆に、変換が必要な場合（ std::int64_t で格納されている整数を std::uint32_t で取り出そうとした場合）は、 変換後の型への参照を返すことは不可能です。\n変換が必要ない型の場合、返された参照を経由して値を書き換えることも可能です。\ntoml::value v(42); toml::get\u0026lt;toml::value::integer_type\u0026gt;(v) = 6 * 9; assert(v.as_integer() == 54); 配列をSTLコンテナに # 配列の要素型が全て同じ場合、要素型が T に変換可能であれば、 std::vector\u0026lt;T\u0026gt; に変換可能です。\na = [1, 2, 3, 4, 5] const auto a = toml::get\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); 他のSTLコンテナにも変換可能です。\nconst auto a1 = toml::get\u0026lt;std::deque\u0026lt;int\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); const auto a2 = toml::get\u0026lt;std::list \u0026lt;int\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); const auto a3 = toml::get\u0026lt;std::array\u0026lt;int, 5\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); std::array に変換する場合、要素数が一致している必要があります。 もし要素数が一致しなかった場合、 std::out_of_range が送出されます。\nSTL以外のコンテナであっても、デフォルトコンストラクタと push_back を持っている場合、 toml::get で変換が可能です。\nconst auto a = toml::get\u0026lt;boost::container::small_vector\u0026lt;int, 8\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); 配列を std::pair, std::tuple に # 配列の要素型が異なる場合、 std::pair や std::tuple に変換が可能です。\na = [true, 3.14] b = [42, 2.718, \u0026#34;foo\u0026#34;] const auto a = toml::get\u0026lt;std::pair\u0026lt;bool, double\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); const auto b = toml::get\u0026lt;std::tuple\u0026lt;int, double, std::string\u0026gt;\u0026gt;(input.at(\u0026#34;b\u0026#34;)); std::array の場合と同様に、配列の長さは std::pair, std::tuple の要素数と一致している必要があります。 もし要素数が一致しなかった場合、 std::out_of_range が送出されます。\nまた、各要素は対応する要素に変換できる必要があります。 変換できない場合、 toml::type_error が送出されます。\nネストされた配列の変換 # ネストされた配列は、ネストされたコンテナに変換可能です。\na = [ [1, 2, 3], [4, 5, 6] ] const auto a = toml::get\u0026lt;std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); 型が異なる場合には、 std::pair/tuple が便利です。\na = [ [1, 2, 3], [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;] ] const auto a = toml::get\u0026lt; std::pair\u0026lt;std::vector\u0026lt;int\u0026gt;, std::vector\u0026lt;std::string\u0026gt;\u0026gt; \u0026gt;(input.at(\u0026#34;a\u0026#34;)); テーブルを std::map に変換 # テーブルに含まれる値の型が全て同じであれば、 std::map や std::unordered_map に変換が可能です。\nt = {a = 1, b = 2} const auto t = toml::get\u0026lt;std::map\u0026lt;std::string, int\u0026gt;\u0026gt;(input.at(\u0026#34;t\u0026#34;)); STL以外のコンテナであっても、デフォルトコンストラクタと emplace(key, mapped) を持っている場合、 toml::get で変換が可能です。\nconst auto t = toml::get\u0026lt;boost::container::flat_map\u0026lt;std::string, int\u0026gt;\u0026gt;(input.at(\u0026#34;t\u0026#34;)); 要素型の変換に失敗した場合は toml::type_error が送出されます。\ntoml::get_orを使って失敗時の値を指定する # toml::get は変換に失敗した際に toml::type_error 例外を送出します。\ntoml::get_or を使用することで、変換に失敗した際に例外ではなくデフォルト値を返せるようになります。\ntoml::get\u0026lt;T\u0026gt; とは異なり、 get_or は引数から変換先の型を推論するため、 \u0026lt;T\u0026gt; の指定は不要です。\nconst auto a = toml::get_or(input.at(\u0026#34;a\u0026#34;), 42); 変換可能な型は toml::get と同様です。\ntoml::value::xxx_typeを指定した場合は、参照を取り出すことも可能ですが、その場合は引数も参照である必要があります。\ntoml::value::integer_type a_default = 42; auto a\u0026amp; = toml::get_or(input.at(\u0026#34;a\u0026#34;), a_default); toml::find\u0026lt;T\u0026gt;を使って検索と変換を同時に行う # toml::find\u0026lt;T\u0026gt; は、テーブルを持つ toml::value から値を検索し、同時に toml::get と同じ型変換を行って取り出す関数です。\nconst auto a = toml::find\u0026lt;int\u0026gt;(input, \u0026#34;a\u0026#34;); // const auto a = toml::get\u0026lt;int\u0026gt;(input.at(\u0026#34;a\u0026#34;)); と同じ toml::find\u0026lt;T\u0026gt; は配列にも使用できます。\nconst auto a = input.at(\u0026#34;a\u0026#34;); const auto a2 = toml::find\u0026lt;int\u0026gt;(a, 2); // const auto a2 = toml::get\u0026lt;int\u0026gt;(input.at(\u0026#34;a\u0026#34;).at(2)); と同じ 型変換の際にエラーが起きた場合、 toml::get と同じ toml::type_error を 送出します。 キーが見つからなかった場合またはインデックスが存在しない場合は、 std::out_of_range を送出します。\n型を指定しなかった場合、型変換を行わず toml::value を取り出します。\nconst auto a = toml::find(input, \u0026#34;a\u0026#34;); // const auto a = input.at(\u0026#34;a\u0026#34;); と同じ toml::find\u0026lt;T\u0026gt; は再帰的に値にアクセスることもできます。\na = {b = {c = 42}} const auto a_b_c = toml::find\u0026lt;int\u0026gt;(input, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // const auto a = toml::get\u0026lt;int\u0026gt;(input.at(\u0026#34;a\u0026#34;).at(\u0026#34;b\u0026#34;).at(\u0026#34;c\u0026#34;)); と同じ このとき、キーとインデックスを混ぜることができます。\na = [ {b = 1}, {b = 2}, {b = 3} ] const auto a_2_b = toml::find\u0026lt;int\u0026gt;(input, \u0026#34;a\u0026#34;, 2, \u0026#34;b\u0026#34;); // const auto a = toml::get\u0026lt;int\u0026gt;(input.at(\u0026#34;a\u0026#34;).at(2).at(\u0026#34;c\u0026#34;)); と同じ TOMLはquoted keyという機能を持っています。\nこれは、 \u0026quot;\u0026quot; や '' を使うことで通常許可されない文字をキーに使えるというもので、 この中では . はテーブルを導入しません。\n\u0026#34;127.0.0.1\u0026#34; = \u0026#34;value\u0026#34; site.\u0026#34;google.com\u0026#34; = true このTOMLファイルは以下のようにして読みます。\nconst auto input = toml::parse(\u0026#34;input.toml\u0026#34;); assert(input.at(\u0026#34;127.0.0.1\u0026#34;).as_string() == \u0026#34;value\u0026#34;); assert(input.at(\u0026#34;site\u0026#34;).at(\u0026#34;google.com\u0026#34;).as_boolean()); このような場合にも違和感なく対応するため、toml11ではキーに . が含まれていても 自動で分割はしません。\nテーブルの階層構造を陽に指定することが、適切な入力ファイルの構造化に資すると考えているからです。\n参考: toml.io キー\ntoml::find_orを使って失敗時の値を指定する # toml::find_or は、 toml::get_or と同様に、失敗時のデフォルト値を渡します。\nconst auto a = toml::find_or(input, \u0026#34;a\u0026#34;, 42); 型変換の失敗だけでなく、キーが見つからなかった場合もデフォルト値を返します。\ntoml::find_or_defaultを使って失敗時の値を指定する # toml::find_or_default は、 toml::find_or と同様に、失敗時にデフォルトコンストラクタの結果を返します。デフォルトコンストラクタは失敗時のみに呼ばれるため、特にそれが高価な時に有効です。\nconst auto a = toml::find_or(input, \u0026#34;a\u0026#34;, expensive()); // 関数呼出前にコンストラクタ呼出 const auto a = toml::find_or_default\u0026lt;expensive\u0026gt;(input, \u0026#34;a\u0026#34;); // 失敗時にのみコンストラクタ呼出 型変換の失敗だけでなく、キーが見つからなかった場合もデフォルトコンストラクタの結果を返します。\ntoml::find\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt; # C++17以降の場合、std::optionalをtoml::findに指定することができます。\nfindと同様に、再帰的なアクセスも可能です。\nconst auto input = toml::parse_str(R\u0026#34;( integer = 1 [table] key = 2 [[array-of-tables]] key = 3 )\u0026#34;); const auto a = toml::find\u0026lt;std::optional\u0026lt;int\u0026gt;\u0026gt;(input, \u0026#34;integer\u0026#34;); const auto b = toml::find\u0026lt;std::optional\u0026lt;int\u0026gt;\u0026gt;(input, \u0026#34;table\u0026#34;, \u0026#34;key\u0026#34;); const auto c = toml::find\u0026lt;std::optional\u0026lt;int\u0026gt;\u0026gt;(input, \u0026#34;array-of-tables\u0026#34;, 0, \u0026#34;key\u0026#34;); キーが存在しなかった場合、例外は投げられず、std::nulloptが返却されます。\nただし、型変換が失敗した場合や、テーブルではない値にキーでアクセスしようとした場合、配列でない値にインデックスでアクセス仕様とした場合は、toml::type_errorが送出されます。\nユーザー定義型との変換を定義する # toml::get や toml::find では、以下のどれかの方法を使うことで ユーザー定義型を使用することができます。\ntoml::from の定義 # toml11には toml::from という型があり、以下のように特殊化することでユーザー定義型からの 変換をサポートできます。\nnamespace extlib { struct foo { int a; std::string b; }; } // extlib namespace toml { template\u0026lt;\u0026gt; struct from\u0026lt;extlib::foo\u0026gt; { static extlib::foo from_toml(const toml::value\u0026amp; v) { return extlib::foo{ toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;), toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;) }; } }; } // toml 後述する型設定を変更した toml::value もサポートする場合、以下のようにしてください。\nnamespace extlib { struct foo { int a; std::string b; }; } // extlib namespace toml { template\u0026lt;\u0026gt; struct from\u0026lt;extlib::foo\u0026gt; { template\u0026lt;typename TC\u0026gt; static extlib::foo from_toml(const toml::basic_value\u0026lt;TC\u0026gt;\u0026amp; v) { return extlib::foo{ toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;), toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;) }; } }; } // toml この定義は、 TOML11_DEFINE_CONVERSION_NON_INTRUSIVE によって自動的に定義できます。\nnamespace extlib { struct foo { int a; std::string b; }; } // extlib TOML11_DEFINE_CONVERSION_NON_INTRUSIVE(extlib::foo, a, b) あるいは、リフレクションライブラリを使用することもできます。 example の boost-ext/reflect を使用したサンプルも参照してください。\nfrom_toml メンバ関数の定義 # from_toml メンバ関数を定義することによっても変換を定義することができます。\nこれを使用する場合、デフォルトコンストラクタが必要です。\nstruct bar { int a; std::string b; void from_toml(const toml::value\u0026amp; v) { this-\u0026gt;a = toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;); this-\u0026gt;b = toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;); return ; } }; 両方が定義されていた場合、 toml::from が優先されます。\ntoml::value を受け取るコンストラクタ # toml::value を受け取るコンストラクタがあれば、 toml::get による変換ができます。\nstruct baz { explicit baz(const toml::value\u0026amp; v) : a(toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;)), b(toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;)) {} int a; std::string b; }; 両方が定義されていた場合、toml::from と from_toml が優先されます。\ntoml::visitで関数を適用する # toml::value が格納する型すべてに適用できる関数オブジェクトがあれば、 toml::visit によって型変換を経ずに直接その関数を呼ぶことができます。\nstruct type_name_of { std::string operator()(const toml::value::boolean_type \u0026amp;) const {return \u0026#34;boolean\u0026#34;;} std::string operator()(const toml::value::integer_type \u0026amp;) const {return \u0026#34;integer\u0026#34;;} std::string operator()(const toml::value::floating_type \u0026amp;) const {return \u0026#34;floating\u0026#34;;} std::string operator()(const toml::value::string_type \u0026amp;) const {return \u0026#34;string\u0026#34;;} std::string operator()(const toml::value::local_time_type \u0026amp;) const {return \u0026#34;local_time\u0026#34;;} std::string operator()(const toml::value::local_date_type \u0026amp;) const {return \u0026#34;local_date\u0026#34;;} std::string operator()(const toml::value::local_datetime_type \u0026amp;) const {return \u0026#34;local_datetime\u0026#34;;} std::string operator()(const toml::value::offset_datetime_type\u0026amp;) const {return \u0026#34;offset_datetime\u0026#34;;} std::string operator()(const toml::value::array_type \u0026amp;) const {return \u0026#34;array\u0026#34;;} std::string operator()(const toml::value::table_type \u0026amp;) const {return \u0026#34;table\u0026#34;;} }; toml::value v(3.14); std::cout \u0026lt;\u0026lt; toml::visit(type_name_of{}, v) \u0026lt;\u0026lt; std::endl; // floating toml::value を構築する # toml::value はパーサの内部だけでなく、ユーザーコードで構築することも可能です。\ntoml::value が格納する型と同じか変換可能な型を渡しての構築が可能です。\ntoml::value v1(true); toml::value v2(42); toml::value v3(3.14); 配列の場合、 toml::array を使うか、\ntoml::value v(toml::array{1, 2, 3}); 配列の場合、 std::vector などのコンテナを直接渡すことが可能です。\nconst std::vector\u0026lt;toml::value\u0026gt; a{1,2,3}; toml::value v(a); このコンテナには、 toml::get で変換可能なコンテナが使用できます。\nテーブルの場合も同様に、 toml::table を使うか、\ntoml::value v(toml::table{{\u0026#34;foo\u0026#34;, 1}, {\u0026#34;bar\u0026#34;, 2}, {\u0026#34;baz\u0026#34;, 3}}); std::map などのコンテナを直接渡します。\nconst std::map\u0026lt;std::string, toml::value\u0026gt; t{ {\u0026#34;foo\u0026#34;, 1}, {\u0026#34;bar\u0026#34;, 2}, {\u0026#34;baz\u0026#34;, 3} } toml::value v(t); コンストラクタには、 format_info と コメントを渡すことができます。\nコメントの型は std::vector\u0026lt;std::string\u0026gt; です。 各要素が一行分に相当します。\ntoml::integer_format_info fmt; fmt.fmt = toml::integer_format::hex; fmt.spacer = 4; toml::value v1(0xDEADBEEF, fmt); toml::value v2(0xC0FFEE, fmt, {\u0026#34;hex value!\u0026#34;}); toml::value に変換する # ユーザー定義型から toml::value を構築する際に、 toml::into や into_toml を 定義することで、その挙動をカスタマイズできます。\n特に、別のライブラリの型などを変換する際に toml::into が便利です。\ntoml::intoを定義する # toml::into を特殊化することで toml::value への変換が可能になります。\ntoml::value への変換が用意されていない外部ライブラリの型などに対して有効です。\ntoml::value が変換時に type_config を渡すため、basic_value の template 引数を受け取る必要があります。\nnamespace extlib { struct foo { int a; std::string b; }; } // extlib template\u0026lt;\u0026gt; struct into\u0026lt;extlib::foo\u0026gt; { template\u0026lt;typename TC\u0026gt; static toml::basic_value\u0026lt;TC\u0026gt; into_toml(const extlib::foo\u0026amp; f) { return toml::basic_value\u0026lt;TC\u0026gt;(typename toml::basic_value\u0026lt;TC\u0026gt;::table_type{{\u0026#34;a\u0026#34;, f.a}, {\u0026#34;b\u0026#34;, f.b}}); } }; into_toml メンバ関数を定義する # from_toml と同様、メンバ関数によっても変換を定義することができます。\ntoml::into が定義されていた場合、そちらが優先されます。\nstruct bar { int a; std::string b; toml::value into_toml() const { return toml::value(toml::table{{\u0026#34;a\u0026#34;, this-\u0026gt;a}, {\u0026#34;b\u0026#34;, this-\u0026gt;b}}); } }; 値がアクセス済みかどうかチェックする # TOML11_ENABLE_ACCESS_CHECKマクロを定義してコンパイルすると、toml::valueにbool accessed() constメソッドが追加され、パース後にその値にアクセスしたかどうかが確認できるようになります。\n$ g++ -std=c++17 -O2 -DTOML11_ENABLE_ACCESS_CHECK -I/path/to/toml11/include main.cpp $ cmake -B ./build -DTOML11_ENABLE_ACCESS_CHECK=ON CPMAddPackage( NAME toml11 GITHUB_REPOSITORY \u0026#34;ToruNiina/toml11\u0026#34; VERSION 4.4.0 OPTIONS \u0026#34;CMAKE_CXX_STANDARD 17\u0026#34; \u0026#34;TOML11_PRECOMPILE ON\u0026#34; \u0026#34;TOML11_ENABLE_ACCESS_CHECK ON\u0026#34; ) この機能によって、テーブル内に定義されているものの使用されなかった値についての警告を表示することが可能になります。\n#include \u0026lt;toml.hpp\u0026gt; namespace yours { Config read_config(const toml::value\u0026amp; v) { const auto cfg = read_your_config(input); for(const auto\u0026amp; [k, v] : input.as_table()) { if( ! v.accessed()) { std::cerr \u0026lt;\u0026lt; toml::format_error(\u0026#34;value defined but not used\u0026#34;, v.source_location(), \u0026#34;not used\u0026#34;); } } return cfg; } } // yours この機能は、必要な場合のみ定義されるような値を、名称を間違えて定義してしまった際に役に立つでしょう。 例えば、\n# 正しくは reactions # reactions = [ \u0026#34;:+1:\u0026#34;, \u0026#34;star\u0026#34; ] # 名前が違うので読み込めない reaction = [ \u0026#34;:+1:\u0026#34;, \u0026#34;star\u0026#34; ] このファイルを上記のコードで読んだ場合、read_your_configはreactionsを探し、定義されていなかったので空の配列として処理するでしょう。 その場合、reactionはaccessed()がtrueにならないため、エラーとして検出できます。\n"},{"id":6,"href":"/toml11/ja/docs/features/error_message/","title":"error message","section":"features","content":" エラーメッセージを出力する # toml11は toml::parse や toml::get\u0026lt;T\u0026gt;/find\u0026lt;T\u0026gt;, as_integer() などから ファイル内の位置情報を含んだエラーメッセージを出力します。\n例えば、パース時に整数の文法エラーを発見した場合、\n[error] bad integer: `_` must be surrounded by digits --\u0026gt; internal string at line 64 in file main.cpp | 1 | a = 123__456 | ^-- invalid underscore Hint: valid : -42, 1_000, 1_2_3_4_5, 0xC0FFEE, 0b0010, 0o755 Hint: invalid: _42, 1__000, 0123 あるいは実際に格納されている型と異なる型を要求した場合\n[error] toml::value::as_string(): bad_cast to string --\u0026gt; input.toml | 1 | a = 123_456 | ^^^^^^^-- the actual type is integer toml11は toml::value からこのようなエラーメッセージを作成する方法を提供します。\nこの機能を利用することで、TOMLの文法エラーだけでなく、 例えば正の値でなければならないところに負数が現れた場合などの アプリケーション固有のエラーメッセージを、TOMLファイル内の位置を指摘しながら ユーザーに伝えられるということです。\ntoml::value の位置情報からエラーメッセージを作成する # toml::value はそれがパースされた位置の情報を持っています。\nその情報は toml::source_location にまとめられ、toml::value::location() で取得できます。\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); const toml::source_location src = a.location(); ファイルを toml::parse でパースした場合、そのTOMLファイル名と行数が保存されています。\ntoml::parse_str でパースした場合TOMLファイル名はありませんが、代わりに toml::parse_str を呼び出したC++ソースコードのファイル名と行数がTOMLファイル名として保存されています。 このページの最初の例は toml::parse_str から出力された例でした。 ファイル名の部分に注目してください。\n詳細は reference を参照してください。\ntoml::source_location または toml::value とそれに付随するエラーメッセージを toml::make_error_info に渡すことで、エラー情報を構築できます。 これをtoml::format_error に渡すと、エラーメッセージが std::string にフォーマットされます。\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); if(a.as_integer() \u0026lt; 0) { const toml::error_info err = toml::make_error_info( \u0026#34;positive integer is required\u0026#34;, // エラーのタイトル a, \u0026#34;but got negative value\u0026#34; // 値の横に書くメッセージ ); std::cerr \u0026lt;\u0026lt; toml::format_error(err) \u0026lt;\u0026lt; std::endl; } これは以下のようになります。\n[error] positive integer is required --\u0026gt; input.toml | 1 | a = -123456 | ^^^^^^^-- but got negative value 最後に補足をつけ足すこともできます。これはインデントされません。\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); if(a.as_integer() \u0026lt; 0) { const toml::error_info err = toml::make_error_info( \u0026#34;positive integer is required\u0026#34;, // エラーのタイトル a, \u0026#34;but got negative value\u0026#34;, // 値の横に書くメッセージ \u0026#34;Hint: `a` means length of the data\u0026#34; // 補足 ); std::cerr \u0026lt;\u0026lt; toml::format_error(err) \u0026lt;\u0026lt; std::endl; } [error] positive integer is required --\u0026gt; input.toml | 1 | a = -123456 | ^^^^^^^-- but got negative value Hint: `a` means length of the data toml::value からファイル内の行を出力できるのは、 パースしたファイルが文字列としてメモリの中に残されているからです。\nパースした文字列はその全体が std::shared_ptr で toml::value に共有されています。 コピーしてもファイル文字列全体がコピーされることはありません。 また、そのファイルをパースして構築された toml::value が全てデストラクトされた時点で、 ファイル情報もメモリ上から解放されます。\nですので、アプリケーションで使用する際には、 toml::value を直接保存するのではなく 読み込み中に必要な値を全て取り出して、変換した値を保存した方がよいでしょう。\n文字列に色を付ける # エラーメッセージにはANSIエスケープコードを使って色を付けることができます。\nTOML11_COLORIZE_ERROR_MESSAGE をコンパイル時に定義していれば、 toml11の出力するエラーメッセージはデフォルトで色が付くようになります。\nそうでない場合は、 toml::color::enable() を呼び出すことにより、それ以降で出力される エラーメッセージには色が付くようになります。 逆に出力先がコンソールではないなどの理由で色をつけたくない場合は、 toml::color::disable() を呼び出してください。 その時点で色が付くようになっているかどうかは、 toml::color::should_color() の返り値で判定できます。\n詳細は reference を参照してください。\nまた、エラーのタイトルやエラーメッセージ、補足にはデフォルトで色が付きませんが、 toml::color にあるマニピュレータを使って色を付けることも可能です。\nstd::ostringstream oss; oss \u0026lt;\u0026lt; toml::color::red \u0026lt;\u0026lt; \u0026#34;but got negative value\u0026#34;; const toml::error_info err = toml::make_error_info( \u0026#34;positive integer is required\u0026#34;, // Error title a, oss.str(), // Message next to the value \u0026#34;Hint: `a` means length of the data\u0026#34; // Supplementary message ); こちらも、詳細は reference を参照してください。\nエラーメッセージのprefixを[error]から変更する # エラーには種類があり、デフォルトの [error] ではよくない場合もあるでしょう。\ntoml::format_error では、 toml::error_info の前に std::string を取って、それを [error] の代わりに出力することができます。\n例えば、\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); if(a.as_integer() \u0026lt; 0) { const toml::error_info err = toml::make_error_info( \u0026#34;positive integer is required\u0026#34;, // エラーのタイトル a, \u0026#34;but got negative value\u0026#34; // 値の横に書くメッセージ ); std::ostringstream prefix; prefix \u0026lt;\u0026lt; toml::color::bold \u0026lt;\u0026lt; toml::color::yellow \u0026lt;\u0026lt; \u0026#34;[warn]\u0026#34;; std::cerr \u0026lt;\u0026lt; toml::format_error(prefix.str(), err) \u0026lt;\u0026lt; std::endl; return 0; } else { return a.as_integer() } このようにすると、 [warn] から始まる警告を出力することができます。\n他にも、toml::format_error に直接 error_info の構成要素を渡すことで、 [error] なしのエラーメッセージを作成できます。\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); if(a.as_integer() \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; toml::format_error( \u0026#34;[warn] positive integer is required\u0026#34;, // エラーのタイトル a, \u0026#34;but got negative value\u0026#34; // 値の横に書くメッセージ ) \u0026lt;\u0026lt; std::endl; return 0; } else { return a.as_integer() } 複数の toml::value を指すエラーメッセージを作成する # アプリケーションの設定では、先に読み込んだ値によって後に読み込んだ値が取れる範囲が変わることがあるでしょう。\nそのような場合には、エラーの原因となる別の値を同時に出力したいはずです。\ntoml::format_error と toml::make_error_info は、 toml::value とそれに対応するエラーメッセージ std::string のペアを任意個取ることができます。\nstd::cerr \u0026lt;\u0026lt; toml::format_error( \u0026#34;[error] invalid range\u0026#34;, a, \u0026#34;minimum value is defined here\u0026#34;, b, \u0026#34;maximum value is defined here\u0026#34;, c, \u0026#34;and it exceeds the range\u0026#34; ) \u0026lt;\u0026lt; std::endl; こちらも末尾に補足を追加することができます。\nstd::cerr \u0026lt;\u0026lt; toml::format_error( \u0026#34;[error] invalid range\u0026#34;, a, \u0026#34;minimum value is defined here\u0026#34;, b, \u0026#34;maximum value is defined here\u0026#34;, c, \u0026#34;and it exceeds the range\u0026#34;, \u0026#34;Hint: all the value must be in the range, [a, b)\u0026#34; ) \u0026lt;\u0026lt; std::endl; toml::value または toml::source_location を渡した場合、必ずそれに関する エラーメッセージが続く必要があります。 そうしない場合、非常にわかりにくいコンパイルエラーになります。\n"},{"id":7,"href":"/toml11/ja/docs/features/serialize/","title":"serializing values","section":"features","content":" TOMLファイルを出力する # toml::format を使うと、 toml::value を文字列にすることができます。\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;cassert\u0026gt; int main() { const toml::value v(toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;b\u0026#34;, \u0026#34;foo\u0026#34;}, }); const std::string s = toml::format(v); const toml::value u = toml::parse_str(s); assert(u.at(\u0026#34;a\u0026#34;).as_integer() == 42); assert(u.at(\u0026#34;b\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); return 0; } table_type を格納している toml::value が渡されると、それがファイルのルートテーブルとして解釈されます。\nもし table_type 以外を格納している toml::value が渡されると、その値だけがフォーマットされます。\n一部のフォーマット指定では、キーが渡されていないとフォーマットできないことがあります。 例えば、 toml::array_format::array_of_tables は [[array.of.tables]] の形でフォーマットするので、 キーへのアクセスを要求します。\nキーを要求するフォーマット指定の値がキーなしで渡された場合、 toml::serialization_error が送出されます。\n他にも、フォーマット指定と矛盾する値が含まれる場合には、 toml::serialization_error が送出されます。 例えば、 integer_format::hex が指定された整数が負の値を持っている場合や、 string_format::literal が指定された文字列が改行を含んでいる場合などです。\nフォーマットの指定方法は後述します。\nキーを渡して出力する # toml::format には std::string としてキーを渡すことが可能です。\nその場合、ルートテーブルの下にそのキーがあり、渡した値はそのキーに対応すると解釈されます。\nキーが複数段になる場合、 std::vector\u0026lt;std::string\u0026gt; を渡すことができます。\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;cassert\u0026gt; int main() { const toml::value v(toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;b\u0026#34;, \u0026#34;foo\u0026#34;}, }); const std::string s = toml::format(\u0026#34;bar\u0026#34;, v); const toml::value u = toml::parse_str(s); assert(u.at(\u0026#34;bar\u0026#34;).at(\u0026#34;a\u0026#34;).as_integer() == 42); assert(u.at(\u0026#34;bar\u0026#34;).at(\u0026#34;b\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); return 0; } フォーマットを指定する # toml::value のそれぞれの型には、対応するフォーマット情報型があります。\ntoml::value::integer_type には toml::integer_format_info が、 toml::value::table_type には toml::table_format_info があります。\nこれらは、パースした際に設定され、型が変わらない限り値を変更しても引き継がれます。\nまた、 as_integer_fmt() や as_table_fmt() といったメンバ関数によってアクセスすることができ、 直接編集することが可能です。\n以下ではいくつかの例を挙げて使い方を説明します。\nフォーマットへのアクセス方法は toml::valueのリファレンスを、 フォーマット情報クラスの完全なリストと詳細は formatのリファレンスを 参照してください。\n整数のフォーマットを指定する # 整数は、基数と幅、そして _ の位置を指定することができます。\nhex, oct, bin のとき、指定された幅に達するまでゼロで埋められます。 dec の場合は幅指定はスペースを追加しますが、これはパースされません。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::value v(0x00C0\u0026#39;FFEE); v.as_integer_fmt().fmt = toml::integer_format::hex; v.as_integer_fmt().width = 8; v.as_integer_fmt().spacer = 4; const std::stirng s = toml::format(v); assert(s == \u0026#34;0x00C0_FFEE\u0026#34;); return 0; } 詳細は、reference を参照してください。\n配列を単一行・複数行にする # 配列には、 toml::array_format::oneline や toml::array_format::multiline を指定できます。\n# oneline a = [1, 2, 3, 4, 5] # multiline a = [ 1, 2, 3, 4, 5 ] multiline のときは、インデントを指定できます。 各要素は body_indent の分だけインデントされ、閉じ括弧 ] は closing_indent の分だけインデントされます。\n文字種は indent_type で指定され、 toml::indent_char::space または toml::indent_char::tab が選択できます。\nインデントに使用する文字種は統一してください。\n一つのファイル内でインデントに異なる文字種が指定された場合、結果は未規定になります。 何らかのインデントがされますが、全ての箇所で文字種やインデントの深さは不定となります。\nまた、 array の要素が全て table_type を持つ場合、 toml::array_format::array_of_tables が指定できます。\narray_of_tables を指定せずに multiline にした場合、テーブルはインラインテーブルになります。\n# multiline a = [ {foo = 42}, {bar = \u0026#34;hoge\u0026#34;}, ] # array_of_tables [[a]] foo = 42 [[a]] bar = \u0026#34;hoge\u0026#34; デフォルトでは、 toml::array_format::default_format が指定されます。 これは適したフォーマットを自動的に選択します。\n例えば、 default_format で全要素が table_type だった場合、 array_of_tables が選択されます。 また、十分短い配列は oneline に、長い配列またはネストされた配列などの複雑な配列は multiline になります。\n詳細は、reference を参照してください。\nテーブルをインラインテーブルにする # テーブルをインラインテーブルにする際は toml::table_format::oneline を指定します。 通常のテーブルにする際は、 toml::table_format::multiline を指定します。\noneline = {a = 42, b = \u0026#34;foo\u0026#34;} [multiline] a = 42 b = \u0026#34;foo\u0026#34; TOML v1.1.0ではインラインテーブル内での改行が許可されますが、その場合は toml::table_format::multiline_oneline とします。 これは、後述するTOMLバージョン指定で対応する機能フラグがtrueになっていない限り無視されます。\nmultiline_oneline = { a = 42, b = \u0026#34;foo\u0026#34; } 詳細は、reference を参照してください。\nTOML言語バージョンを指定して出力する # TOML v1.1.0で許可されたインラインテーブル内の改行や\\xエスケープシーケンスのように、 TOMLバージョンによって使用できない言語機能があります。\ntoml::format は最後の引数に toml::spec を取ることができます。\nこれにより、シリアライズ時に使用するTOMLのバージョンを指定することができます。\n特に、 toml::parse で toml::spec を使用して新機能を使用した場合は、 パースした値がそのバージョンでしか使えないフォーマット情報を持つ場合があるので、 toml::format にも同じ toml::spec を渡すことを忘れないようにしてください。\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { const auto spec = toml::spec::v(1, 1, 0) const toml::value v = toml::parse(\u0026#34;input.toml\u0026#34;, spec); std::cout \u0026lt;\u0026lt; toml::format(v, spec); return 0; } "},{"id":8,"href":"/toml11/ja/docs/features/configure_types/","title":"configuring types","section":"features","content":" 型をカスタマイズする # toml::value は integer_type として std::int64_t を、 table_type として std::unordered_map\u0026lt;key_type, value_type\u0026gt; を使用します。\nしかし、場合によっては boost::multiprecision::int128_t や、 std::map を使用したい場合もあります。\nそのため、 toml::value は template 引数を取って格納する型を変えられるように実装されています。\nstd::string が実際には std::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt;\u0026gt; の エイリアスであるように、 toml::value は実際には toml::basic_value\u0026lt;toml::type_config\u0026gt; のエイリアスです。\nここでは、 toml::type_config が持つ型と、異なる config 型を定義する方法を説明します。\ntype_config # type_config は、以下のメンバ型とstaticメンバ関数を持つクラスです。\nnamespace toml { struct type_config { using comment_type = preserve_comments; using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = std::unordered_map\u0026lt;K, T\u0026gt;; static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base); static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex); }; } toml::basic_value\u0026lt;TypeConfig\u0026gt; は、格納する boolean_type を TypeConfig::boolean_type、 格納する integer_type を TypeConfig::integer_type 、のようにして定義しています。\nまた、 array_type は TypeConfig::array_type\u0026lt;toml::basic_value\u0026lt;TypeConfig\u0026gt;\u0026gt; 、 table_type は TypeConfig::table_type\u0026lt;key_type, toml::basic_value\u0026lt;TypeConfig\u0026gt;\u0026gt; と 定義されます。\nこれらのメンバ型とメンバ関数を定義したクラスを toml::basic_value に 渡すことで、その toml::basic_value が持つ型を変更できます。\nparse_int と parse_float は、数値型を独自実装のものに変更した際にパース方法を提供するための関数です。 これらの関数には 0x などのprefixと桁区切りの _ が取り除かれた文字列、 例えば 123456 や DEADBEEF が渡されます。 base には 10, 16, 8, 2 のいずれかが渡されます。 これらを使って integer_type と floating_type をパース出来るような関数を渡してください。\nデフォルト実装として、toml::read_int と toml::read_float が提供されています。\nstatic result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base) { return toml::read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex) { return toml::read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } read_int は istream を使用し、16進と8進の場合は std::hex と std::oct を使用します。2進の場合は掛け算と足し算で実装されています。 これらをサポートしている型であれば、 read_int をそのまま使用できます。\nread_float は istream を使用します。 16進浮動小数点数は double と float の場合しかサポートされておらず、 それ以外の型のときに呼ばれると常にパースエラーを返す実装になっているので、 もし浮動小数点数型をこれら以外の型にし、かつ hexfloat を使用する場合は、 それを実装してください。 hexfloat を使用しないのであれば、実装する必要はありません。\nテーブル内の値の順序を維持する # デフォルトの toml::type_config の他に、 toml::ordered_type_config が提供されています。 これは、 table_type を ordered_map に変更したものです。\nこれを使用したものを toml::ordered_value 、その配列型とテーブル型のエイリアスを toml::ordered_array と toml::ordered_table と定義しています。\ntoml::parse(...) を toml::parse\u0026lt;toml::ordered_type_config\u0026gt;(...) として呼び出すことで、 toml::ordered_value を使用することができます。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::ordered_value input = toml::parse\u0026lt;toml::ordered_type_config\u0026gt;(\u0026#34;example.toml\u0026#34;); std::cout \u0026lt;\u0026lt; toml::format(input) \u0026lt;\u0026lt; std::endl; return 0; } コメントを保存しない # type_config は comment_type でコメントを保存するコンテナを定義しています。\nコメントに特に情報がなく、パースせずに捨ててしまっていい場合は、 comment_type に toml::discard_comments を指定してください。\nstruct wo_comment_config { using comment_type = toml::discard_comments; // XXX using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = std::unordered_map\u0026lt;K, T\u0026gt;; static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base) { return toml::read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex) { return toml::read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } }; 配列にstd::vector以外のコンテナを使用する # TOML配列の実装にvector以外のコンテナ（例：std::deque）を使用するには、 array_type を以下のように変更してください。\nまた、テーブル型のコンテナに unordered_map 以外のコンテナ（例：std::map）を使用するには、 table_type を以下のように変更してください。\nstruct deque_map_config { using comment_type = toml::preserve_comments; using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::deque\u0026lt;T\u0026gt;; // XXX template\u0026lt;typename K, typename T\u0026gt; using table_type = std::map\u0026lt;K, T\u0026gt;; // XXX static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base) { return toml::read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex) { return toml::read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } }; 数値型に boost::multiprecision を使用する # boost::multiprecision::cpp_int と boost::multiprecision::cpp_bin_float_oct を使用することで、より幅の広い整数型とより精度の良い浮動小数点数型を使用することができます。\nこれらの型はストリーム演算子を実装しているため、デフォルト実装の read_int と read_float をそのまま使用できます。\nstruct large_num_config { using comment_type = toml::preserve_comments; using boolean_type = bool; using integer_type = boost::multiprecision::cpp_int; using floating_type = boost::multiprecision::cpp_bin_float_oct; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = std::unordered_map\u0026lt;K, T\u0026gt;; static toml::result\u0026lt;integer_type, toml::error_info\u0026gt; parse_int(const std::string\u0026amp; str, const toml::source_location src, const std::uint8_t base) { return toml::read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static toml::result\u0026lt;floating_type, toml::error_info\u0026gt; parse_float(const std::string\u0026amp; str, const toml::source_location src, const bool is_hex) { return toml::read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } }; "},{"id":9,"href":"/toml11/ja/docs/features/literal/","title":"toml literal","section":"features","content":" _tomlリテラル # \u0026quot;\u0026quot;_tomlリテラルによって、TOMLファイルをその場でフォーマットできます。\n#include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto v = \u0026#34;a = 42\u0026#34;_toml; assert(v.at(\u0026#34;a\u0026#34;).as_integer() == 42); return 0; } 改行を含む場合、生文字列リテラルが便利です。\n#include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto v = R\u0026#34;( a = 42 b = \u0026#34;foo\u0026#34; )\u0026#34;_toml; assert(v.at(\u0026#34;a\u0026#34;).as_integer() == 42); assert(v.at(\u0026#34;b\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); return 0; } 値が単体で書かれていた場合、その値が返されます。\n#include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto a = \u0026#34;42\u0026#34;_toml; const auto b = \u0026#34;12:34:56\u0026#34;_toml; assert(v.at(\u0026#34;a\u0026#34;).as_integer() == 42); assert(v.at(\u0026#34;b\u0026#34;).as_local_time().hour == 12); assert(v.at(\u0026#34;b\u0026#34;).as_local_time().minute == 34); assert(v.at(\u0026#34;b\u0026#34;).as_local_time().second == 56); return 0; } TOMLは数値のみからなるキーを許可しています。 よって、[1]はテーブル名として合法です。\n[1]のようにテーブル定義と配列の区別がつかない場合、テーブル定義が優先されます。\n配列として解釈させるには、trailing commaを使用してください。\n#include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto t = \u0026#34;[1]\u0026#34;_toml; // {1 = {}} const auto a = \u0026#34;[1,]\u0026#34;_toml; // [1,] assert(t.is_table()); assert(t.at(\u0026#34;1\u0026#34;).is_table()); assert(a.is_array()); assert(a.at(0).as_integer() == 1); return 0; } "},{"id":10,"href":"/toml11/ja/docs/features/toml_spec/","title":"toml spec","section":"features","content":" TOML言語バージョン # toml::spec によって、 toml::parse や toml::format で使用するTOML言語のバージョンや、個別の機能フラグを指定することができます。\nTOMLのバージョンを指定する # toml::spec は toml::semantic_version から構築できます。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec(toml::semantic_version(1, 1, 0)); return 0; } ですがこれは長いので、toml::spec::v()関数が用意されています。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec = toml::spec::v(1, 1, 0); return 0; } 特に指定しない場合、デフォルトの値で構築する toml::spec::default_version() が使用されます。\nデフォルトの値はtoml11のバージョンによって変わりますが、その時点でリリースされているTOML言語の最新バージョンに追従します。\nv4.4.0現在、TOML v1.1.0はまだリリースされていないため、デフォルトのTOMLバージョンはv1.0.0です。\nTOML v1.1.0の一部の機能にはかなり長い議論が続いており、まだ差し戻される可能性があります。\n実際に差し戻された場合、toml11はマイナーバージョンアップでそれらの機能を削除、もしくは対応するそれ以降のバージョンに移動します。\nそのような意味で、将来のバージョンに関する機能は全て不安定なものと考えてください。\nバージョン指定でパースする # toml::parse のオーバーロードは、ファイル名に続いてtoml::specを受け取ります。\nこれによって、使用するTOMLバージョンを変更できます。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::value input = toml::parse(\u0026#34;input.toml\u0026#34;, toml::spec::v(1, 1, 0)); return 0; } バージョン指定でシリアライズする # toml::format のオーバーロードは、 toml::value に続いて toml::spec を受け取ります。\nこれによって、使用するTOMLバージョンを変更できます。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::value v = toml::parse(\u0026#34;input.toml\u0026#34;, toml::spec::v(1, 1, 0)); std::cout \u0026lt;\u0026lt; toml::format(v, toml::spec::v(1, 1, 0)) \u0026lt;\u0026lt; std::endl; return 0; } もしフォーマット変数などによって指定されているフォーマットが渡された toml::spec では許可されていないものだった場合、指定は無視されて他のフォーマットにフォールバックされます。\nTOMLに追加された新機能を個別に指定する # TOMLのバージョンアップで追加された機能は複数あり、そのうちの一部だけを有効にすることが可能です。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec = toml::spec::v(1, 0, 0); // インラインテーブル内での改行を許可 spec.v1_1_0_allow_newlines_in_inline_tables = true; toml::value input = toml::parse(\u0026#34;input.toml\u0026#34;, spec); return 0; } 全てのフラグのリストは、 toml::spec を参照してください。\n"},{"id":11,"href":"/toml11/ja/docs/features/extension/","title":"extension","section":"features","content":" TOML言語拡張 # TOML言語は現在 v1.0.0 が最新版ですが、その後もいくつかの新機能が議論の末マージされ、 v1.1.0に向けて議論が続いています。\nそこで議論された機能の中には、有用なケースが少ないと考えられたものや、 提案された際の方向性では導入が難しいもの、導入がされなかったものも多くあります。\ntoml11では、そのような機能のなかからいくつかを選んで、実験的に実装を行っています。 これらはtoml11ではサポートされていますが、他のパーサではサポートされておらず、また サポートされる予定もないことに注意してください。\nまた、これらの機能はデフォルトで使用されない設定になっており、 使用するためには機能フラグをそれぞれ true にしなければなりません。 非標準の機能なので、あえて明示的に書かなければ使えないように設計しています。\nいくつかの機能は今後TOML言語自体に新機能としてマージされる可能性があります。 もし以下の拡張機能を完全に置き換えられる機能が導入された場合、拡張機能は 本来の機能の実装後にマイナーバージョンアップで削除される可能性があります。\nnull # TOMLファイル内で値としてnullを使えるようになります。\na = null b = [ 1, 2, 3, null, 5] これを使用するには、 toml::spec の ext_null_value を true にします。\nパースすると、デフォルト構築した場合と同様の toml::value_t::empty となります。 ただし、ファイル内の位置情報は設定されます。\nnull は値の文脈でのみパースされるので、キーに null を使用した際はこれまで通り \u0026quot;null\u0026quot; という文字列のキーとして解釈されます。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec; spec.ext_null_value = true; const auto v = toml::parse_str(\u0026#34;a = null\u0026#34;, spec); assert(v.at(\u0026#34;a\u0026#34;).is_empty()); assert(v.at(\u0026#34;a\u0026#34;).is(toml::value_t::empty)); return 0; } 浮動小数点数の16進数フォーマット # TOMLファイル内で浮動小数点数に16進数フォーマットを使用できるようになります。\na = 0x1.91eb851eb851fp+1 # 3.14 これを使用するには、 toml::spec の ext_hex_float を true にします。\nフォーマットは printf で %a/%A を指定した場合に準拠します。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec; spec.ext_hex_float = true; const auto v = toml::parse_str(\u0026#34;a = 0x1.91eb851eb851fp+1\u0026#34;, spec); assert(v.at(\u0026#34;a\u0026#34;).is_floating()); assert(v.at(\u0026#34;a\u0026#34;).as_floating() == 3.14); return 0; } 整数・浮動小数点数のsuffix # TOMLファイル内で数値の後ろにsuffixをつけられるようになります。 10進数表記の整数と浮動小数点数で使用できます。\n単位を表示するときなどに便利です。\na = 86_400_sec b = 3.1416_rad c = 10_μm ですが、これらはあくまで単なる suffix であり、単位換算は行われません。 単位換算が必要な場合は、ユーザーが suffix を参照して実装してください。\nこれを使用するには、 toml::spec の ext_num_suffix を true にします。\n数値と接尾辞の間は_で区切られている必要があります。\n数値部分との区別のため、suffixは数値で始まることはできません。\ndistance = 100_m # valid distance = 10_0m # invalid distance = 10_0_m # valid 接尾辞はstd::string suffixとしてフォーマット情報に保持されます。\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec; spec.ext_hex_float = true; const auto v = toml::parse_str(\u0026#34;a = 86_400_sec\u0026#34;, spec); assert(v.at(\u0026#34;a\u0026#34;).is_integer()); assert(v.at(\u0026#34;a\u0026#34;).as_integer() == 86400); assert(v.at(\u0026#34;a\u0026#34;).as_integer_fmt().suffix == \u0026#34;sec\u0026#34;); return 0; } "},{"id":12,"href":"/toml11/ja/docs/reference/color/","title":"color.hpp","section":"reference","content":" color.hpp # color.hppでは、エラーメッセージの色付けに関する関数が定義されます。\n色はANSIエスケープシーケンスによって指定されます。 ANSIエスケープシーケンスをサポートしていないターミナルやその他の出力先では、読みにくくなる可能性があります。\nマクロ # TOML11_COLORIZE_ERROR_MESSAGE # コンパイル時にこのマクロが定義されていた場合（-DTOML11_COLORIZE_ERROR_MESASGE）、 デフォルトでエラーメッセージに色が付きます。\n定義されていなかった場合、デフォルトでは色は付きません。以下の toml::color::enable() を 使用して指定する必要があります。\nTOML11_USE_THREAD_LOCAL_COLORIZATION # コンパイル時にこのマクロが定義されていた場合（-DTOML11_COLORIZE_ERROR_MESASGE）、 toml::color::enableの設定がthread_localになります。 この場合、toml::color::enable()やtoml::color::disable()は、それを呼び出したスレッドでの設定しか変更しません。 つまり、新しいスレッドを起動した際にデフォルトと異なる設定にしたい場合は、再度設定が必要になります。 その代わり、toml::color::enable()やtoml::color::disable()はスレッドセーフになります。\nデフォルトでは設定はグローバルです。 グローバルの場合、一つのスレッドがtoml::color::enable()を実行した場合、すべてのスレッドで色が付きます。 ただし、あるスレッドがenable()またはdisable()を実行している間に別のスレッドがenable()、disable()、should_color()を実行した場合、その結果は未定義です。\n関数 # enable() # namespace toml { namespace color { void enable(); } // color } // toml ANSIエスケープシーケンスによる色付けを行うよう設定します。\n例 # #include \u0026lt;toml.hpp\u0026gt; int main() { toml::color::enable(); // この後の全てのエラーがカラーになります。 const auto input = toml::parse(\u0026#34;input.toml\u0026#34;); return 0; } disable() # namespace toml { namespace color { void disable(); } // color } // toml ANSIエスケープシーケンスによる色付けを行わないよう設定します。\n例 # #include \u0026lt;toml.hpp\u0026gt; int main() { toml::color::enable(); // この後の全てのエラーがカラーになります。 const auto input = toml::parse(\u0026#34;input.toml\u0026#34;); return 0; } should_color() # namespace toml { namespace color { bool should_color(); } // color } // toml 色付けを行う設定になっている場合trueが、そうでない場合falseが返されます。\n例 # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;colorized? : \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; toml::color::should_color() \u0026lt;\u0026lt; std::endl; return 0; } マニピュレータ # namespace toml { namespace color { std::ostream\u0026amp; reset (std::ostream\u0026amp;); std::ostream\u0026amp; bold (std::ostream\u0026amp;); std::ostream\u0026amp; grey (std::ostream\u0026amp;); std::ostream\u0026amp; gray (std::ostream\u0026amp;); std::ostream\u0026amp; red (std::ostream\u0026amp;); std::ostream\u0026amp; green (std::ostream\u0026amp;); std::ostream\u0026amp; yellow (std::ostream\u0026amp;); std::ostream\u0026amp; blue (std::ostream\u0026amp;); std::ostream\u0026amp; magenta(std::ostream\u0026amp;); std::ostream\u0026amp; cyan (std::ostream\u0026amp;); std::ostream\u0026amp; white (std::ostream\u0026amp;); } // color } // toml ANSIエスケープシーケンスによって、fgを色付けします。\n例 # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; toml::color::red \u0026lt;\u0026lt; \u0026#34;red!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 関連項目 # error_info.hpp "},{"id":13,"href":"/toml11/ja/docs/reference/comments/","title":"comments.hpp","section":"reference","content":" comments.hpp # color.hppでは、コメントを保持するクラスが提供されます。\ntoml::preserve_comments # preserve_commentsは、コメントを保持するコンテナです。\nstd::vector\u0026lt;std::string\u0026gt;が持つメンバ関数を全て持っています。\nコメントはstd::stringとして保持されます。 先頭が#でない場合、出力時に#が補われます。コンテナに要素として追加する段階では補われません。 スペースは補われないため、#の直後にスペースを入れたい場合、コメントをスペースから始めるか、#を含めたコメントを渡す必要があります。\nnamespace toml { class preserve_comments; bool operator==(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator!=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026lt; (const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026lt;=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026gt; (const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026gt;=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); void swap(preserve_comments\u0026amp;, preserve_comments\u0026amp;); void swap(preserve_comments\u0026amp;, std::vector\u0026lt;std::string\u0026gt;\u0026amp;); void swap(std::vector\u0026lt;std::string\u0026gt;\u0026amp;, preserve_comments\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, const preserve_comments\u0026amp;); } //toml メンバ型 # using container_type = std::vector\u0026lt;std::string\u0026gt;; using size_type = container_type::size_type; using difference_type = container_type::difference_type; using value_type = container_type::value_type; using reference = container_type::reference; using const_reference = container_type::const_reference; using pointer = container_type::pointer; using const_pointer = container_type::const_pointer; using iterator = container_type::iterator; using const_iterator = container_type::const_iterator; using reverse_iterator = container_type::reverse_iterator; using const_reverse_iterator = container_type::const_reverse_iterator; メンバ関数 # デフォルトコンストラクタ # preserve_comments() = default; 空のpreserve_commentsを構築します。\nコピー・ムーブコンストラクタ # preserve_comments(preserve_comments const\u0026amp;) = default; preserve_comments(preserve_comments \u0026amp;\u0026amp;) = default; preserve_commentsをコピー・ムーブ構築します。\nコンストラクタ(std::vector\u0026lt;std::string\u0026gt;) # explicit preserve_comments(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; c); explicit preserve_comments(std::vector\u0026lt;std::string\u0026gt;\u0026amp;\u0026amp; c); std::vector\u0026lt;std::string\u0026gt;の内容を持つpreserve_commentsを構築します。\nコンストラクタ(discard_comments) # explicit preserve_comments(const discard_comments\u0026amp;); 空のpreserve_commentsを構築します。\nコンストラクタ(Iterator) # template\u0026lt;typename InputIterator\u0026gt; preserve_comments(InputIterator first, InputIterator last); std::stringを指すInputIteratorが表す範囲からpreserve_commentsを構築します。\nコンストラクタ(std::initializer_list) # preserve_comments(std::initializer_list\u0026lt;std::string\u0026gt; x); std::initializer_list\u0026lt;std::string\u0026gt;が表す範囲からpreserve_commentsを構築します。\nコンストラクタ(サイズ指定) # explicit preserve_comments(size_type n); preserve_comments(size_type n, const std::string\u0026amp; x); n個のコメントを持つpreserve_commentsを構築します。\nstd::stringを渡した場合、そのコメントをn個に複製します。\nデストラクタ # ~preserve_comments() = default; preserve_commentsを破棄します。\noperator=(preserve_comments) # preserve_comments\u0026amp; operator=(preserve_comments const\u0026amp;) = default; preserve_comments\u0026amp; operator=(preserve_comments \u0026amp;\u0026amp;) = default; preserve_commentsをコピー・ムーブ代入します。\noperator=(std::vector\u0026lt;std::string\u0026gt;) # preserve_comments\u0026amp; operator=(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; c); preserve_comments\u0026amp; operator=(std::vector\u0026lt;std::string\u0026gt;\u0026amp;\u0026amp; c); std::vector\u0026lt;std::string\u0026gt;をコピー・ムーブ代入します。\nassign # template\u0026lt;typename InputIterator\u0026gt; void assign(InputIterator first, InputIterator last); void assign(std::initializer_list\u0026lt;std::string\u0026gt; ini); void assign(size_type n, const std::string\u0026amp; val); std::vector\u0026lt;std::string\u0026gt;::assignと同等の効果を持ちます。\ninsert # iterator insert(const_iterator p, const std::string\u0026amp; x); iterator insert(const_iterator p, std::string\u0026amp;\u0026amp; x); iterator insert(const_iterator p, size_type n, const std::string\u0026amp; x); template\u0026lt;typename InputIterator\u0026gt; iterator insert(const_iterator p, InputIterator first, InputIterator last); iterator insert(const_iterator p, std::initializer_list\u0026lt;std::string\u0026gt; ini); std::vector\u0026lt;std::string\u0026gt;::insertと同等の効果を持ちます。\nemplace # template\u0026lt;typename ... Ts\u0026gt; iterator emplace(const_iterator p, Ts\u0026amp;\u0026amp; ... args); std::vector\u0026lt;std::string\u0026gt;::insertと同等の効果を持ちます。\nerase # iterator erase(const_iterator pos); iterator erase(const_iterator first, const_iterator last); std::vector\u0026lt;std::string\u0026gt;::insertと同等の効果を持ちます。\nswap # void swap(preserve_comments\u0026amp; other); 他のpreserve_commentsと内容を交換します。\npush_back # void push_back(const std::string\u0026amp; v); void push_back(std::string\u0026amp;\u0026amp; v); std::vector\u0026lt;std::string\u0026gt;::push_backと同等の効果を持ちます。\npop_back # void pop_back(); std::vector\u0026lt;std::string\u0026gt;::pop_backと同等の効果を持ちます。\nemplace_back # template\u0026lt;typename ... Ts\u0026gt; void emplace_back(Ts\u0026amp;\u0026amp; ... args); std::vector\u0026lt;std::string\u0026gt;::emplace_backと同等の効果を持ちます。\nclear # void clear(); std::vector\u0026lt;std::string\u0026gt;::clearと同等の効果を持ちます。\nsize # size_type size() const noexcept; std::vector\u0026lt;std::string\u0026gt;::sizeと同等の効果を持ちます。\nmax_size # size_type max_size() const noexcept; std::vector\u0026lt;std::string\u0026gt;::max_sizeと同等の効果を持ちます。\ncapacity # size_type capacity() const noexcept; std::vector\u0026lt;std::string\u0026gt;::capacityと同等の効果を持ちます。\nempty # bool empty() const noexcept; std::vector\u0026lt;std::string\u0026gt;::emptyと同等の効果を持ちます。\nreserve # void reserve(size_type n); std::vector\u0026lt;std::string\u0026gt;::reserveと同等の効果を持ちます。\nresize # void resize(size_type n); void resize(size_type n, const std::string\u0026amp; c); std::vector\u0026lt;std::string\u0026gt;::resizeと同等の効果を持ちます。\nshrink_to_fit # void shrink_to_fit(); std::vector\u0026lt;std::string\u0026gt;::shrink_to_fitと同等の効果を持ちます。\noperator[] # reference operator[](const size_type n) noexcept; const_reference operator[](const size_type n) const noexcept; std::vector\u0026lt;std::string\u0026gt;::operator[]と同等の効果を持ちます。\nat # reference at(const size_type n) ; const_reference at(const size_type n) const; std::vector\u0026lt;std::string\u0026gt;::atと同等の効果を持ちます。\nfront # reference front() noexcept; const_reference front() const noexcept; std::vector\u0026lt;std::string\u0026gt;::frontと同等の効果を持ちます。\nback # reference back() noexcept; const_reference back() const noexcept; std::vector\u0026lt;std::string\u0026gt;::backと同等の効果を持ちます。\ndata # pointer data() noexcept; const_pointer data() const noexcept; std::vector\u0026lt;std::string\u0026gt;::dataと同等の効果を持ちます。\nbegin/end # iterator begin() noexcept; iterator end() noexcept; const_iterator begin() const noexcept; const_iterator end() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; std::vector\u0026lt;std::string\u0026gt;::begin/endと同等の効果を持ちます。\nrbegin/rend # reverse_iterator rbegin() noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rbegin() const noexcept; const_reverse_iterator rend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; std::vector\u0026lt;std::string\u0026gt;::rbegin/rendと同等の効果を持ちます。\n非メンバ関数 # 比較演算子 # bool operator==(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator!=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026lt; (const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026lt;=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026gt; (const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026gt;=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); std::vector\u0026lt;std::string\u0026gt;と同様に比較を行います。\nswap # void swap(preserve_comments\u0026amp;, preserve_comments\u0026amp;); void swap(preserve_comments\u0026amp;, std::vector\u0026lt;std::string\u0026gt;\u0026amp;); void swap(std::vector\u0026lt;std::string\u0026gt;\u0026amp;, preserve_comments\u0026amp;); ストリーム演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, const preserve_comments\u0026amp;); コメントとして出力します。\n先頭が#でない場合、#が補われます。\ntoml::discard_comments # discard_commentsは、コメントを破棄するコンテナです。\nstd::vector\u0026lt;std::string\u0026gt;が持つメンバ関数を全て持っていますが、内容を変更する関数を呼び出しても何も効果はなく、常に空になります。\nnamespace toml { class discard_comments; bool operator==(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator!=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026lt; (const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026lt;=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026gt; (const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026gt;=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); void swap(discard_comments\u0026amp;, discard_comments\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, const discard_comments\u0026amp;); } //toml メンバ型 # // container_type is not defined using size_type = std::size_t; using difference_type = std::ptrdiff_t; using value_type = std::string; using reference = std::string\u0026amp;; using const_reference = std::string const\u0026amp;; using pointer = std::string*; using const_pointer = std::string const*; using iterator = /* internal type: empty-iterator */ using const_iterator = /* internal type: empty-iterator */ using reverse_iterator = /* internal type: empty-iterator */ using const_reverse_iterator = /* internal type: empty-iterator */ デフォルトコンストラクタ # discard_comments() = default; 空のdiscard_commentsを構築します。\nコピー・ムーブコンストラクタ # discard_comments(discard_comments const\u0026amp;) = default; discard_comments(discard_comments \u0026amp;\u0026amp;) = default; discard_commentsをコピー・ムーブ構築します。\nコンストラクタ(std::vector\u0026lt;std::string\u0026gt;) # explicit discard_comments(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; c); explicit discard_comments(std::vector\u0026lt;std::string\u0026gt;\u0026amp;\u0026amp; c); 空のdiscard_commentsを構築します。引数の内容は無視されます。\nコンストラクタ(preserve_comments) # explicit discard_comments(const preserve_comments\u0026amp;); 空のdiscard_commentsを構築します。引数の内容は無視されます。\nコンストラクタ(Iterator) # template\u0026lt;typename InputIterator\u0026gt; discard_comments(InputIterator first, InputIterator last); 空のdiscard_commentsを構築します。引数の内容は無視されます。\nコンストラクタ(std::initializer_list) # discard_comments(std::initializer_list\u0026lt;std::string\u0026gt; x); 空のdiscard_commentsを構築します。引数の内容は無視されます。\nコンストラクタ(サイズ指定) # explicit discard_comments(size_type n); discard_comments(size_type n, const std::string\u0026amp; x); 空のdiscard_commentsを構築します。引数の内容は無視されます。\nデストラクタ # ~discard_comments() = default; discard_commentsを破棄します。\noperator=(discard_comments) # discard_comments\u0026amp; operator=(discard_comments const\u0026amp;) = default; discard_comments\u0026amp; operator=(discard_comments \u0026amp;\u0026amp;) = default; discard_commentsをコピー・ムーブ代入します。\noperator=(std::vector\u0026lt;std::string\u0026gt;) # discard_comments\u0026amp; operator=(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; c); discard_comments\u0026amp; operator=(std::vector\u0026lt;std::string\u0026gt;\u0026amp;\u0026amp; c); 何もしません。引数の内容は無視されます。\nassign # template\u0026lt;typename InputIterator\u0026gt; void assign(InputIterator first, InputIterator last); void assign(std::initializer_list\u0026lt;std::string\u0026gt; ini); void assign(size_type n, const std::string\u0026amp; val); 何もしません。引数の内容は無視されます。\ninsert # iterator insert(const_iterator p, const std::string\u0026amp; x); iterator insert(const_iterator p, std::string\u0026amp;\u0026amp; x); iterator insert(const_iterator p, size_type n, const std::string\u0026amp; x); template\u0026lt;typename InputIterator\u0026gt; iterator insert(const_iterator p, InputIterator first, InputIterator last); iterator insert(const_iterator p, std::initializer_list\u0026lt;std::string\u0026gt; ini); 何もしません。引数の内容は無視されます。\nemplace # template\u0026lt;typename ... Ts\u0026gt; iterator emplace(const_iterator p, Ts\u0026amp;\u0026amp; ... args); 何もしません。引数の内容は無視されます。\nerase # iterator erase(const_iterator pos); iterator erase(const_iterator first, const_iterator last); 何もしません。引数の内容は無視されます。\nswap # void swap(discard_comments\u0026amp; other); 他のdiscard_commentsと内容を交換します。\npush_back # void push_back(const std::string\u0026amp; v); void push_back(std::string\u0026amp;\u0026amp; v); 何もしません。引数の内容は無視されます。\npop_back # void pop_back(); 何もしません。引数の内容は無視されます。\nemplace_back # template\u0026lt;typename ... Ts\u0026gt; void emplace_back(Ts\u0026amp;\u0026amp; ... args); 何もしません。引数の内容は無視されます。\nclear # void clear(); 何もしません。引数の内容は無視されます。\nsize # size_type size() const noexcept; 常に0を返します。\nmax_size # size_type max_size() const noexcept; 常に0を返します。\ncapacity # size_type capacity() const noexcept; 常に0を返します。\nempty # bool empty() const noexcept; 常にtrueを返します。\nreserve # void reserve(size_type n); 何もしません。引数の内容は無視されます。\nresize # void resize(size_type n); void resize(size_type n, const std::string\u0026amp; c); 何もしません。引数の内容は無視されます。\nshrink_to_fit # void shrink_to_fit(); 何もしません。引数の内容は無視されます。\noperator[] # reference operator[](const size_type n) noexcept; const_reference operator[](const size_type n) const noexcept; 未定義動作です。\nat # reference at(const size_type n) ; const_reference at(const size_type n) const; std::out_of_rangeを送出します。\nfront # reference front() noexcept; const_reference front() const noexcept; 未定義動作です。\nback # reference back() noexcept; const_reference back() const noexcept; 未定義動作です。\ndata # pointer data() noexcept; const_pointer data() const noexcept; 常にnullptrを返します。\nbegin/end # iterator begin() noexcept; iterator end() noexcept; const_iterator begin() const noexcept; const_iterator end() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; 内部で定義されたempty-iteratorを返します。\nempty-iteratorはインクリメントやデクリメントしても同じ値でとどまり、全ての値が同値です。\nempty-iteratorが指す先にアクセスすると常にstd::terminateが呼び出されます。\nrbegin/rend # reverse_iterator rbegin() noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rbegin() const noexcept; const_reverse_iterator rend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; 内部で定義されたempty-iteratorを返します。\nempty-iteratorはインクリメントやデクリメントしても同じ値でとどまり、全ての値が同値です。\nempty-iteratorが指す先にアクセスすると常にstd::terminateが呼び出されます。\n非メンバ関数 # 比較演算子 # bool operator==(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator!=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026lt; (const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026lt;=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026gt; (const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026gt;=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); discard_commentsは全て同じ値です。==には常にtrueを、!=には常にfalseを返します。\nswap # void swap(discard_comments\u0026amp;, discard_comments\u0026amp;); 二つのdiscard_commentsを交換します。\nストリーム演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, const discard_comments\u0026amp;); 何も出力しません。\n関連項目 # value.hpp "},{"id":14,"href":"/toml11/ja/docs/reference/conversion/","title":"conversion.hpp","section":"reference","content":" conversion.hpp # toml::getやtoml::findでユーザー定義型をサポートするための変換関数を自動定義するマクロを提供します。\nTOML11_DEFINE_CONVERSION_NON_INTRUSIVE(NAME, ...) 例 # namespace foo { struct Foo { std::string s; double d; int i; }; } // foo TOML11_DEFINE_CONVERSION_NON_INTRUSIVE(foo::Foo, s, d, i) 関連項目 # from.hpp into.hpp "},{"id":15,"href":"/toml11/ja/docs/reference/datetime/","title":"datetime.hpp","section":"reference","content":" datetime.hpp # TOMLのdatetimeで使用される、日時情報を保存するクラスを定義します。\nenum class month_t # 月を指定するenum classです。\nstd::tmとの関係で、local_dateは1月を0としています。 混乱を避けるため、月の名前で指定できるようmonth_tが用意されています。\nnamespace toml { enum class month_t : std::uint8_t { Jan = 0, Feb = 1, Mar = 2, Apr = 3, May = 4, Jun = 5, Jul = 6, Aug = 7, Sep = 8, Oct = 9, Nov = 10, Dec = 11 }; } local_date # 日付を保持する構造体です。\nyearは西暦を、monthはstd::tmとの対応のため1月を0として、dayは日付を保持します。\nnamespace toml { struct local_date { std::int16_t year; std::uint8_t month; std::uint8_t day; local_date() = default; ~local_date() = default; local_date(local_date const\u0026amp;) = default; local_date(local_date\u0026amp;\u0026amp;) = default; local_date\u0026amp; operator=(local_date const\u0026amp;) = default; local_date\u0026amp; operator=(local_date\u0026amp;\u0026amp;) = default; local_date(int y, month_t m, int d); explicit local_date(const std::tm\u0026amp; t); explicit local_date(const std::chrono::system_clock::time_point\u0026amp; tp); explicit local_date(const std::time_t t); operator std::chrono::system_clock::time_point() const; operator std::time_t() const; }; bool operator==(const local_date\u0026amp;, const local_date\u0026amp;); bool operator!=(const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026lt; (const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026lt;=(const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026gt; (const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026gt;=(const local_date\u0026amp;, const local_date\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_date\u0026amp; date); std::string to_string(const local_date\u0026amp; date); } メンバ変数 # year # std::int16_t year; 西暦です。オフセットはありません。2024年は2024です。\nmonth # std::uint8_t month; 月を表します。std::tmとの対応のため、1月は0, 2月は1と続きます。\n混乱を避けるため、構築の際はmonth_tを使用します。\nday # std::uint8_t day; 日付を表します。1日は1です。\nメンバ関数 # コンストラクタ # local_date() = default; デフォルト実装を使用します。\nデストラクタ # ~local_date() = default; デフォルト実装を使用します。\nコピー・ムーブコンストラクタ # local_date(local_date const\u0026amp;) = default; local_date(local_date\u0026amp;\u0026amp;) = default; デフォルト実装を使用します。\nコピー・ムーブ代入演算子 # local_date\u0026amp; operator=(local_date const\u0026amp;) = default; local_date\u0026amp; operator=(local_date\u0026amp;\u0026amp;) = default; デフォルト実装を使用します。\nコンストラクタ(int year, month_t month, int day) # local_date(int y, month_t m, int d); 指定した値からlocal_dateを構築します。\n境界チェックなどは行いません。\nコンストラクタ(std::tm) # local_date(const std::tm\u0026amp;); 指定した値からlocal_dateを構築します。\nコンストラクタ(std::chrono::system_clock::time_point) # local_date(const std::chrono::system_clock::time_point\u0026amp;); 指定した値からlocal_dateを構築します。\nタイムゾーンは実行環境でのものが選択されます。\nコンストラクタ(std::time_t) # local_date(const std::time_t); 指定した値からlocal_dateを構築します。\nタイムゾーンは実行環境でのものが選択されます。\noperator std::chrono::system_clock::time_point # operator std::chrono::system_clock::time_point() const; std::chrono::system_clock::time_pointに変換します。\nタイムゾーンは実行環境でのものが選択されます。\n時刻は0時00分とします。\noperator std::time_t # operator std::time_t() const; std::time_tに変換します。\nタイムゾーンは実行環境でのものが選択されます。\n時刻は0時00分とします。\n非メンバ関数 # 比較演算子 # bool operator==(const local_date\u0026amp;, const local_date\u0026amp;); bool operator!=(const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026lt; (const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026lt;=(const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026gt; (const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026gt;=(const local_date\u0026amp;, const local_date\u0026amp;); 日付の順序によって比較します。\nストリーム出力演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_date\u0026amp; date); TOMLのデフォルトのフォーマットで出力を行います。\nto_string # std::string to_string(const local_date\u0026amp; date); TOMLのデフォルトのフォーマットで文字列化します。\nlocal_time # namespace toml { struct local_time { std::uint8_t hour; // [0, 23] std::uint8_t minute; // [0, 59] std::uint8_t second; // [0, 60] std::uint16_t millisecond; // [0, 999] std::uint16_t microsecond; // [0, 999] std::uint16_t nanosecond; // [0, 999] local_time(int h, int m, int s, int ms = 0, int us = 0, int ns = 0); explicit local_time(const std::tm\u0026amp; t); template\u0026lt;typename Rep, typename Period\u0026gt; explicit local_time(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; t); operator std::chrono::nanoseconds() const; local_time() = default; ~local_time() = default; local_time(local_time const\u0026amp;) = default; local_time(local_time\u0026amp;\u0026amp;) = default; local_time\u0026amp; operator=(local_time const\u0026amp;) = default; local_time\u0026amp; operator=(local_time\u0026amp;\u0026amp;) = default; }; bool operator==(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator!=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026lt; (const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026lt;=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026gt; (const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026gt;=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_time\u0026amp; time); std::string to_string(const local_time\u0026amp; time); } メンバ変数 # hour # std::uint8_t hour; 時間を表します。0から23の値を取ります。\nminute # std::uint8_t minute; // [0, 59] 分を表します。0から59の値を取ります。\nsecond # std::uint8_t second; // [0, 60] 秒を表します。0から60の値を取ります。\nmillisecond # std::uint16_t millisecond; // [0, 999] ミリ秒を表します。0から999の値を取ります。\nmicrosecond # std::uint16_t microsecond; // [0, 999] マイクロ秒を表します。0から999の値を取ります。\nnanosecond # std::uint16_t nanosecond; // [0, 999] ナノ秒を表します。0から999の値を取ります。\nメンバ関数 # デフォルトコンストラクタ # local_time() = default; 全ての値を0で初期化します。\nコンストラクタ(h, m, s, ms = 0, us = 0, ns = 0) # local_time(int h, int m, int s, int ms = 0, int us = 0, int ns = 0); 指定された時刻を使って構築します。\n境界チェックは行われません。\nコンストラクタ(std::tm) # explicit local_time(const std::tm\u0026amp; t); std::tmのtm_hour, tm_min, tm_secを使って構築します。\nサブセコンドは全て0で初期化されます。\nコンストラクタ(std::chrono::duration) # template\u0026lt;typename Rep, typename Period\u0026gt; explicit local_time(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; t); durationをその日の0時からの時間として構築します。\noperator std::chrono::nanoseconds # operator std::chrono::nanoseconds() const; std::chrono::nanosecondsへ変換します。\n非メンバ関数 # 比較演算子 # bool operator==(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator!=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026lt; (const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026lt;=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026gt; (const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026gt;=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); 時刻の値によって比較を行います。\nストリーム演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_time\u0026amp; time); TOMLのデフォルトのフォーマットで出力を行います。\nto_string # std::string to_string(const local_time\u0026amp; time); TOMLのデフォルトのフォーマットで文字列化します。\ntime_offset # namespace toml { struct time_offset { std::int8_t hour{0}; // [-12, 12] std::int8_t minute{0}; // [-59, 59] time_offset(int h, int m); operator std::chrono::minutes() const; time_offset() = default; ~time_offset() = default; time_offset(time_offset const\u0026amp;) = default; time_offset(time_offset\u0026amp;\u0026amp;) = default; time_offset\u0026amp; operator=(time_offset const\u0026amp;) = default; time_offset\u0026amp; operator=(time_offset\u0026amp;\u0026amp;) = default; }; bool operator==(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator!=(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026lt; (const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026lt;=(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026gt; (const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026gt;=(const time_offset\u0026amp;, const time_offset\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const time_offset\u0026amp; offset); std::string to_string(const time_offset\u0026amp; offset); } メンバ変数 # hour # std::int8_t hour{0}; // [-12, 12] 時間のオフセットです。-12から+12の範囲の値を取ります。\nminute # std::int8_t minute{0}; // [-59, 59] 分のオフセットです。-59から+59の範囲の値を取ります。\nメンバ関数 # コンストラクタ # time_offset(int h, int m); 時間と分を取って構築します。\n境界チェックは行いません。\noperator std::chrono::minutes # operator std::chrono::minutes() const; std::chrono::minutesへの変換を行います。\n非メンバ関数 # 比較演算子 # bool operator==(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator!=(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026lt; (const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026lt;=(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026gt; (const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026gt;=(const time_offset\u0026amp;, const time_offset\u0026amp;); 時刻の長さで比較します。\nストリーム出力演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const time_offset\u0026amp;); TOMLのデフォルトのフォーマットで出力を行います。\nto_string # std::string to_string(const time_offset\u0026amp;); TOMLのデフォルトのフォーマットで文字列化します。\nlocal_datetime # namespace toml { struct local_datetime { local_date date; local_time time; local_datetime(local_date d, local_time t); explicit local_datetime(const std::tm\u0026amp; t); explicit local_datetime(const std::chrono::system_clock::time_point\u0026amp; tp); explicit local_datetime(const std::time_t t); operator std::chrono::system_clock::time_point() const; operator std::time_t() const; local_datetime() = default; ~local_datetime() = default; local_datetime(local_datetime const\u0026amp;) = default; local_datetime(local_datetime\u0026amp;\u0026amp;) = default; local_datetime\u0026amp; operator=(local_datetime const\u0026amp;) = default; local_datetime\u0026amp; operator=(local_datetime\u0026amp;\u0026amp;) = default; }; bool operator==(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator!=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026lt; (const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026lt;=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026gt; (const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026gt;=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_datetime\u0026amp; dt); std::string to_string(const local_datetime\u0026amp; dt); } メンバ変数 # local_date date # local_date date; 日付部分のデータを保持します。\nlocal_time time # local_time time; 時刻部分のデータを保持します。\nメンバ関数 # デフォルトコンストラクタ # date, timeの双方をデフォルト構築します。\nコンストラクタ(local_date, local_time) # 指定されたdateとtimeで構築します。\nコンストラクタ(std::tm) # std::tmから構築します。\nタイムゾーンは実行環境でのものが選択されます。\nコンストラクタ(std::chrono::system_clock::time_point) # std::chrono::system_clock::time_pointから構築します。\nタイムゾーンは実行環境でのものが選択されます。\nコンストラクタ(std::time_t) # std::time_tから構築します。\nタイムゾーンは実行環境でのものが選択されます。\noperator std::chrono::system_clock::time_point # std::chrono::system_clock::time_pointへ変換します。\noperator std::time_t # std::time_tへ変換します。\n非メンバ関数 # 比較演算子 # bool operator==(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator!=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026lt; (const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026lt;=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026gt; (const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026gt;=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); 日付順で比較します。\nストリーム出力演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_datetime\u0026amp;); TOMLのデフォルトのフォーマットで出力を行います。\nto_string # std::string to_string(const local_datetime\u0026amp;); TOMLのデフォルトのフォーマットで文字列化します。\noffset_datetime # namespace toml { struct offset_datetime { local_date date; local_time time; time_offset offset; offset_datetime(local_date d, local_time t, time_offset o); offset_datetime(const local_datetime\u0026amp; dt, time_offset o); explicit offset_datetime(const local_datetime\u0026amp; ld); explicit offset_datetime(const std::chrono::system_clock::time_point\u0026amp; tp); explicit offset_datetime(const std::time_t\u0026amp; t); explicit offset_datetime(const std::tm\u0026amp; t); operator std::chrono::system_clock::time_point() const; operator std::time_t() const; offset_datetime() = default; ~offset_datetime() = default; offset_datetime(offset_datetime const\u0026amp;) = default; offset_datetime(offset_datetime\u0026amp;\u0026amp;) = default; offset_datetime\u0026amp; operator=(offset_datetime const\u0026amp;) = default; offset_datetime\u0026amp; operator=(offset_datetime\u0026amp;\u0026amp;) = default; }; bool operator==(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator!=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026lt; (const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026lt;=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026gt; (const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026gt;=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const offset_datetime\u0026amp; dt); std::string to_string(const offset_datetime\u0026amp; dt); } メンバ変数 # date # local_date date; 日付部分のデータを保持します。\ntime # local_time time; 時刻部分のデータを保持します。\noffset # time_offset offset; オフセット部分のデータを保持します。\nメンバ関数 # デフォルトコンストラクタ # date, time, offsetを全てデフォルト構築します。\nコンストラクタ(local_date, local_time, time_offset) # 指定されたdate, time, offsetで構築します。\nコンストラクタ(local_datetime, time_offset) # local_datetimeとoffsetから構築します。\nコンストラクタ(std::tm) # std::tmから構築します。\nタイムゾーンはUTC(00:00)になります。\nコンストラクタ(std::chrono::system_clock::time_point) # std::chrono::system_clock::time_pointから構築します。\nタイムゾーンはUTC(00:00)になります。\nコンストラクタ(std::time_t) # std::time_tから構築します。\nタイムゾーンはUTC(00:00)になります。\noperator std::chrono::system_clock::time_point # std::chrono::system_clock::time_pointへ変換します。\nタイムゾーンはUTC(00:00)になります。\noperator std::time_t # std::time_tへ変換します。\nタイムゾーンはUTC(00:00)になります。\n非メンバ関数 # 比較演算子 # bool operator==(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator!=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026lt; (const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026lt;=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026gt; (const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026gt;=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); 日付順で比較します。\n同じ日付の場合、タイムゾーン順で比較されます。\nストリーム出力演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const offset_datetime\u0026amp;); TOMLのデフォルトのフォーマットで出力を行います。\nto_string # std::string to_string(const offset_datetime\u0026amp;); TOMLのデフォルトのフォーマットで文字列化します。\n"},{"id":16,"href":"/toml11/ja/docs/reference/error_info/","title":"error_info.hpp","section":"reference","content":" error_info.hpp # error_info.hppでは、error_infoと、それをフォーマットする関数が定義されます。\ntoml::error_info # namespace toml { struct error_info { error_info(std::string t, source_location l, std::string m, std::string s = \u0026#34;\u0026#34;); error_info(std::string t, std::vector\u0026lt;std::pair\u0026lt;source_location, std::string\u0026gt;\u0026gt; l, std::string s = \u0026#34;\u0026#34;); std::string const\u0026amp; title() const noexcept; std::string \u0026amp; title() noexcept; std::vector\u0026lt;std::pair\u0026lt;source_location, std::string\u0026gt;\u0026gt; const\u0026amp; locations() const noexcept; void add_locations(source_location loc, std::string msg) noexcept; std::string const\u0026amp; suffix() const noexcept; std::string \u0026amp; suffix() noexcept; }; template\u0026lt;typename ... Ts\u0026gt; error_info make_error_info( std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); std::string format_error(const std::string\u0026amp; errkind, const error_info\u0026amp; err); std::string format_error(const error_info\u0026amp; err); template\u0026lt;typename ... Ts\u0026gt; std::string format_error(std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const error_info\u0026amp; e); } メンバ関数 # コンストラクタ(title, loc, msg, suffix) # 指定されたタイトル、位置情報、メッセージ、suffixからerror_infoを構築します。\nsuffixはデフォルトで空です。\nコンストラクタ(title, [{loc, msg}, ...], suffix) # 指定されたタイトル、位置情報とメッセージの配列、そしてsuffixからerror_infoを構築します。\nsuffixはデフォルトで空です。\nメンバ関数 # std::string title() # エラーメッセージのタイトルです。\nstd::vector\u0026lt;std::pair\u0026lt;source_location, std::string\u0026gt;\u0026gt; locations() # エラーの発生した位置とそれに関するメッセージです。\n複数指定可能です。\nstd::string suffix() # 最後に表示するメッセージです。ヒントや補足を表示します。\n非メンバ関数 # make_error_info # template\u0026lt;typename ... Ts\u0026gt; error_info make_error_info( std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); 新しくerror_infoを構築します。\nsource_locationまたはbasic_valueの後には、それに関するmsgが続かなければなりません。\nvalue.hpp では、 source_location の代わりに toml::basic_value を渡した際のオーバーロードが追加されます。\n末尾にはsuffixを渡すことが可能です。\nformat_error # error_info を以下のようにフォーマットします。\n{title} --\u0026gt; {locations().at(0).first.file_name()} | 1 | {locations().at(0).first.line()} | ^-- {locations().at(0).second} | 2 | {locations().at(1).first.line()} | ^-- {locations().at(1).second} {suffix} 二つの source_location のファイル名が異なる場合は、ファイル名が再度表示されます。\nstd::string format_error(const std::string\u0026amp; errkind, const error_info\u0026amp; err); std::string format_error(const error_info\u0026amp; err); error_infoをフォーマットします。\nerrkindが与えられなかった場合、赤色太字の[error]がtitleの前につけ足されます。\nerrkindが与えられた場合（空文字列の場合も含みます）、それが[error]の代わりに表示されます。\nnamespace toml { template\u0026lt;typename ... Ts\u0026gt; std::string format_error(std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); } // toml make_error_info を使って作成した error_info を format_error でフォーマットした文字列を返します。\nvalue.hpp では、 source_location の代わりに toml::basic_value を渡した際のオーバーロードが追加されます。\nストリーム演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const error_info\u0026amp; e); format_error(e)を呼び出し、それを出力します。\n関連項目 # color.hpp parser.hpp source_location.hpp "},{"id":17,"href":"/toml11/ja/docs/reference/exception/","title":"exception.hpp","section":"reference","content":" exception.hpp # toml::exception # toml11で定義される例外型の基底クラスです。\nnamespace toml { struct exception : public std::exception { public: virtual ~exception() noexcept override = default; virtual const char* what() const noexcept override {return \u0026#34;\u0026#34;;} }; } // toml メンバ関数 # デストラクタ # virtual ~exception() noexcept override = default; 派生する際に上書きします。\nwhat # virtual const char* what() const noexcept override {return \u0026#34;\u0026#34;;} エラーメッセージを返します。派生する際に上書きします。\n"},{"id":18,"href":"/toml11/ja/docs/reference/find/","title":"find.hpp","section":"reference","content":" find.hpp # toml::valueから値を検索し、同時に（必要な場合）型変換を行う関数です。\ntoml::value は格納する型を変更でき、toml::findはそれらに対応しているので、 厳密には全て toml::basic_value\u0026lt;TC\u0026gt; が使われています。ただしこれでは冗長なので、 関数の宣言と特に区別しなければならない場合を除いて、簡単のため説明文では toml::value と書きます。 説明文では、テンプレートパラメータTCを変更して型が変更されていれば toml::value::integer_type などの型は追従して変更されると解釈してください。 toml::find # 概要 # toml::findには、取り出したい型をテンプレート引数で、検索したい値のキーを引数で与えます。\ntemplate\u0026lt;typename T, typename TC, typename ... Keys\u0026gt; T find(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, Keys ... keys); サポートされている T の種類と変換の挙動に関しては、 toml::get と同様です。\nT が指定されなかった場合、 toml::value が返されます。\nキーは、 toml::value::key_type または std::size_t です。 複数個のキーが与えられた場合は、サブテーブルや配列に対して再帰的に検索が行われます。 toml::value::key_type が与えられた場合は toml::table として、 std::size_t が与えられた場合は toml::array として解釈されます。\n再帰的な検索に関しての注意 # TOMLには通常の bare key の他に、 \u0026quot; や ' で囲まれた quoted key というものがあります。 quoted key を使うと、 \u0026quot;foo.bar\u0026quot; = \u0026quot;baz\u0026quot; というようなキーを書くことができ、この場合はサブテーブルは構築されず、キーは foo.barとなります。 このようなパターンに対応するため、toml11ではキーの中に.が含まれていても分割は行わず、そのままの文字列で検索を行います。\n以下のTOMLファイルを考えます。\n[foo] [foo.bar] baz = \u0026#34;hoge\u0026#34; [\u0026#34;foo.bar\u0026#34;] baz = \u0026#34;fuga\u0026#34; これに対応するtoml::findの書き方は以下の通りです。\nconst auto input = toml::parse(\u0026#34;input.toml\u0026#34;); const auto baz1 = toml::find\u0026lt;std::string\u0026gt;(input, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;); // hoge const auto baz2 = toml::find\u0026lt;std::string\u0026gt;(input, \u0026#34;foo.bar\u0026#34;, \u0026#34;baz\u0026#34;); // fuga 参考：toml.io/ja/v1.0.0#キー\ntoml::find(value, key) # value を toml::table として key を検索したあと、 toml::get で変換を行います。\ntemplate\u0026lt;typename T, typename TC\u0026gt; /* toml::get\u0026lt;T\u0026gt;(const value\u0026amp;) と同等 */ find( const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); template\u0026lt;typename T, typename TC\u0026gt; /* toml::get\u0026lt;T\u0026gt;(value\u0026amp;) と同等 */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); template\u0026lt;typename T, typename TC\u0026gt; /* toml::get\u0026lt;T\u0026gt;(value\u0026amp;\u0026amp;) と同等 */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); Tが指定されない場合は、変換を行わずtoml::valueを返します。\ntemplate\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; const\u0026amp; find( basic_value\u0026lt;TC\u0026gt; const\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt;\u0026amp; find( basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; find( basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); 例外 # toml::value が table を保持していなかった場合、 toml::type_error が送出されます。\n格納している table が指定された要素を持っていなかった場合、 std::out_of_range が送出されます。\n指定された要素が T に変換できない場合 （ toml::get が変換に失敗する場合） 、 toml::type_error が送出されます。\ntoml::find(value, index) # value を toml::array として index 番目にアクセスし、 toml::get で変換を行います。\ntemplate\u0026lt;typename T, typename TC\u0026gt; /* toml::get\u0026lt;T\u0026gt;(const value\u0026amp;) と同等 */ find( const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const std::size_t index); template\u0026lt;typename T, typename TC\u0026gt; /* toml::get\u0026lt;T\u0026gt;(value\u0026amp;) と同等 */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const std::size_t index); template\u0026lt;typename T, typename TC\u0026gt; /* toml::get\u0026lt;T\u0026gt;(value\u0026amp;\u0026amp;) と同等 */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const std::size_t index); Tが指定されない場合は、変換を行わずtoml::valueを返します。\ntemplate\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; const\u0026amp; find(basic_value\u0026lt;TC\u0026gt; const\u0026amp; v, const std::size_t ky); template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt;\u0026amp; find(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const std::size_t ky); template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; find(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const std::size_t ky); 例外 # toml::value が array を保持していなかった場合、 toml::type_error が送出されます。\n格納している array が指定された数の要素を持っていなかった場合、std::out_of_rangeが送出されます。\n指定された要素が T に変換できない場合 （ toml::get が変換に失敗する場合） 、 toml::type_error が送出されます。\ntoml::find(value, keys...) # template\u0026lt;typename T, typename TC, typename K1, typename K2, typename ... Ks\u0026gt; /* toml::get\u0026lt;T\u0026gt;(const value\u0026amp;) と同等 */ find( const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K1\u0026amp; k1, const K2\u0026amp; k2, const Ks\u0026amp; ... ks); template\u0026lt;typename T, typename TC, typename K1, typename K2, typename ... Ks\u0026gt; /* toml::get\u0026lt;T\u0026gt;(value\u0026amp;) と同等 */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K1\u0026amp; k1, const K2\u0026amp; k2, const Ks\u0026amp; ... ks); template\u0026lt;typename T, typename TC, typename K1, typename K2, typename ... Ks\u0026gt; /* toml::get\u0026lt;T\u0026gt;(value\u0026amp;\u0026amp;) と同等 */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const K1\u0026amp; k1, const K2\u0026amp; k2, const Ks\u0026amp; ... ks); 再帰的にtoml::findが呼び出されます。\n失敗する条件とその際に送出される例外は toml::find と同じです。\ntoml::find_or(value, key, fallback) # template\u0026lt;typename T, typename TC, typename Key\u0026gt; T find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const Key\u0026amp; key, T\u0026amp;\u0026amp; opt); find_or は失敗した際のためのデフォルト値を受け取ることで、失敗時に例外を投げないようにします。\nこのデフォルト値は受け取る型Tと同じ型でなければなりません。 よって、 toml::find\u0026lt;T\u0026gt; とは違って、 find_or では T を指定せずとも推論されます。\nfind_or\u0026lt;T\u0026gt;のように T を指定することもできますが、その場合は常に新規な値が返されます。 参照を取得したい場合は、 T を指定しないでください。\nTがbasic_valueである場合 # template\u0026lt;typename TC, typename K\u0026gt; basic_value\u0026lt;TC\u0026gt;\u0026amp; find_or(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, basic_value\u0026lt;TC\u0026gt;\u0026amp; opt) noexcept template\u0026lt;typename TC, typename K\u0026gt; basic_value\u0026lt;TC\u0026gt; const\u0026amp; find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, const basic_value\u0026lt;TC\u0026gt;\u0026amp; opt) noexcept 対応する値を検索し、変換せずに返します。変換が必要ないため、参照を返すことができます。\n値が見つからなかった場合、デフォルト値を返します。\nTがtoml::value::{some_type}である場合 # template\u0026lt;typename T, typename TC, typename K\u0026gt; T\u0026amp; find_or(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, T\u0026amp; opt) noexcept template\u0026lt;typename T, typename TC, typename K\u0026gt; T const\u0026amp; find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, const T\u0026amp; opt) noexcept 対応する値を検索し、変換せずに返します。変換が必要ないため、参照を返すことができます。\n値が見つからなかった場合、あるいは異なる型が格納されていた場合、デフォルト値を返します。\nTがconst char*である場合 # template\u0026lt;typename TC, typename K\u0026gt; std::string find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; k, const char* opt) 対応する値を検索し、 std::string として返します。\n失敗時に const char* から std::string を構築するため、参照を返すことはできません。\nTがその他の型である場合 # template\u0026lt;typename T, typename TC, typename K\u0026gt; T find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, T opt) 対応する値を検索し、 T に変換して返します。\n変換を行うため、参照を返すことはできません。\n複数のキーが与えられた場合 # template\u0026lt;typename Value, typename K1, typename K2, typename K3, typename ... Ks\u0026gt; auto find_or(Value\u0026amp;\u0026amp; v, const K1\u0026amp; k1, const K2\u0026amp; k2, K3\u0026amp;\u0026amp; k3, Ks\u0026amp;\u0026amp; ... keys) noexcept -\u0026gt; decltype(find_or(v, k2, std::forward\u0026lt;K3\u0026gt;(k3), std::forward\u0026lt;Ks\u0026gt;(keys)...)) キーの列の最後の要素がデフォルト値であると解釈して、再帰的にfind_orを適用します。\nT の推論結果が toml::value または toml::value::some_type になる場合、参照を返すことができます。\nT を明示的に指定した場合、常に変換を行います。\n関連項目 # get.hpp value.hpp "},{"id":19,"href":"/toml11/ja/docs/reference/format/","title":"format.hpp","section":"reference","content":" format.hpp # toml::valueのフォーマット情報を持つ構造体と列挙型を定義します。\nindent_char # インデント情報を表す列挙体です。\nenum class indent_char : std::uint8_t { space, // use space tab, // use tab none // no indent }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const indent_char\u0026amp; c); std::string to_string(const indent_char); noneを選んだ場合、super tableでの値によらず、インデントは使用されません。\nシリアライズ対象の値のなかにspaceとtabを指定する値が同時に存在していた場合、その動作は未規定で、指定していない方の文字が出現する可能性があります。\nboolean_format_info # booleanのフォーマット情報です。\nstruct boolean_format_info {}; bool operator==(const boolean_format_info\u0026amp;, const boolean_format_info\u0026amp;) noexcept; bool operator!=(const boolean_format_info\u0026amp;, const boolean_format_info\u0026amp;) noexcept; booleanのフォーマット方法は一通りしかないため、設定できる値を持ちません。\ninteger_format # enum class integer_format : std::uint8_t { dec = 0, bin = 1, oct = 2, hex = 3, }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const integer_format f); std::string to_string(const integer_format); integerの基数を指定します。\ninteger_format_info # struct integer_format_info { integer_format fmt = integer_format::dec; bool uppercase = true; // use uppercase letters std::size_t width = 0; // minimal width (may exceed) std::size_t spacer = 0; // position of `_` (if 0, no spacer) std::string suffix = \u0026#34;\u0026#34;; // _suffix (library extension) }; bool operator==(const integer_format_info\u0026amp;, const integer_format_info\u0026amp;) noexcept; bool operator!=(const integer_format_info\u0026amp;, const integer_format_info\u0026amp;) noexcept; 例 # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value v(0xDEADBEEF); std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 3735928559 v.as_integer_fmt().uppercase = true; v.as_integer_fmt().fmt = toml::integer_format::hex; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 0xDEADBEEF v.as_integer_fmt().spacer = 4; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 0xDEAD_BEEF v.as_integer_fmt().spacer = 8; v.as_integer_fmt().width = 16; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 0x00000000_DEADBEEF } メンバ変数 # integer_format fmt # 基数を指定します。\nbool uppercase # 16進数表記で大文字を使用します。\nstd::size_t width # 最小の幅を指定します。値によってはこの幅を超えることがあります。\nフォーマットした値がこの幅よりも小さい場合、integer_format::decの場合は効果はありませんが、それ以外の場合は先頭にリーディング0が追加されます。\nstd::size_t spacer # アンダースコア_を追加する幅を指定します。\n3の場合1_234_567のように、4の場合0xdead_beefのようにフォーマットされます。\n0の場合、アンダースコアは挿入されません。\n不規則な幅を指定することはできません。\nstd::string suffix # toml11拡張のspec::ext_num_suffixをtrueにしている場合、そのsuffixがここに保存されます。\n参考：spec.hpp\nfloating_format # enum class floating_format : std::uint8_t { defaultfloat = 0, fixed = 1, // does not include exponential part scientific = 2, // always include exponential part hex = 3 // hexfloat extension }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const floating_format f); std::string to_string(const floating_format); floatingのフォーマット形式を指定します。 それぞれ、std::defaultfloat, std::fixed, std::scientific, std::hexfloatに対応します。\nhexfloatは、toml::spec::ext_hex_floatがtrueの場合のみ使用可能です。\n参考：spec.hpp\nfloating_format_info # struct floating_format_info { floating_format fmt = floating_format::defaultfloat; std::size_t prec = 0; // precision (if 0, use the default) std::string suffix = \u0026#34;\u0026#34;; // 1.0e+2_suffix (library extension) }; bool operator==(const floating_format_info\u0026amp;, const floating_format_info\u0026amp;) noexcept; bool operator!=(const floating_format_info\u0026amp;, const floating_format_info\u0026amp;) noexcept; 例 # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value pi(3.141592653589793); std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; // 3.14159 pi.as_floating_fmt().fmt = toml::floating_format::fixed; std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; // 3.141593 pi.as_floating_fmt().prec = 16; std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; // 3.1415926535897931 toml::value na(6.02214076e+23); std::cout \u0026lt;\u0026lt; na \u0026lt;\u0026lt; std::endl; // 6.022e+23 na.as_floating_fmt().fmt = toml::floating_format::fixed; std::cout \u0026lt;\u0026lt; na \u0026lt;\u0026lt; std::endl; // 602214075999999987023872.000000 na.as_floating_fmt().fmt = toml::floating_format::scientific; std::cout \u0026lt;\u0026lt; na \u0026lt;\u0026lt; std::endl; // 6.022141e+23 na.as_floating_fmt().prec = 16; std::cout \u0026lt;\u0026lt; na \u0026lt;\u0026lt; std::endl; // 6.0221407599999999e+23 return 0; } メンバ変数 # floating_format fmt # フォーマット形式を指定します。\nstd::size_t prec # 小数点以下の精度を指定します。\nstd::string suffix # toml11拡張のspec::ext_num_suffixをtrueにしている場合、そのsuffixがここに保存されます。\n参考：spec.hpp\nstring_format # enum class string_format : std::uint8_t { basic = 0, literal = 1, multiline_basic = 2, multiline_literal = 3 }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const string_format f); std::string to_string(const string_format); 文字列のフォーマット形式を指定します。\nstring_format_info # struct string_format_info { string_format fmt = string_format::basic; bool start_with_newline = false; }; bool operator==(const string_format_info\u0026amp;, const string_format_info\u0026amp;) noexcept; bool operator!=(const string_format_info\u0026amp;, const string_format_info\u0026amp;) noexcept; 例 # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value s(\u0026#34;foo\u0026#34;); std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; // \u0026#34;foo\u0026#34; s.as_string_fmt().fmt = toml::string_format::literal; std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; // \u0026#39;foo\u0026#39; s.as_string_fmt().fmt = toml::string_format::multiline_basic; std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; // \u0026#34;\u0026#34;\u0026#34;foo\u0026#34;\u0026#34;\u0026#34; s.as_string_fmt().fmt = toml::string_format::multiline_literal; std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; // \u0026#39;\u0026#39;\u0026#39;foo\u0026#39;\u0026#39;\u0026#39; toml::value multiline(\u0026#34;foo\\nbar\u0026#34;); std::cout \u0026lt;\u0026lt; multiline \u0026lt;\u0026lt; std::endl; // \u0026#34;foo\\nbar\u0026#34; multiline.as_string_fmt().fmt = toml::string_format::multiline_basic; std::cout \u0026lt;\u0026lt; multiline \u0026lt;\u0026lt; std::endl; // \u0026#34;\u0026#34;\u0026#34;foo // bar\u0026#34;\u0026#34;\u0026#34; multiline.as_string_fmt().start_with_newline = true; std::cout \u0026lt;\u0026lt; multiline \u0026lt;\u0026lt; std::endl; // \u0026#34;\u0026#34;\u0026#34; // foo // bar\u0026#34;\u0026#34;\u0026#34; multiline.as_string_fmt().fmt = toml::string_format::multiline_literal; std::cout \u0026lt;\u0026lt; multiline \u0026lt;\u0026lt; std::endl; // \u0026#39;\u0026#39;\u0026#39; // foo // bar\u0026#39;\u0026#39;\u0026#39; return 0; } メンバ変数 # string_format fmt # 文字列のフォーマット情報を指定します。\nbool start_with_newline # multiline_basicまたはmultiline_literalの場合、最初の\u0026quot;\u0026quot;\u0026quot;や'''の後に改行を入れるかどうかを指定します。\ndatetime_delimiter_kind # enum class datetime_delimiter_kind : std::uint8_t { upper_T = 0, lower_t = 1, space = 2, }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const datetime_delimiter_kind d); std::string to_string(const datetime_delimiter_kind); datetimeで日付と時刻の間のデリミタにどの文字を使うかを指定します。\nT, t, が使用可能です。\noffset_datetime_format_info # struct offset_datetime_format_info { datetime_delimiter_kind delimiter = datetime_delimiter_kind::upper_T; bool has_seconds = true; std::size_t subsecond_precision = 6; // [us] }; bool operator==(const offset_datetime_format_info\u0026amp;, const offset_datetime_format_info\u0026amp;) noexcept; bool operator!=(const offset_datetime_format_info\u0026amp;, const offset_datetime_format_info\u0026amp;) noexcept; 例 # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value v(toml::offset_datetime( toml::local_date(2025, toml::month_t::Mar, 29), toml::local_time(1, 23, 45, /*ms=*/678, /*us=*/901, /*ns=*/234), toml::time_offset(9, 0) )); std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 2025-03-29T01:23:45.678901+09:00 v.as_offset_datetime_fmt().subsecond_precision = 9; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 2025-03-29T01:23:45.678901234+09:00 v.as_offset_datetime_fmt().has_seconds = false; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 2025-03-29T01:23+09:00 v.as_offset_datetime_fmt().delimiter = toml::datetime_delimiter_kind::space; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 2025-03-29 01:23+09:00 return 0; } メンバ変数 # datetime_delimiter_kind delimiter # 使用するデリミタを指定します。\nbool has_seconds # 秒数を省略するかどうかを指定します。\nstd::size_t subsecond_precision # 秒以下の精度を何桁出力するかを指定します。\nlocal_datetime_format_info # struct local_datetime_format_info { datetime_delimiter_kind delimiter = datetime_delimiter_kind::upper_T; bool has_seconds = true; std::size_t subsecond_precision = 6; // [us] }; bool operator==(const local_datetime_format_info\u0026amp;, const local_datetime_format_info\u0026amp;) noexcept; bool operator!=(const local_datetime_format_info\u0026amp;, const local_datetime_format_info\u0026amp;) noexcept; メンバ変数 # datetime_delimiter_kind delimiter # 使用するデリミタを指定します。\nbool has_seconds # 秒数を省略するかどうかを指定します。\nstd::size_t subsecond_precision # 秒以下の精度を何桁出力するかを指定します。\nlocal_date_format_info # struct local_date_format_info { // nothing, for now }; bool operator==(const local_date_format_info\u0026amp;, const local_date_format_info\u0026amp;) noexcept; bool operator!=(const local_date_format_info\u0026amp;, const local_date_format_info\u0026amp;) noexcept; local_datetimeにはフォーマット指定するパラメータはありません。\nlocal_time_format_info # struct local_time_format_info { bool has_seconds = true; std::size_t subsecond_precision = 6; // [us] }; bool operator==(const local_time_format_info\u0026amp;, const local_time_format_info\u0026amp;) noexcept; bool operator!=(const local_time_format_info\u0026amp;, const local_time_format_info\u0026amp;) noexcept; メンバ変数 # bool has_seconds # 秒数を省略するかどうかを指定します。\nstd::size_t subsecond_precision # 秒以下の精度を何桁出力するかを指定します。\narray_format # enum class array_format : std::uint8_t { default_format = 0, oneline = 1, multiline = 2, array_of_tables = 3 // [[format.in.this.way]] }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const array_format f); std::string to_string(const array_format); default_format 適したフォーマットを自動的に選択します。ある程度長い配列は複数行になります。 oneline 全ての要素を一行でフォーマットします。 multiline 一行ごとに一つの要素を出力します。 array_of_tables [[array.of.tables]]の形式でフォーマットします。table以外の要素を含むことはできません。 array_format_info # struct array_format_info { array_format fmt = array_format::default_format; indent_char indent_type = indent_char::space; std::int32_t body_indent = 4; // indent in case of multiline std::int32_t closing_indent = 0; // indent of `]` }; bool operator==(const array_format_info\u0026amp;, const array_format_info\u0026amp;) noexcept; bool operator!=(const array_format_info\u0026amp;, const array_format_info\u0026amp;) noexcept; 例 # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value a(toml::array{ 3, 1, 4 }); a.as_array_fmt().fmt = toml::array_format::oneline; std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; // a = [3, 1, 4] a.as_array_fmt().fmt = toml::array_format::multiline; std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; // a = [ // 3, // 1, // 4, // ] a.as_array_fmt().body_indent = 4; a.as_array_fmt().closing_indent = 2; std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; // a = [ // 3, // 1, // 4, // ] return 0; } メンバ変数 # array_format fmt # フォーマット形式を指定します。\nindent_char indent_type # インデントに使用する文字の種類を選択します。\nstd::int32_t body_indent # array_format::multilineの場合、要素の前に出力するインデントの文字数を指定します。\nstd::int32_t closing_indent # array_format::multilineの場合、閉じ括弧]の前に出力するインデントの文字数を指定します。\ntable_format # enum class table_format : std::uint8_t { multiline = 0, // [foo] \\n bar = \u0026#34;baz\u0026#34; oneline = 1, // foo = {bar = \u0026#34;baz\u0026#34;} dotted = 2, // foo.bar = \u0026#34;baz\u0026#34; multiline_oneline = 3, // foo = { \\n bar = \u0026#34;baz\u0026#34; \\n } implicit = 4 // [x] defined by [x.y.z]. skip in serializer. }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const table_format f); std::string to_string(const table_format); multiline 複数行の通常のテーブルとしてフォーマットします。 oneline インラインテーブルとしてフォーマットします。 dotted a.b.c = \u0026quot;d\u0026quot;の形式でフォーマットします。 multiline_oneline 改行を含むインラインテーブルとしてフォーマットします。TOML v1.1.0以降で使用可能です。 参考：spec.hpp implicit [x.y.z.w]だけが定義されている際の[x], [x.y], [x.y.z]のように、暗黙定義としてスキップします。 TOMLの文法上、dottedはサブテーブルを持つことができます。\n[fruit] apple.color = \u0026#34;red\u0026#34; apple.taste.sweet = true # [fruit.apple] # INVALID # [fruit.apple.taste] # INVALID [fruit.apple.texture] # you can add sub-tables smooth = true toml11は現時点ではこのフォーマットに対応していません。 dottedテーブルの下にあるテーブルは全てdottedになり、テーブルは強制的にインラインテーブルになります。\ntable_format_info # struct table_format_info { table_format fmt = table_format::multiline; indent_char indent_type = indent_char::space; std::int32_t body_indent = 0; // indent of values std::int32_t name_indent = 0; // indent of [table] std::int32_t closing_indent = 0; // in case of {inline-table} }; bool operator==(const table_format_info\u0026amp;, const table_format_info\u0026amp;) noexcept; bool operator!=(const table_format_info\u0026amp;, const table_format_info\u0026amp;) noexcept; 例 # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value t(toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;pi\u0026#34;, 3.14}, {\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;}, { \u0026#34;table\u0026#34;, toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;pi\u0026#34;, 3.14}, {\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;} } }, }); std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; // pi = 3.14 // foo = \u0026#34;bar\u0026#34; // a = 42 // // [table] // pi = 3.14 // foo = \u0026#34;bar\u0026#34; // a = 42 // root table cannot be dotted. // t.as_table_fmt().fmt = toml::table_format::dotted; t.at(\u0026#34;table\u0026#34;).as_table_fmt().fmt = toml::table_format::dotted; std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; // table.pi = 3.14 // table.foo = \u0026#34;bar\u0026#34; // table.a = 42 // pi = 3.14 // foo = \u0026#34;bar\u0026#34; // a = 42 t.as_table_fmt().fmt = toml::table_format::oneline; std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; // {table = {pi = 3.14, foo = \u0026#34;bar\u0026#34;, a = 42}, pi = 3.14, foo = \u0026#34;bar\u0026#34;, a = 42} return 0; } メンバ変数 # table_format fmt # フォーマット方法を指定します。\nindent_char indent_type # インデントに使用する文字を指定します。\nstd::int32_t body_indent # キーの前に出力するインデントの幅を指定します。\nスーパーテーブルのインデント幅は加算されません。\nstd::int32_t name_indent # [table]形式のキーのインデントを指定します。\nスーパーテーブルのインデント幅は加算されません。\nstd::int32_t closing_indent # multiline_onelineの場合に、閉じ括弧}の前のインデント幅を指定します。\n"},{"id":20,"href":"/toml11/ja/docs/reference/from/","title":"from.hpp","section":"reference","content":" from.hpp # toml::getやtoml::findで使用する、toml::valueからの変換を定義する構造体です。\nメンバ関数にfrom_tomlを追加することによっても同じ機能を追加できますが、メンバ関数を追加できないクラスに対してはfrom\u0026lt;T\u0026gt;を使用してください。\nこのファイルでは特定の実装は提供しません。使用する際に、この構造体を特殊化してください。\nnamespace toml { template\u0026lt;typename T\u0026gt; struct from; } // toml 例 # namespace extlib { struct foo { int a; std::string b; }; } // extlib #include \u0026lt;toml11/from.hpp\u0026gt; namespace toml { template\u0026lt;\u0026gt; struct from\u0026lt;extlib::foo\u0026gt; { template\u0026lt;typename TC\u0026gt; static extlib::foo from_toml(const toml::basic_value\u0026lt;TC\u0026gt;\u0026amp; v) { return extlib::foo{toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;), toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;)}; } }; } // toml 関連項目 # conversion.hpp into.hpp "},{"id":21,"href":"/toml11/ja/docs/reference/get/","title":"get.hpp","section":"reference","content":" get.hpp # toml::valueから値を取り出し、同時に（必要な場合）型変換を行う関数です。\ntoml::value は格納する型を変更でき、toml::getはそれらに対応しているので、 厳密には全て toml::basic_value\u0026lt;TC\u0026gt; が使われています。ただしこれでは冗長なので、 関数の宣言と特に区別しなければならない場合を除いて、簡単のため説明文では toml::value と書きます。 説明文では、テンプレートパラメータTCを変更して型が変更されていれば toml::value::integer_type などの型は追従して変更されると解釈してください。 toml::get\u0026lt;T\u0026gt; # 概要 # 基本的に、toml::getは以下のような関数として振る舞います。 Tはtoml::get\u0026lt;int\u0026gt;(v)のようにして与えます。\ntemplate\u0026lt;typename T, typename TC\u0026gt; T get(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v); ただし、Tがどのような型であるかによって、toml::getは異なる挙動をします。\nTの型の種類は、\n変換が必要ない型 変換する必要がある型 に分けられます。\n細かい条件と、特別にサポートしている具体的な型については後述します。\n変換が必要ない型 # 変換が必要ないのは、渡された toml::value が格納している型です。 例えば、 toml::value::integer_type は std::int64_t のエイリアスなので、 toml::get\u0026lt;std::int64_t\u0026gt;(v) は変換を必要としません。 この場合、 toml:get は integer の値を toml::value から取り出し、その参照を返します。\n渡されたtoml::valueが可変参照(\u0026amp;)である場合、返す値も可変参照(\u0026amp;)です。 不変参照(const\u0026amp;)の場合、返す値も不変参照(const\u0026amp;)となります。 可変参照を返した場合、その参照を通してtoml::valueに格納されている値に上書きできます。\n変換が必要な型 # 上記の型以外については変換が必要です。 例えば、toml::value::integer_typeはstd::int64_tのエイリアスなので、toml::get\u0026lt;std::size_t\u0026gt;(toml::value\u0026amp;)は変換が必要です。 この場合、toml:getはintegerの値をtoml::valueから取り出し、それをキャストして返します。\ntoml11は簡単なキャストだけでなく、 toml::arrayからやstd::tuple\u0026lt;int, double, std::string\u0026gt;やstd::array\u0026lt;double, 4\u0026gt;、 toml::tableからstd::map\u0026lt;std::string, int\u0026gt;などの複雑な型変換をサポートします。 具体的には、続くセクションを参照してください。\n失敗した場合 # 期待した型変換を行えない場合があります。例えば、tableを持っているtoml::valueにtoml::get\u0026lt;int\u0026gt;(v)を適用した場合などです。\nこのような場合は、取り出そうとした型に最も似ている型への変換（今回はintなので、as_integer）が失敗したとして、toml::type_errorが送出されます。\nファイルからパースした場合、以下のようなエラーメッセージが出力されます。\nterminate called after throwing an instance of \u0026#39;toml::type_error\u0026#39; what(): toml::value::as_integer(): bad_cast to integer --\u0026gt; input.toml | 6 | [fruit] | ^^^^^^^-- the actual type is table Tがtoml::valueと同一のとき # template\u0026lt; T, typename TC\u0026gt; T\u0026amp; get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); template\u0026lt;typename T, typename TC\u0026gt; T const\u0026amp; get(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v); template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v); 条件：\nstd::is_same\u0026lt;T, basic_value\u0026lt;TC\u0026gt;\u0026gt; を満たす toml::valueからtoml::valueなので、変換は行われず、そのままの値が返されます。 他の関数の実装を一般化するためだけに存在しています。\n失敗しません。\nTがtoml::value::{some_type}のいずれかのとき # template\u0026lt;typename T, typename TC\u0026gt; T\u0026amp; get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); template\u0026lt;typename T, typename TC\u0026gt; T const\u0026amp; get(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v); template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v); 条件：\nTがtoml::valueが格納できる型（toml::value::boolean_typeなど）のどれかと同一であること toml::value が格納している型と同じ型、例えば toml::value::integer_type が toml::get\u0026lt;T\u0026gt; の T として指定されたとき、型変換の必要がないため参照を返すことが可能です。\n異なる型が格納されていた場合、toml::type_error が送出されます。\nTが異なるTypeConfigを持つbasic_value\u0026lt;OtherTC\u0026gt;のとき # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nTがtoml::basic_value\u0026lt;TC\u0026gt;ではない Tがtoml::basic_value\u0026lt;OtherTC\u0026gt;である 異なる型を格納し得るbasic_valueが指定された場合、変換が行われます。\n型変換が発生するので、返す値は新規な値であり、参照ではありません。\n失敗しません（メモリ枯渇などの場合を除く）。\nTが整数型の場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nstd::is_integral\u0026lt;T\u0026gt; を満たす std::is_same\u0026lt;T, bool\u0026gt; ではない toml::value::integer_type ではない toml::value を integer_type を保持しているとしてその値を取得し、それを T に変換して返します。\ntoml::value::integer_type 以外の型が格納されていた場合、 toml::type_error が送出されます。\nTが浮動小数点数型の場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nstd::is_floating_point\u0026lt;T\u0026gt; を満たす toml::value::floating_type ではない toml::valueをfloating_typeを保持しているとしてその値を取得し、それをTに変換して返します。\ntoml::value::floating_type 以外の型が格納されていた場合、 toml::type_error が送出されます。\nTがstd::string_viewの場合 # C++17以降でのみ使用可能です。\ntemplate\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nstd::is_same\u0026lt;std::string_view, T\u0026gt; を満たす toml::valueをstring_typeを保持しているとしてその値を取得し、それからstd::string_viewを構築して返します。\ntoml::value::string_type 以外の型が格納されていた場合、 toml::type_error が送出されます。\nTがstd::chrono::durationの場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nTがstd::chrono::duration\u0026lt;Rep, Period\u0026gt;である toml::valueをlocal_timeを保持しているとしてその値を取得し、それをstd::chrono::durationに変換して返します。\ntoml::value::local_time 以外の型が格納されていた場合、 toml::type_error が送出されます。\nTがstd::chrono::system_clock::time_pointの場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nstd::is_same\u0026lt;T, std::chrono::system_clock::time_point\u0026gt;を満たす toml::value を local_date, local_datetime, offset_datetimeのどれかを保持しているとしてその値を取得し、それをstd::chrono::system_clock::time_pointに変換して返します。\nlocal_date, local_datetime, offset_datetime 以外の型が格納されていた場合、 toml::type_error が送出されます。\nTがarray-likeである場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nTはT::iteratorを持つ TはT::value_typeを持つ TはT::push_back(x)を持つ Tはtoml::value::array_typeではない Tはstd::stringではない Tはstd::string_viewではない Tはmap-likeではない Tはfrom_toml()メンバ関数を持たない toml::from\u0026lt;T\u0026gt;が定義されていない toml::basic_value\u0026lt;TC\u0026gt;からのコンストラクタが定義されていない std::vector\u0026lt;int\u0026gt;やstd::deque\u0026lt;std::string\u0026gt;などが該当します。\ntoml::valueをarrayを保持しているとしてその値を取得し、それを指定されたコンテナに変換して返します。\ntoml::value::array_type 以外の型が格納されていた場合、 toml::type_error が送出されます。\nTがstd::arrayである場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nTはstd::array\u0026lt;U, N\u0026gt;である toml::valueをarrayを保持しているとしてその値を取得し、それを指定されたコンテナに変換して返します。\ntoml::value::array_type 以外の型が格納されていた場合、 toml::type_error が送出されます。\ntoml::value が持つ array が十分な数の要素を持っていなかった場合、std::out_of_rangeが送出されます。\nTがstd::forward_listである場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nTはstd::forward_list\u0026lt;U\u0026gt;である toml::valueをarrayを保持しているとしてその値を取得し、それをstd::forward_listに変換して返します。\ntoml::value::array_type 以外の型が格納されていた場合、 toml::type_error が送出されます。\nforward_listはpush_backを持たないので、別に実装されています。\nTがstd::pairである場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nTはstd::pair\u0026lt;T1, T2\u0026gt;である toml::valueをarrayを保持しているとしてその値を取得し、それをstd::pair\u0026lt;T1, T2\u0026gt;に変換して返します。\nfirst と second はそれぞれ再帰的に変換されます。\ntoml::value::array_type 以外の型が格納されていた場合、 toml::type_error が送出されます。\ntoml::value が持つ array の要素数がちょうど2個でなかった場合、std::out_of_rangeが送出されます。\nTがstd::tupleである場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nTはstd::tuple\u0026lt;T1, T2, ... TN\u0026gt;である toml::valueをarrayを保持しているとしてその値を取得し、それをstd::tuple\u0026lt;T1, T2, ...TN\u0026gt;に変換して返します。\n各要素はそれぞれ再帰的に変換されます。\ntoml::value::array_type 以外の型が格納されていた場合、 toml::type_error が送出されます。\ntoml::value が持つ array の要素数がちょうど std::tuple_size\u0026lt;T\u0026gt;::value 個でなかった場合、std::out_of_rangeが送出されます。\nTがmap-likeである場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\nTはT::iteratorを持つ TはT::key_typeを持つ TはT::value_typeを持つ TはT::mapped_typeを持つ Tはtoml::value::table_typeではない Tはfrom_toml()メンバ関数を持たない toml::from\u0026lt;T\u0026gt;が定義されていない toml::basic_value\u0026lt;TC\u0026gt;からのコンストラクタが定義されていない std::map\u0026lt;std::string, int\u0026gt;やstd::unordered_map\u0026lt;std::string, float\u0026gt;などが該当します。\ntoml::valueをtableを保持しているとしてその値を取得し、それを T に変換して返します。\n各要素はそれぞれ再帰的に変換されます。\nbasic_value::table_type 以外の型が格納されていた場合、 toml::type_error が送出されます。\nTがtoml::from\u0026lt;T\u0026gt;の特殊化を持つユーザー定義型である場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\ntoml::from\u0026lt;T\u0026gt;が定義されている toml::from の T に対する特殊化が定義されていた場合、それを使用した型変換が行われます。\n個別にサポートされる型（ std::array, std::pair, std::tuple ）と衝突しないようにしてください。\nTがT::from_tomlメンバ関数を持つユーザー定義型である場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\ntoml::from\u0026lt;T\u0026gt;が定義されていない Tはfrom_toml()メンバ関数を持つ T に from_toml(toml::basic_value\u0026lt;TC\u0026gt;) メンバ関数が定義されていた場合、それを使用した型変換が行われます。\ntoml::from\u0026lt;T\u0026gt; が定義されていると、そちらが優先されます。\nTがtoml::basic_value\u0026lt;TC\u0026gt;を取るコンストラクタを持つユーザー定義型である場合 # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); 条件：\ntoml::from\u0026lt;T\u0026gt;が定義されていない Tはfrom_toml()メンバ関数を持たない Tはtoml::basic_value\u0026lt;TC\u0026gt;を取るコンストラクタを持つ T に toml::basic_value\u0026lt;TC\u0026gt; を取るコンストラクタが定義されていた場合、それを使用した型変換が行われます。\ntoml::from\u0026lt;T\u0026gt; または T::from_toml が定義されていると、そちらが優先されます。\ntoml::get_or\u0026lt;T\u0026gt; # get_or は失敗した際のためのデフォルト値を受け取ることで、失敗時に例外を投げないようにします。\nこのデフォルト値は受け取る型Tと同じ型でなければなりません。 よって、 toml::get\u0026lt;T\u0026gt; とは違って、 get_or では T を指定せずとも推論されます。\nTがbasic_value\u0026lt;TC\u0026gt;である場合 # template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; const\u0026amp; get_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const basic_value\u0026lt;TC\u0026gt;\u0026amp; opt) template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; \u0026amp; get_or(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, basic_value\u0026lt;TC\u0026gt;\u0026amp; opt) template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; get_or(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; opt) 変換先は同一のtoml::valueなので、失敗しません。\n他の関数の実装を一般化するためだけに存在しています。\nTがbasic_value\u0026lt;TC\u0026gt;::{some_type}である場合 # template\u0026lt;typename T, typename TC\u0026gt; T const\u0026amp; get_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const T\u0026amp; opt) noexcept template\u0026lt;typename T, typename TC\u0026gt; T \u0026amp; get_or(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, T\u0026amp; opt) noexcept template\u0026lt;typename T, typename TC\u0026gt; T get_or(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, T\u0026amp;\u0026amp; opt) noexcept toml::get\u0026lt;T\u0026gt;と同様の変換を行います。失敗した場合は第二引数が返されます。\nTがconst char*である場合 # template\u0026lt;typename TC\u0026gt; typename basic_value\u0026lt;TC\u0026gt;::string_type get_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::string_type::value_type* opt); const char* が渡された場合、変換先は std::string として解釈されます。\nTがその他の場合 # template\u0026lt;typename TC\u0026gt; typename std::remove_cv\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026gt;::type get_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, T\u0026amp;\u0026amp; opt); toml::get\u0026lt;T\u0026gt;と同様の変換を行います。失敗した場合は第二引数が返されます。\n関連項目 # find.hpp from.hpp value.hpp "},{"id":22,"href":"/toml11/ja/docs/reference/into/","title":"into.hpp","section":"reference","content":" into.hpp # toml::valueのコンストラクタで使用する、ユーザー定義型からの変換を定義する構造体です。\nメンバ関数にinto_tomlを追加することによっても同じ機能を追加できますが、メンバ関数を追加できないクラスに対してはinto\u0026lt;T\u0026gt;を使用してください。\nこのファイルでは特定の実装は提供しません。使用する際に、この構造体を特殊化してください。\nnamespace toml { template\u0026lt;typename T\u0026gt; struct into; } // toml 例 # namespace extlib { struct foo { int a; std::string b; }; } // extlib #include \u0026lt;toml11/into.hpp\u0026gt; namespace toml { template\u0026lt;\u0026gt; struct into\u0026lt;extlib::foo\u0026gt; { template\u0026lt;typename TC\u0026gt; static toml::basic_value\u0026lt;TC\u0026gt; into_toml(const extlib::foo\u0026amp; f) { using value_type = toml::basic_value\u0026lt;TC\u0026gt;; using table_type = typename value_type::table_type; return value_type(table_type{{\u0026#34;a\u0026#34;, f.a}, {\u0026#34;b\u0026#34;, f.b}}); } }; } // toml 関連項目 # conversion.hpp from.hpp "},{"id":23,"href":"/toml11/ja/docs/reference/literal/","title":"literal.hpp","section":"reference","content":" literal.hpp # literal.hppでは、_tomlリテラルが定義されます。\n_tomlリテラルは、文字列リテラルをパースしてtoml::valueに変換します。\nnamespace toml { inline namespace literals { inline namespace toml_literals { toml::value operator\u0026#34;\u0026#34; _toml(const char* str, std::size_t len); toml::value operator\u0026#34;\u0026#34; _toml(const char8_t* str, std::size_t len); // C++20以降 } // toml_literals } // literals } // toml 自由関数 # operator\u0026quot;\u0026quot; _toml(char) # toml::value operator\u0026#34;\u0026#34; _toml(const char* str, std::size_t len); 文字列リテラルをパースしてtoml::valueに変換します。\n通常のTOMLファイルの場合、toml::parseと同等の処理が行われます。\nconst auto v1 = \u0026#34;a = \u0026#39;foo\u0026#39;\u0026#34;_toml; // v1: {a = \u0026#39;foo\u0026#39;} 改行を含む場合、生文字列リテラルが便利です。\nconst auto v1 = R\u0026#34;( a = 42 b = \u0026#34;foo\u0026#34; )\u0026#34;_toml; 値が単体で書かれていた場合、その値になります。\nconst auto v2 = \u0026#34;\u0026#39;foo\u0026#39;\u0026#34;_toml; // v2: \u0026#39;foo\u0026#39; TOMLは数値のみからなるキーを許可しています。 [1]のように、テーブル定義と配列の区別がつかない場合、テーブル定義が優先されます。\n配列として解釈させるには、trailing commaを使用してください。\nconst auto v3 = \u0026#34;[1]\u0026#34;_toml; // v3: {1 = {}} const auto v4 = \u0026#34;[1,]\u0026#34;_toml; // v4: [1,] operator\u0026quot;\u0026quot; _toml(char8_t) # char8_tが利用可能な場合に定義されます。引数の型のほかに違いはありません。\n例 # #include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto v = \u0026#34;a = \\\u0026#34;foo\\\u0026#34;\u0026#34;_toml; assert(v.at(\u0026#34;a\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); return 0; } "},{"id":24,"href":"/toml11/ja/docs/reference/ordered_map/","title":"ordered_map.hpp","section":"reference","content":" ordered_map.hpp # ファイル中の値の順番を維持するために使用するtoml::ordered_mapを定義します。\nclass ordered_map # namespace toml { template\u0026lt;typename Key, typename Val, typename Cmp = std::equal_to\u0026lt;Key\u0026gt;, typename Allocator = std::allocator\u0026lt;std::pair\u0026lt;Key, Val\u0026gt;\u0026gt;\u0026gt; class ordered_map; } ordered_mapは、値を追加した順序を保ったまま値を保持し、その順でイテレートできる map 型です。\n線形コンテナなので、検索には要素数に対して O(n) の時間がかかります。 検索を行う機会が少なく、値の順序を守る必要がある場合に使用してください。\n非メンバ型 # namespace toml { struct ordered_type_config; using ordered_value = basic_value\u0026lt;ordered_type_config\u0026gt;; using ordered_table = typename ordered_value::table_type; using ordered_array = typename ordered_value::array_type; } toml::type_config と toml::value の代わりに使用します。\ntoml::parse はデフォルトで type_config を使用するので、パースする際に\nconst auto input = toml::parse\u0026lt;toml::ordered_type_config\u0026gt;(\u0026#34;input.toml\u0026#34;); としてください。\nメンバ型 # using key_type = Key; using mapped_type = Val; using value_type = std::pair\u0026lt;Key, Val\u0026gt;; using key_compare = Cmp; using allocator_type = Allocator; using container_type = std::vector\u0026lt;value_type, Allocator\u0026gt;; using reference = typename container_type::reference; using pointer = typename container_type::pointer; using const_reference = typename container_type::const_reference; using const_pointer = typename container_type::const_pointer; using iterator = typename container_type::iterator; using const_iterator = typename container_type::const_iterator; using size_type = typename container_type::size_type; using difference_type = typename container_type::difference_type; メンバ関数 # コンストラクタ # ordered_map() = default; 空の ordered_map を構築します。\nコンストラクタ（コンパレータ、アロケータ） # explicit ordered_map(const Cmp\u0026amp; cmp, const Allocator\u0026amp; alloc = Allocator()); explicit ordered_map(const Allocator\u0026amp; alloc); キーの比較に使用するコンパレータや、コンテナのメモリ確保に使用するアロケータを指定して構築します。\nコピー・ムーブコンストラクタ # ordered_map(const ordered_map\u0026amp;) = default; ordered_map(ordered_map\u0026amp;\u0026amp;) = default; ordered_map(const ordered_map\u0026amp; other, const Allocator\u0026amp; alloc); ordered_map(ordered_map\u0026amp;\u0026amp; other, const Allocator\u0026amp; alloc); 別の ordered_map の内容をコピー・ムーブして構築します。\nコンテナのメモリ確保に使用するアロケータを指定することも可能です。\nコンストラクタ（Iterator） # template\u0026lt;typename InputIterator\u0026gt; ordered_map(InputIterator first, InputIterator last, const Cmp\u0026amp; cmp = Cmp(), const Allocator\u0026amp; alloc = Allocator()); template\u0026lt;typename InputIterator\u0026gt; ordered_map(InputIterator first, InputIterator last, const Allocator\u0026amp; alloc = Allocator()); イテレータ範囲を受け取って構築します。\n順序は、イテレータの順序に従います。\nコンストラクタ（std::initializer_list） # ordered_map(std::initializer_list\u0026lt;value_type\u0026gt; v, const Cmp\u0026amp; cmp = Cmp(), const Allocator\u0026amp; alloc = Allocator()); ordered_map(std::initializer_list\u0026lt;value_type\u0026gt; v, const Allocator\u0026amp; alloc); ordered_map{...}の形式で初期化します。\nコピー・ムーブ代入演算子 # ordered_map\u0026amp; operator=(const ordered_map\u0026amp;) = default; ordered_map\u0026amp; operator=(ordered_map\u0026amp;\u0026amp;) = default; 別の ordered_map の内容をコピー・ムーブ代入します。\n代入演算子（std::initializer_list） # ordered_map\u0026amp; operator=(std::initializer_list\u0026lt;value_type\u0026gt; v); std::initializer_list の内容を代入します。\nデストラクタ # ~ordered_map() = default; ordered_map を破棄します。\nbegin(), end() # iterator begin() noexcept; iterator end() noexcept; const_iterator begin() const noexcept; const_iterator end() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; コンテナの内容を順序通りにイテレートします。\nempty() # bool empty() const noexcept; ordered_map が空の場合 true を、そうでない場合 false を返します。\nsize() # std::size_t size() const noexcept; ordered_map の要素数を返します。\nmax_size() # std::size_t max_size() const noexcept; ordered_map が持つことのできる最大の要素数を返します。\nclear() # void clear(); 内容を消去します。\npush_back(kv) # void push_back(const value_type\u0026amp;); void push_back(value_type\u0026amp;\u0026amp;); キーと値のペアを末尾に追加します。\nemplace_back(k, v) # void emplace_back(key_type, mapped_type); キーと値のペアを末尾に追加します。\npop_back() # void pop_back(); 末尾の値を削除します。\ninsert(kv) # void insert(value_type); キーと値のペアを末尾に追加します。\nemplace(k, v) # void emplace(key_type, mapped_type); キーと値のペアを末尾に追加します。\ncount(k) # std::size_t count(const key_type\u0026amp;) const noexcept; キーに対応する値の数を返します。\n同じキーに複数の値を代入することはできないので、値が存在する場合は 1, そうでない場合は 0 を返します。\ncontains(k) # bool contains(const key_type\u0026amp;) const noexcept; キーに対応する値が存在するなら true を、そうでないなら false を返します。\nfind(k) # iterator find(const key_type\u0026amp; key) noexcept; const_iterator find(const key_type\u0026amp; key) const noexcept; キーに対応する値を検索し、それを指すイテレータを返します。\n存在しなかった場合、end()を返します。\nat(k) # mapped_type\u0026amp; at(const key_type\u0026amp; k); mapped_type const\u0026amp; at(const key_type\u0026amp; k) const; キーに対応する値を検索して返します。\n存在しなかった場合、std::out_of_rangeを送出します。\noperator[](k) # mapped_type\u0026amp; operator[](const key_type\u0026amp; k); mapped_type const\u0026amp; operator[](const key_type\u0026amp; k) const; キーに対応する値を検索して返します。\n存在しなかった場合、新規な値を構築して返します。\nordered_map が const の場合は新規な値を構築できないので、 std::out_of_range を送出します。\nerase(...) # iterator erase(iterator pos); iterator erase(const_iterator pos); iterator erase(const_iterator first, const_iterator last); size_type erase(const key_type\u0026amp; key); イテレータの指す位置の値、あるいはキーに該当する値を削除します。\nkey_comp() # key_compare key_comp() const; 比較に使用するコンパレータを返します。\n使用上の注意 # キーの書き換え # ordered_map は value_type に std::pair\u0026lt;Key, Val\u0026gt; を使用しているので、イテレータを介してキーを書き換えることが可能になってしまっています。\nこの方法でキーを書き換えることは推奨されません。\nキーを書き換えて既存のキーと衝突した場合、衝突したうちの片方が検索できなくなります。\noperator[] や push_back, insert による書き込みの場合は、既存のキーとの衝突が検出されます。\n保たれる順序の詳細 # ordered_map はキーの順序を保ちますが、ここで保たれる順序は同じテーブルで定義されたキーの順序のみです。 よって、テーブルをまたいだ順序は保たれないことに注意してください。\n例えば、以下のファイルの順序は保たれます。\napple.type = \u0026#34;fruit\u0026#34; apple.skin = \u0026#34;thin\u0026#34; apple.color = \u0026#34;red\u0026#34; orange.type = \u0026#34;fruit\u0026#34; orange.skin = \u0026#34;thick\u0026#34; orange.color = \u0026#34;orange\u0026#34; 対して以下のファイルの順序は保たれません。\napple.type = \u0026#34;fruit\u0026#34; orange.type = \u0026#34;fruit\u0026#34; apple.skin = \u0026#34;thin\u0026#34; orange.skin = \u0026#34;thick\u0026#34; apple.color = \u0026#34;red\u0026#34; orange.color = \u0026#34;orange\u0026#34; ordered_map が保つ順序は、rootテーブルに定義された apple と orange の順序と、 apple 内で定義された type, skin, color の順序、 また orange 内で定義された type, skin, color の順序のみです。\n関連項目 # parser.hpp types.hpp value.hpp "},{"id":25,"href":"/toml11/ja/docs/reference/parser/","title":"parser.hpp","section":"reference","content":" parser.hpp # ファイルまたは文字列をパースする関数と、それが用いる例外を定義します。\nparseは失敗した場合に例外を送出しますが、try_parseはエラー情報を返します。\nparse # 与えられたファイルの内容をパースし、toml::basic_valueを返します。\n失敗した場合はtoml::syntax_errorが送出されます。\nbasic_valueの持つ型情報はtemplateで、TOML言語のバージョンはtoml::specで指定します。\nparse(std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(std::string fname, spec s = spec::default_version()); } ファイル名を受け取って、その内容をパースします。\nファイルの読み込みに失敗した場合、file_io_errorが送出されます。\nパースに失敗した場合、syntax_errorが送出されます。\nparse(const char (\u0026amp;)[N] filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config, std::size_t N\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(const char (\u0026amp;fname)[N], spec s = spec::default_version()); } 文字列リテラルを受け取って、そのファイルの内容をパースします。\nファイルの読み込みに失敗した場合、file_io_errorが送出されます。\nパースに失敗した場合、syntax_errorが送出されます。\nparse(std::filesystem::path, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(const std::filesystem::path\u0026amp; fpath, spec s = spec::default_version()); } \u0026lt;filesystem\u0026gt;が利用可能な場合のみ定義されます。\nファイルパスを受け取って、そのファイルの内容をパースします。\nファイルの読み込みに失敗した場合、file_io_errorが送出されます。\nパースに失敗した場合、syntax_errorが送出されます。\nparse(std::istream\u0026amp;, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(std::istream\u0026amp; is, std::string fname = \u0026#34;unknown file\u0026#34;, spec s = spec::default_version()); } std::istream\u0026amp;を受け取ってその内容をパースします。\n標準ライブラリが改行文字を自動変換することによるファイルサイズと文字数との不整合を避けるため、 std::ios::binaryを使ってバイナリモードで開いてください。\nファイル名の情報は第三引数で受け取ります。ファイル名が渡されなかった場合、\u0026quot;unknown file\u0026quot;になります。\nparse(FILE*, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; parse(FILE* fp, std::string filename, spec s = spec::default_version()); } FILE*が指すファイルを読み込んでパースします。\n標準ライブラリが改行文字を自動変換することによるファイルサイズと文字数との不整合を避けるため、 fopenには\u0026quot;rb\u0026quot;などを渡してバイナリモードで開いてください。\nファイルの読み込みに失敗した場合、errnoが含まれたfile_io_errorが送出されます。\nパースに失敗した場合、syntax_errorが送出されます。\nparse(std::vector\u0026lt;unsigned char\u0026gt;, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(std::vector\u0026lt;unsigned char\u0026gt; content, std::string filename, spec s = spec::default_version()); } バイト列をTOMLファイルとしてパースします。\nパースに失敗した場合、syntax_errorが送出されます。\nparse_str # parse_str(std::string, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse_str(std::string content, spec s = spec::default_version(), cxx::source_location loc = cxx::source_location::current()); } 文字列をTOMLファイルとしてパースします。\n失敗した場合はtoml::syntax_errorが送出されます。\nbasic_valueの持つ型情報はtemplateで、TOML言語のバージョンはtoml::specで指定します。\n第三引数のcxx::source_locationを手動で設定する必要は通常ありません。 std::source_location, std::experimental::source_location, __builtin_FILEのいずれかが利用可能な場合、 parse_strが呼ばれた地点の情報が位置情報として保存されます。\ntry_parse # 与えられたファイルの内容をパースし、成功した場合はtoml::basic_valueを、失敗した場合はstd::vector\u0026lt;toml::error_info\u0026gt;を返します。\nbasic_valueの持つ型情報はtemplateで、TOML言語のバージョンはtoml::specで指定します。\ntry_parseはparseと異なりsyntax_errorなどのtoml11で定義された例外は投げませんが、 標準ライブラリから送出される例外はそのまま送出されることに注意してください。\n例えば、std::ifstreamの内部で起きたエラーや、std::vectorでのメモリ枯渇などは例外を送出します。\ntry_parse(std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(std::string fname, spec s = spec::default_version()); } ファイル名を受け取って、その内容をパースします。\nパースに失敗した場合、エラー型であるstd::vector\u0026lt;error_info\u0026gt;を持つresultが返されます。\n成功した場合、basic_valueを持つresultが返されます。\ntry_parse(const char (\u0026amp;)[N] filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config, std::size_t N\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(const char (\u0026amp;fname)[N], spec s = spec::default_version()); } 文字列リテラルをファイル名として受け取って、その内容をパースします。\nパースに失敗した場合、エラー型であるstd::vector\u0026lt;error_info\u0026gt;を持つresultが返されます。\n成功した場合、basic_valueを持つresultが返されます。\ntry_parse(std::filesystem::path, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(const std::filesystem::path\u0026amp; fpath, spec s = spec::default_version()); } ファイルパスを受け取って、その内容をパースします。\nパースに失敗した場合、エラー型であるstd::vector\u0026lt;error_info\u0026gt;を持つresultが返されます。\n成功した場合、basic_valueを持つresultが返されます。\ntry_parse(std::istream\u0026amp;, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(std::istream\u0026amp; is, std::string fname = \u0026#34;unknown file\u0026#34;, spec s = spec::default_version()); } std::istream\u0026amp;を受け取ってその内容をパースします。\n標準ライブラリが改行文字を自動変換することによるファイルサイズと文字数との不整合を避けるため、 std::ios::binaryを使ってバイナリモードで開いてください。\nファイル名の情報は第二引数で受け取ります。ファイル名が渡されなかった場合、\u0026quot;unknown file\u0026quot;になります。\nパースに失敗した場合、エラー型であるstd::vector\u0026lt;error_info\u0026gt;を持つresultが返されます。\n成功した場合、basic_valueを持つresultが返されます。\ntry_parse(FILE*, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(FILE* fp, std::string filename, spec s = spec::default_version()); } FILE*を受け取って、そのファイルの内容をパースします。\n標準ライブラリが改行文字を自動変換することによるファイルサイズと文字数との不整合を避けるため、 fopenには\u0026quot;rb\u0026quot;などを渡してバイナリモードで開いてください。\nパースに失敗した場合、エラー型であるstd::vector\u0026lt;error_info\u0026gt;を持つresultが返されます。\n成功した場合、basic_valueを持つresultが返されます。\ntry_parse(std::vector\u0026lt;unsigned char\u0026gt;, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(std::vector\u0026lt;unsigned char\u0026gt; content, std::string filename, spec s = spec::default_version()); } バイト列を受け取って、その内容をTOMLファイルとしてパースします。\nパースに失敗した場合、エラー型であるstd::vector\u0026lt;error_info\u0026gt;を持つresultが返されます。\n成功した場合、basic_valueを持つresultが返されます。\ntry_parse_str # try_parse_str(std::string, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse_str(std::string content, spec s = spec::default_version(), cxx::source_location loc = cxx::source_location::current()); } 文字列をTOMLファイルとしてパースし、成功した場合はtoml::basic_valueを、失敗した場合はstd::vector\u0026lt;toml::error_info\u0026gt;を返します。\nparse_strと異なり、syntax_errorを送出せず、エラー情報をresultの失敗型として返します。\nstd::source_location, std::experimental::source_location, __builtin_FILEのどれかが利用可能な場合、それを位置情報に記録します。\n第三引数のcxx::source_locationを手動で設定する必要は通常ありません。 std::source_location, std::experimental::source_location, __builtin_FILEのいずれかが利用可能な場合、 parse_strが呼ばれた地点の情報が位置情報として保存されます。\ntry_parseはparseと異なりsyntax_errorなどのtoml11で定義された例外は投げませんが、 標準ライブラリから送出される例外はそのまま送出されることに注意してください。\n例えば、std::ifstreamの内部で起きたエラーや、std::vectorでのメモリ枯渇などは例外を送出します。\nsyntax_error # namespace toml { struct syntax_error final : public ::toml::exception { public: syntax_error(std::string what_arg, std::vector\u0026lt;error_info\u0026gt; err); ~syntax_error() noexcept override = default; const char* what() const noexcept override; std::vector\u0026lt;error_info\u0026gt; const\u0026amp; errors() const noexcept }; } TOML言語の文法エラーが発見された場合に送出される例外です。\nparseからは送出されますが、try_parseからは送出されません。\nfile_io_error # namespace toml { struct file_io_error final : public ::toml::exception { public: file_io_error(const std::string\u0026amp; msg, const std::string\u0026amp; fname); file_io_error(int errnum, const std::string\u0026amp; msg, const std::string\u0026amp; fname); ~file_io_error() noexcept override = default; const char* what() const noexcept override; bool has_errno() const noexcept; int get_errno() const noexcept; }; } ファイルの内容を読むのに失敗した場合に送出される例外です。\nFILE*を使ってファイルを読み込んだ場合はerrnoが設定されます。\nhas_errno # std::ifstreamが失敗した場合はerrnoは設定されません。\nこのとき、has_errnoはfalseになります。\nget_errno # 特にFILE*を渡していた場合に、errnoの値を取得します。\nhas_errnoがfalseの場合は0となります。\n関連項目 # error_info.hpp result.hpp spec.hpp value.hpp "},{"id":26,"href":"/toml11/ja/docs/reference/result/","title":"result.hpp","section":"reference","content":" result.hpp # result.hppは、成功値か失敗値かのどちらかを持つresult型を定義します。\nこれは、例外を投げないtoml::try_parseの返り値として使用されます。\nsuccess # 成功値を持つ型です。\nnamespace toml { template\u0026lt;typename T\u0026gt; struct success { using value_type = T; explicit success(value_type v); ~success() = default; success(const success\u0026amp;) = default; success(success\u0026amp;\u0026amp;) = default; success\u0026amp; operator=(const success\u0026amp;) = default; success\u0026amp; operator=(success\u0026amp;\u0026amp;) = default; template\u0026lt;typename U\u0026gt; explicit success(U\u0026amp;\u0026amp; v); template\u0026lt;typename U\u0026gt; explicit success(success\u0026lt;U\u0026gt; v); value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; }; template\u0026lt;typename T\u0026gt; success\u0026lt;typename std::decay\u0026lt;T\u0026gt;::type\u0026gt; ok(T\u0026amp;\u0026amp; v); template\u0026lt;std::size_t N\u0026gt; success\u0026lt;std::string\u0026gt; ok(const char (\u0026amp;literal)[N]) } メンバ型 # using value_type = T; 成功値の型です。\nメンバ関数 # コンストラクタ # explicit success(value_type v); value_typeを受け取って構築します。\ntemplate\u0026lt;typename U\u0026gt; explicit success(U\u0026amp;\u0026amp; v); value_typeに変換可能な他の型を受け取って構築します。\ntemplate\u0026lt;typename U\u0026gt; explicit success(success\u0026lt;U\u0026gt; v); value_typeに変換可能な他の型を持つsuccess型を受け取って構築します。\nget() # value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; 値にアクセスします。\n非メンバ関数 # ok(T) # template\u0026lt;typename T\u0026gt; success\u0026lt;typename std::decay\u0026lt;T\u0026gt;::type\u0026gt; ok(T\u0026amp;\u0026amp; v); template\u0026lt;std::size_t N\u0026gt; success\u0026lt;std::string\u0026gt; ok(const char (\u0026amp;literal)[N]) 成功値からsuccess型を構築して返します。\n文字列リテラルを与えた場合は、std::stringにして返します。\nsuccess\u0026lt;reference_wrapper\u0026lt;T\u0026gt;\u0026gt; # successの特殊化。成功値が参照であるときに使用されます。\nnamespace toml { template\u0026lt;typename T\u0026gt; struct success\u0026lt;std::reference_wrapper\u0026lt;T\u0026gt;\u0026gt; { using value_type = T; explicit success(std::reference_wrapper\u0026lt;value_type\u0026gt; v) noexcept; value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; }; } メンバ型 # using value_type = T; 成功値の型です。参照ではなく、std::reference_wrapper\u0026lt;T\u0026gt;のTです。\nget() # value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; 値にアクセスします。\nfailure # 失敗値を持つ型です。\nnamespace toml { template\u0026lt;typename T\u0026gt; struct failure { using value_type = T; explicit failure(value_type v); ~failure() = default; failure(const failure\u0026amp;) = default; failure(failure\u0026amp;\u0026amp;) = default; failure\u0026amp; operator=(const failure\u0026amp;) = default; failure\u0026amp; operator=(failure\u0026amp;\u0026amp;) = default; template\u0026lt;typename U\u0026gt; explicit failure(U\u0026amp;\u0026amp; v); template\u0026lt;typename U\u0026gt; explicit failure(failure\u0026lt;U\u0026gt; v); value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; }; template\u0026lt;typename T\u0026gt; failure\u0026lt;typename std::decay\u0026lt;T\u0026gt;::type\u0026gt; err(T\u0026amp;\u0026amp; v); template\u0026lt;std::size_t N\u0026gt; failure\u0026lt;std::string\u0026gt; err(const char (\u0026amp;literal)[N]); } メンバ型 # using value_type = T; 失敗値の型です。\nメンバ関数 # コンストラクタ # explicit failure(value_type v); value_typeを受け取って構築します。\ntemplate\u0026lt;typename U\u0026gt; explicit failure(U\u0026amp;\u0026amp; v); value_typeに変換可能な他の型を受け取って構築します。\ntemplate\u0026lt;typename U\u0026gt; explicit failure(failure\u0026lt;U\u0026gt; v); value_typeに変換可能な他の型を持つfailure型を受け取って構築します。\nget() # value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; 値にアクセスします。\n非メンバ関数 # err(T) # template\u0026lt;typename T\u0026gt; failure\u0026lt;typename std::decay\u0026lt;T\u0026gt;::type\u0026gt; err(T\u0026amp;\u0026amp; v); template\u0026lt;std::size_t N\u0026gt; failure\u0026lt;std::string\u0026gt; err(const char (\u0026amp;literal)[N]); 失敗値からfailure型を構築して返します。\n文字列リテラルを与えた場合は、std::stringにして返します。\nfailure\u0026lt;reference_wrapper\u0026lt;T\u0026gt;\u0026gt; # failureの特殊化。失敗値が参照であるときに使用されます。\nnamespace toml { template\u0026lt;typename T\u0026gt; struct failure\u0026lt;std::reference_wrapper\u0026lt;T\u0026gt;\u0026gt; { using value_type = T; explicit failure(std::reference_wrapper\u0026lt;value_type\u0026gt; v) noexcept; value_type\u0026amp; get() noexcept {return value.get();} value_type const\u0026amp; get() const noexcept {return value.get();} }; } メンバ型 # using value_type = T; 失敗値の型です。参照ではなく、std::reference_wrapper\u0026lt;T\u0026gt;のTです。\nget() # value_type\u0026amp; get() noexcept value_type const\u0026amp; get() const noexcept 値にアクセスします。\nresult # 成功値か失敗値かのどちらかを持つ型です。\nnamespace toml { template\u0026lt;typename T, typename E\u0026gt; struct result { using success_type = success\u0026lt;T\u0026gt;; using failure_type = failure\u0026lt;E\u0026gt;; using value_type = typename success_type::value_type; using error_type = typename failure_type::value_type; result(success_type s); result(failure_type f); template\u0026lt;typename U\u0026gt; result(success\u0026lt;U\u0026gt; s); template\u0026lt;typename U\u0026gt; result(failure\u0026lt;U\u0026gt; f); result\u0026amp; operator=(success_type s); result\u0026amp; operator=(failure_type f); template\u0026lt;typename U\u0026gt; result\u0026amp; operator=(success\u0026lt;U\u0026gt; s); template\u0026lt;typename U\u0026gt; result\u0026amp; operator=(failure\u0026lt;U\u0026gt; f); ~result() noexcept; result(const result\u0026amp; other); result(result\u0026amp;\u0026amp; other); result\u0026amp; operator=(const result\u0026amp; other); result\u0026amp; operator=(result\u0026amp;\u0026amp; other); template\u0026lt;typename U, typename F\u0026gt; result(result\u0026lt;U, F\u0026gt; other); template\u0026lt;typename U, typename F\u0026gt; result\u0026amp; operator=(result\u0026lt;U, F\u0026gt; other); bool is_ok() const noexcept; bool is_err() const noexcept; explicit operator bool() const noexcept; value_type\u0026amp; unwrap(cxx::source_location loc = cxx::source_location::current()); value_type const\u0026amp; unwrap(cxx::source_location loc = cxx::source_location::current()) const; value_type\u0026amp; unwrap_or(value_type\u0026amp; opt) noexcept; value_type const\u0026amp; unwrap_or(value_type const\u0026amp; opt) const noexcept; error_type\u0026amp; unwrap_err(cxx::source_location loc = cxx::source_location::current()); error_type const\u0026amp; unwrap_err(cxx::source_location loc = cxx::source_location::current()) const; value_type\u0026amp; as_ok() noexcept; value_type const\u0026amp; as_ok() const noexcept; error_type\u0026amp; as_err() noexcept; error_type const\u0026amp; as_err() const noexcept; }; } メンバ型 # success_type # success\u0026lt;T\u0026gt;です。\nfailure_type # failure\u0026lt;E\u0026gt;です。\nvalue_type # 成功型Tです。success_type::value_typeのエイリアスです。\n成功型Tとしてstd::reference_wrapper\u0026lt;U\u0026gt;が渡された場合、その引数型のUになります。\nerror_type # 失敗型Eです。failure_type::value_typeのエイリアスです。\n失敗型Eとしてstd::reference_wrapper\u0026lt;F\u0026gt;が渡された場合、その引数型のFになります。\nメンバ関数 # コンストラクタ # result() = delete; result型はデフォルトでは構築できません。 成功型か失敗型を与える必要があります。\nresult(success_type s); result(failure_type f); 成功型、失敗型を受け取って構築します。\ntemplate\u0026lt;typename U\u0026gt; result(success\u0026lt;U\u0026gt; s); template\u0026lt;typename U\u0026gt; result(failure\u0026lt;U\u0026gt; f); value_typeとerror_typeに変換可能な成功型、失敗型を受け取って構築します。\ntemplate\u0026lt;typename U, typename F\u0026gt; result(result\u0026lt;U, F\u0026gt; other); template\u0026lt;typename U, typename F\u0026gt; result\u0026amp; operator=(result\u0026lt;U, F\u0026gt; other); 変換可能な成功型、失敗型を持つresultから構築します。\nコピー・ムーブコンストラクタ # result(const result\u0026amp; other); result(result\u0026amp;\u0026amp; other); コピー・ムーブ構築可能です。\noperator= # result\u0026amp; operator=(const result\u0026amp; other); result\u0026amp; operator=(result\u0026amp;\u0026amp; other); コピー・ムーブ代入可能です。\ntemplate\u0026lt;typename U\u0026gt; result\u0026amp; operator=(success\u0026lt;U\u0026gt; s); template\u0026lt;typename U\u0026gt; result\u0026amp; operator=(failure\u0026lt;U\u0026gt; f); 変換可能な型を持つ成功型、失敗型は代入可能です。\nis_ok() # bool is_ok() const noexcept; 成功値を持っている場合trueを、そうでない場合falseを返します。\nis_err() # bool is_err() const noexcept; 失敗値を持っている場合trueを、そうでない場合falseを返します。\noperator bool() # explicit operator bool() const noexcept; 成功値を持っている場合trueを、そうでない場合falseを返します。\nunwrap() # value_type\u0026amp; unwrap(cxx::source_location loc = cxx::source_location::current()); value_type const\u0026amp; unwrap(cxx::source_location loc = cxx::source_location::current()) const; 成功値を取り出します。\n成功値を持っていない場合、toml::bad_result_accessが送出されます。\nstd::source_locationまたはstd::experimental::source_locationが利用可能か、 あるいはコンパイラ拡張によって同等の情報が利用可能な場合、what()文字列に unwrap()が発生したソースコードのファイル名と行数が表示されます。\n利用可能でない場合、位置情報は表示されません。\nunwrap_or() # value_type\u0026amp; unwrap_or(value_type\u0026amp; opt) noexcept; value_type const\u0026amp; unwrap_or(value_type const\u0026amp; opt) const noexcept; 成功値を持っていた場合それを、持っていなかった場合は引数で与えられた値を返します。\nunwrap_err() # error_type\u0026amp; unwrap_err(cxx::source_location loc = cxx::source_location::current()); error_type const\u0026amp; unwrap_err(cxx::source_location loc = cxx::source_location::current()) const; 失敗値を取り出します。\n失敗値を持っていない場合、toml::bad_result_accessが送出されます。\nstd::source_locationまたはstd::experimental::source_locationが利用可能か、 あるいはコンパイラ拡張によって同等の情報が利用可能な場合、what()文字列に unwrap()が発生したソースコードのファイル名と行数が表示されます。\n利用可能でない場合、位置情報は表示されません。\nas_ok() # value_type\u0026amp; as_ok() noexcept; value_type const\u0026amp; as_ok() const noexcept; チェックなしで成功値を返します。\n成功値を持っていなかった場合、その動作は未定義となります。\nas_err() # error_type\u0026amp; as_err() noexcept; error_type const\u0026amp; as_err() const noexcept; チェックなしで失敗値を返します。\n失敗値を持っていなかった場合、その動作は未定義となります。\nbad_result_access # resultのunwrapまたはunwrap_errで失敗した際に送出される例外です。\nnamespace toml { struct bad_result_access : public ::toml::exception { public: explicit bad_result_access(const std::string\u0026amp; what_arg); virtual ~bad_result_access() noexcept override = default; virtual const char* what() const noexcept override; protected: std::string what_; }; } "},{"id":27,"href":"/toml11/ja/docs/reference/serializer/","title":"serializer.hpp","section":"reference","content":" serializer.hpp # format # シリアライズを行います。\nnamespace toml { template\u0026lt;typename TC\u0026gt; std::string format(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const spec s = spec::default_version()); template\u0026lt;typename TC\u0026gt; std::string format(const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; k, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const spec s = spec::default_version()); template\u0026lt;typename TC\u0026gt; std::string format(const std::vector\u0026lt;typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026gt;\u0026amp; ks, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const spec s = spec::default_version()); } フォーマット情報とspecが矛盾する場合、例えばv1.0.0でtable_format::multiline_onelineが指定されているときなどは、specが優先されます。\nformat(v, spec) # toml::valueを、それが持つフォーマット情報とspecに従ってフォーマットします。\ntable_typeだった場合、それがルートであるとしてフォーマットします。 それ以外の値だった場合、値のみをフォーマットします。\nformat(k, v, spec) # toml::valueを、与えられたキーと同時にフォーマットします。\nvはそのキー以下に定義されていると解釈されます。\nformat([k,...], v, spec) # vはそのキー以下に定義されていると解釈されます。 キーが複数与えられた場合、再帰的に定義されたテーブルとして解釈されます。\nserialization_error # シリアライズ中に発生したエラーを報告します。\nnamespace toml { struct serialization_error final : public ::toml::exception { public: explicit serialization_error(std::string what_arg, source_location loc); ~serialization_error() noexcept override = default; const char* what() const noexcept override; source_location const\u0026amp; location() const noexcept; }; } "},{"id":28,"href":"/toml11/ja/docs/reference/source_location/","title":"source_location.hpp","section":"reference","content":" source_location.hpp # source_location.hppでは、TOMLファイル内のある領域を指すクラスが定義されます。\nこのクラスは、エラーメッセージで問題の箇所を指摘するために使われます。\ntoml::source_location # source_locationは、TOMLファイル内のある領域を指すクラスです。\nnamespace toml { struct source_location { public: explicit source_location(/* implementation-defined */); ~source_location() = default; source_location(source_location const\u0026amp;) = default; source_location(source_location \u0026amp;\u0026amp;) = default; source_location\u0026amp; operator=(source_location const\u0026amp;) = default; source_location\u0026amp; operator=(source_location \u0026amp;\u0026amp;) = default; bool is_ok() const noexcept; std::size_t length() const noexcept; std::size_t first_line_number() const noexcept; std::size_t first_column_number() const noexcept; std::size_t last_line_number() const noexcept; std::size_t last_column_number() const noexcept; std::string const\u0026amp; file_name() const noexcept; std::size_t num_lines() const noexcept; std::string const\u0026amp; first_line() const; std::string const\u0026amp; last_line() const; std::vector\u0026lt;std::string\u0026gt; const\u0026amp; lines() const noexcept; }; template\u0026lt;typename ... Ts\u0026gt; std::string format_location(const source_location\u0026amp; loc, const std::string\u0026amp; msg, const Ts\u0026amp; ... locs_and_msgs); } //toml メンバ関数 # コンストラクタ # explicit source_location(/* implementation-defined */); toml::source_locationをtoml::parseまたは_tomlリテラル以外で構築することはできません。\nis_ok() # bool is_ok() const noexcept; source_locationが有効な値を保持している場合、trueを、そうでない場合falseを返します。\ntoml::parseや_tomlリテラル以外から構築したtoml::valueのlocation()の結果は、指す対象がないため、is_okはfalseを返します。\nlength() # std::size_t length() const noexcept; source_locationが指す領域の長さを返します。\n有効な値を保持していない場合、0を返します。\nfirst_line_number() # std::size_t first_line_number() const noexcept; source_locationが指す領域の最初の行の行番号を返します。\n有効な値を保持していない場合、1を返します。\nfirst_column_number() # std::size_t first_column_number() const noexcept; source_locationが指す領域の最初の列の列番号を返します。\n有効な値を保持していない場合、1を返します。\nlast_line_number() # std::size_t last_line_number() const noexcept; source_locationが指す領域の最後の行の行番号を返します。\n有効な値を保持していない場合、1を返します。\nlast_column_number() # std::size_t last_column_number() const noexcept; source_locationが指す領域の最後の列の列番号を返します。\n有効な値を保持していない場合、1を返します。\nfile_name() # std::string const\u0026amp; file_name() const noexcept; source_locationが指す領域を含むファイルのファイル名を返します。\n有効な値を保持していない場合、\u0026quot;unknown file\u0026quot;を返します。\nnum_lines() # std::size_t num_lines() const noexcept; source_locationが指す領域の行数を返します。\n有効な値を保持していない場合、0を返します。\nfirst_line() # std::string const\u0026amp; first_line() const; source_locationが指す領域の最初の行を返します。\n有効な値を保持していない場合、std::out_of_range例外が送出されます。\nlast_line() # std::string const\u0026amp; last_line() const; source_locationが指す領域の最後の行を返します。\n有効な値を保持していない場合、std::out_of_range例外が送出されます。\nlines() # std::vector\u0026lt;std::string\u0026gt; const\u0026amp; lines() const noexcept; source_locationが指す領域の全ての行を返します。\n有効な値を保持していない場合、空のstd::vectorへの参照を返します。\n非メンバ関数 # format_location # template\u0026lt;typename ... Ts\u0026gt; std::string format_location(const source_location\u0026amp; loc, const std::string\u0026amp; msg, const Ts\u0026amp; ... locs_and_msgs); source_locationが指す箇所と、それについてのメッセージを以下のようにフォーマットします。\n-\u0026gt; {filename.toml} | 1 | a = 42 | ^-- {message} この時、色付けがONになっている場合、ANSIエスケープシーケンスによって色情報が追加されます。\nlocs_and_msgsが複数個ある場合、それらはconst source_location\u0026amp;とconst std::string\u0026amp;の順である必要があります。\n例：複数のsource_locationとstd::string # 複数のsource_locationとstd::stringを渡した場合、以下のようにフォーマットされます。\nsource_location\u0026amp; loc0; source_location\u0026amp; loc1; source_location\u0026amp; loc2; std::string msg0; std::string msg1; std::string msg2; format_location(loc0, msg0, loc1, msg1, loc2, msg2); -\u0026gt; {filename0.toml} | 1 | a = 42 | ^-- {message0} | -\u0026gt; {filename1.toml} | 2 | b = 3.14 | ^-- {message1} | -\u0026gt; {filename2.toml} | 3 | c = \u0026#34;foo\u0026#34; | ^-- {message2} 関連項目 # error_info.hpp value.hpp "},{"id":29,"href":"/toml11/ja/docs/reference/spec/","title":"spec.hpp","section":"reference","content":" spec.hpp # spec.hppでは、TOMLのバージョンを指定するためのクラスが定義されます。\ntoml::semantic_version # semantic_versionは、バージョン情報を格納するクラスです。\nnamespace toml { struct semantic_version { constexpr semantic_version(std::uint32_t mjr, std::uint32_t mnr, std::uint32_t p) noexcept; std::uint32_t major; std::uint32_t minor; std::uint32_t patch; }; constexpr semantic_version make_semver(std::uint32_t major, std::uint32_t minor, std::uint32_t patch) noexcept; constexpr bool operator==(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator!=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026lt; (const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026lt;=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026gt; (const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026gt;=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const semantic_version\u0026amp; ver); } //toml メンバ関数 # コンストラクタ # constexpr semantic_version(std::uint32_t mjr, std::uint32_t mnr, std::uint32_t p) noexcept; major, minor, patchバージョンを指定して構築します。\n非メンバ関数 # 比較演算子 # constexpr bool operator==(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator!=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026lt; (const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026lt;=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026gt; (const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026gt;=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; semantic versioningに従って比較します。\nストリーム演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const semantic_version\u0026amp; ver); {major}.{minor}.{patch}の形式で出力します。\nto_string # std::string to_string(const semantic_version\u0026amp; ver); {major}.{minor}.{patch}の形式で文字列化します。\ntoml::spec # specは、TOMLのバージョン情報を格納するクラスです。\nstruct spec { constexpr static spec default_version() noexcept; constexpr static spec v(std::uint32_t mjr, std::uint32_t mnr, std::uint32_t p) noexcept; constexpr explicit spec(const semantic_version\u0026amp; semver) noexcept; semantic_version version; // toml version // diff from v1.0.0 -\u0026gt; v1.1.0 bool v1_1_0_allow_control_characters_in_comments; bool v1_1_0_allow_newlines_in_inline_tables; bool v1_1_0_allow_trailing_comma_in_inline_tables; bool v1_1_0_allow_non_english_in_bare_keys; bool v1_1_0_add_escape_sequence_e; bool v1_1_0_add_escape_sequence_x; bool v1_1_0_make_seconds_optional; // library extensions bool ext_hex_float; // allow hex float bool ext_num_suffix; // allow number suffix bool ext_null_value; // allow null value }; メンバ関数 # コンストラクタ # constexpr explicit spec(const semantic_version\u0026amp; semver) noexcept; 指定されたTOMLバージョンでspecを構築します。\nTOML v1.0.0と、TOML v1.1.0に対応しています。\ndefault_version() # constexpr static spec default_version() noexcept; デフォルトのバージョンでspecを構築します。\ntoml::parse、toml::formatでのデフォルト値として使われます。\ntoml11 v4.4.0での値は、v1.0.0です。\nv(major, minor, patch) # constexpr static spec v(std::uint32_t mjr, std::uint32_t mnr, std::uint32_t p) noexcept; 指定されたバージョンでspecを構築します。\nメンバ変数 # 各フラグは機能追加がされたバージョンを指定されたとき、自動的にtrueになります。\n変更して渡すことで、toml::parse、toml::formatの挙動を変更できます。\nTOML v1.1.0の一部の機能にはかなり長い議論が続いており、まだ差し戻される可能性があります。\n実際に差し戻された場合、toml11はマイナーバージョンアップでそれらの機能を削除、もしくは対応するそれ以降のバージョンに移動します。\nそのような意味で、将来のバージョンに関する機能は全て不安定なものと考えてください。\n例 # auto spec = toml::spec::v(1, 0, 0); // v1.0.0の機能に追加して、inline table内の改行を許可する。 // それ以外のv1.1.0の機能は有効化されない。 spec.v1_1_0_allow_newlines_in_inline_tables = true; auto input = toml::parse(\u0026#34;input_file.toml\u0026#34;, spec); v1_1_0_allow_control_characters_in_comments # bool v1_1_0_allow_control_characters_in_comments; ほとんどの制御文字をコメントに含むことを許可します。\ntoml v1.1.0で追加。\nv1_1_0_allow_newlines_in_inline_tables # bool v1_1_0_allow_newlines_in_inline_tables; inline table内で改行することを許可します。\ntoml v1.1.0で追加。\nv1_1_0_allow_trailing_comma_in_inline_tables # bool v1_1_0_allow_trailing_comma_in_inline_tables; inline table内での末尾コンマを許可します。\ntoml v1.1.0で追加。\nv1_1_0_add_escape_sequence_e # bool v1_1_0_add_escape_sequence_e; \\eでESC文字を指定できるようになります。\ntoml v1.1.0で追加。\nv1_1_0_add_escape_sequence_x # bool v1_1_0_add_escape_sequence_x; \\xHHで1バイトの文字を指定できるようになります。\ntoml v1.1.0で追加。\nv1_1_0_make_seconds_optional # bool v1_1_0_make_seconds_optional; 時刻での秒数指定を省略可能にします。\n指定されなかった秒数は0で初期化されます。\ntoml v1.1.0で追加。\next_hex_float # bool ext_hex_float; toml11限定の言語拡張です。\nどのバージョンを指定しても、falseで初期化されます。 使用する際は個別にtrueにしてください。\n浮動小数点数の16進数表記を許可します。\n16進数表記はprintfで%a/%Aを指定した場合に準拠します。\nhexf = 0xC0FFEEp-10 toml::format は、渡された toml::spec で ext_hex_format が true の場合のみ 16進表記でフォーマットします。 フォーマット情報で hex が指定されているにも関わらず toml::format に渡された toml::spec の ext_hex_float が false だった場合、16進数指定は無視され、 10進表記で最大の精度で出力されます。\next_num_suffix # bool ext_num_suffix; toml11限定の言語拡張です。\nどのバージョンを指定しても、falseで初期化されます。 使用する際は個別にtrueにしてください。\n10進数の整数と浮動小数点数に接尾辞を追加します。型を問わず、16進や8進、2進表記には適用されません。\n数値と接尾辞の間は_で区切られている必要があります。\n数値部分との区別のため、接尾辞は数値で始まることはできません。\ndistance = 10_m # valid distance = 10_2m # invalid distance = 10_2_m # valid 接尾辞は std::string suffix としてフォーマット情報に保持されます。 数値部分とを分ける _ は suffix に含まれません。\ntoml::value distance = toml::find(input, \u0026#34;distance\u0026#34;); assert(distance.as_integer_fmt().suffix == std::string(\u0026#34;m\u0026#34;)); toml::format は、渡された toml::spec の ext_num_suffix が true の場合のみ これをフォーマットします。\nsuffixは以下のような文法を持ちます。\nnon-digit-graph = ALPHA / non-ascii graph = ALPHA / DIGIT / non-ascii suffix = _ non-digit-graph *( graph / ( _ graph ) ) ext_null_value # bool ext_null_value; toml11限定の言語拡張です。\n値として null を許可します。\nnull を指定された toml::value は値を持たず、 is_empty() が true になります。\ntoml::format は、渡された toml::spec で ext_null_value が true の場合のみ null としてフォーマットします。 そうでない場合、 toml::format がエラーで終了します。\n"},{"id":30,"href":"/toml11/ja/docs/reference/toml_fwd/","title":"toml_fwd.hpp","section":"reference","content":" toml_fwd.hpp # toml_fwd.hppは、toml11で定義される構造体の前方宣言と、マクロ定義を持ちます。\ntoml11の構造体についての前方宣言しか必要なく実装が必要ない場合、 toml.hpp のかわりにこちらを include することでコンパイル時間を短縮できます。\nこのファイルには前方宣言しか含まれていないため、 toml::basic_value\u0026lt;toml::type_config\u0026gt;::table_type として定義される toml::table と、同様に定義される toml::array は使用できません。 それらには basic_value の実装が必要だからです。 このヘッダファイルと toml.hpp は ${TOML11_INCLUDE_DIR}/ 以下に、 他のヘッダファイルは ${TOML11_INCLUDE_DIR}/toml11/ 以下にあります。\n"},{"id":31,"href":"/toml11/ja/docs/reference/toml/","title":"toml.hpp","section":"reference","content":" toml.hpp # toml.hppは、他の全てのヘッダを include します。\nこれによって、toml11の全機能が使用可能になります。\nこのヘッダファイルと toml_fwd.hpp は ${TOML11_INCLUDE_DIR}/ 以下に、 他のヘッダファイルは ${toml11_include_dir}/toml11/ 以下にあります。\n"},{"id":32,"href":"/toml11/ja/docs/reference/types/","title":"types.hpp","section":"reference","content":" types.hpp # 型情報を与えるクラスが定義されます。\ntype_config # type_configは、toml::basic_valueに与えられるパラメータをまとめた型です。\ntoml::basic_value\u0026lt;T\u0026gt;内で異なる型を使用する場合、これを別に定義して渡します。 記載のある要素は全て必須の要素です。\n通常のストリーム演算子を使用できない数値型を使用する場合、read_int、read_floatに相当するものを定義し、置き換えてください。\nnamespace toml { struct type_config { using comment_type = preserve_comments; using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = std::unordered_map\u0026lt;K, T\u0026gt;; static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base); static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex); }; using value = basic_value\u0026lt;type_config\u0026gt;; using table = typename value::table_type; using array = typename value::array_type; } // toml static メンバ関数 # parse_int(str, src, base) # static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base); 通常のストリーム演算子などを使用できない型をinteger_typeとして使用する場合、この関数を実装してください。\nstrには、prefix、（0xなどの場合）leading zero、underscoreが取り除かれた文字列が渡されます。\nsrcには、その文字列が定義されていた箇所を指すsource_locationが渡されます。\nbaseには、10, 2, 8, 16のいずれかが渡されます。\nparse_float(str, src, is_hex) # static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex); 通常のストリーム演算子などを使用できない型をfloating_typeとして使用する場合、この関数を実装してください。\nstrには、prefix、leading zero、underscoreが取り除かれた文字列が渡されます。\nsrcには、その文字列が定義されていた箇所を指すsource_locationが渡されます。\nis_hexには、フォーマットがhexfloatであるかどうかが渡されます。hexfloat拡張を使用しない場合は使われないので、実装する必要はありません。\nhexfloat拡張に関しては、spec.hppを参照してください。\n非メンバ関数 # read_int # template\u0026lt;typename T\u0026gt; result\u0026lt;T, error_info\u0026gt; read_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base); デフォルトで使用される関数です。std::istringstreamを使用してパースします。\noperator\u0026gt;\u0026gt;とstd::hex等のマニピュレータ、std::numeric_limits\u0026lt;T\u0026gt;が定義されている場合（boost::multiprecisionなど）、特に変更なしにこれを使用できます。\nread_float # template\u0026lt;typename T\u0026gt; result\u0026lt;T, error_info\u0026gt; read_float(const std::string\u0026amp; str, const source_location src, const bool is_hex); デフォルトで使用される関数です。decimalの場合はstd::istringstreamを、hexfloatの場合はsscanf()を使用してパースします。\ndouble、floatに対応しています。\nそれ以外の型の場合、operator\u0026gt;\u0026gt;が定義されていて、かつhexを使用しないなら、これを使用できます。\nordered_type_config # ordered_type_configは、toml::type_configのテーブル型をtoml::ordered_mapに変更したものです。 また、toml::ordered_valueエイリアスを定義します。\nそのほかにtype_configとの違いはありません。\nnamespace toml { struct ordered_type_config { using comment_type = preserve_comments; using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = ordered_map\u0026lt;K, T\u0026gt;; static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base) { return read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex) { return read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } }; using ordered_value = basic_value\u0026lt;ordered_type_config\u0026gt;; using ordered_table = typename ordered_value::table_type; using ordered_array = typename ordered_value::array_type; } // toml "},{"id":33,"href":"/toml11/ja/docs/reference/value_t/","title":"value_t.hpp","section":"reference","content":" value_t.hpp # 型情報を表す列挙型です。\nvalue_t # value_tは、toml::valueが持つ型情報を扱う際に使用します。\nnamespace toml { enum class value_t : std::uint8_t { empty = 0, boolean = 1, integer = 2, floating = 3, string = 4, offset_datetime = 5, local_datetime = 6, local_date = 7, local_time = 8, array = 9, table = 10 }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, value_t t); std::string to_string(value_t t); } // toml 非メンバ関数 # ストリーム演算子 # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, value_t t); value_tの値を文字列化してストリームへ出力します。\nto_string # std::string to_string(value_t t); value_tの値を文字列化して返します。\n"},{"id":34,"href":"/toml11/ja/docs/reference/value/","title":"value.hpp","section":"reference","content":" value.hpp # value.hppでは、basic_valueが定義されます。\ntoml::basic_value # basic_valueは、TOMLの値を格納するクラスです。\nnamespace toml { template \u0026lt;class TypeConfig\u0026gt; class basic_value; // 以下はtypes.hppで定義される // using value = basic_value\u0026lt;type_config\u0026gt;; // using table = typename basic_value\u0026lt;type_config\u0026gt;::table_type; // using array = typename basic_value\u0026lt;type_config\u0026gt;::array_type; template\u0026lt;typename TC\u0026gt; bool operator==(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator!=(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator\u0026lt; (const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator\u0026lt;=(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator\u0026gt; (const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator\u0026gt;=(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); } //toml メンバ型 # 以下のメンバ型が定義されます。\nTypeConfigを使って、メンバ型を変更することができます。\n参考： types.hpp\n名前 定義 char_type typename TypeConfig::char_type key_type typename TypeConfig::string_type value_type basic_value\u0026lt;TypeConfig\u0026gt; boolean_type typename TypeConfig::boolean_type integer_type typename TypeConfig::integer_type floating_type typename TypeConfig::floating_type string_type typename TypeConfig::string_type local_time_type toml::local_time local_date_type toml::local_date local_datetime_type toml::local_datetime offset_datetime_type toml::offset_datetime array_type typename TypeConfig::template array_type\u0026lt;value_type\u0026gt; table_type typename TypeConfig::template table_type\u0026lt;key_type, value_type\u0026gt; comment_type typename TypeConfig::comment_type メンバ関数 # デフォルトコンストラクタ # basic_value() noexcept 空のtoml::valueを構築します。\n構築されたtoml::valueは空になります。\nコピー・ムーブコンストラクタ # basic_value(const basic_value\u0026amp; v) basic_value(basic_value\u0026amp;\u0026amp; v) 値、フォーマット情報、コメント、ファイル領域の全ての情報をコピー・ムーブします。\nコピー・ムーブコンストラクタ（コメント指定） # basic_value(basic_value v, std::vector\u0026lt;std::string\u0026gt; com) コメントを上書きしながらコピー・ムーブします。\n変換コンストラクタ # template\u0026lt;typename TI\u0026gt; basic_value(basic_value\u0026lt;TI\u0026gt; other) template\u0026lt;typename TI\u0026gt; basic_value(basic_value\u0026lt;TI\u0026gt; other, std::vector\u0026lt;std::string\u0026gt; com) 異なるtype_configを持つbasic_valueからコピー・ムーブします。\nコンストラクタ (boolean) # basic_value(boolean_type x) basic_value(boolean_type x, boolean_format_info fmt) basic_value(boolean_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(boolean_type x, boolean_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) boolと、そのフォーマット情報、コメントを受け取って構築します。\nコンストラクタ (integer) # basic_value(integer_type x) basic_value(integer_type x, integer_format_info fmt) basic_value(integer_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(integer_type x, integer_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) integerと、そのフォーマット情報、コメントを受け取って構築します。\nコンストラクタ(floating) # template\u0026lt;typename T, /* T は std::is_floating_point\u0026lt;T\u0026gt; を満たす */\u0026gt; basic_value(T x) template\u0026lt;typename T, /* T は std::is_floating_point\u0026lt;T\u0026gt; を満たす */\u0026gt; basic_value(T x, floating_format_info fmt) template\u0026lt;typename T, /* T は std::is_floating_point\u0026lt;T\u0026gt; を満たす */\u0026gt; basic_value(T x, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* T は std::is_floating_point\u0026lt;T\u0026gt; を満たす */\u0026gt; basic_value(T x, floating_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) floatingと、そのフォーマット情報、コメントを受け取って構築します。\nコンストラクタ(string) # basic_value(string_type x) basic_value(string_type x, string_format_info fmt) basic_value(string_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(string_type x, string_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) basic_value(const string_type::value_type* x) basic_value(const string_type::value_type* x, string_format_info fmt) basic_value(const string_type::value_type* x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(const string_type::value_type* x, string_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) // C++17以降 basic_value(string_view_type x) basic_value(string_view_type x, string_format_info fmt) basic_value(string_view_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(string_view_type x, string_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) stringと、そのフォーマット情報、コメントを受け取って構築します。\nstring_view_typeは、string_typeと同じvalue_typeとtraits_typeを持ちます。\nコンストラクタ(local_date) # basic_value(local_date_type x) basic_value(local_date_type x, local_date_format_info fmt) basic_value(local_date_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(local_date_type x, local_date_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) local_date_typeと、そのフォーマット情報、コメントを受け取って構築します。\nコンストラクタ(local_time) # basic_value(local_time_type x) basic_value(local_time_type x, local_time_format_info fmt) basic_value(local_time_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(local_time_type x, local_time_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename Rep, typename Period\u0026gt; basic_value(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; x) template\u0026lt;typename Rep, typename Period\u0026gt; basic_value(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; x, local_time_format_info fmt) template\u0026lt;typename Rep, typename Period\u0026gt; basic_value(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; x, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename Rep, typename Period\u0026gt; basic_value(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; x, local_time_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) local_time_typeと、そのフォーマット情報、コメントを受け取って構築します。\nstd::chrono::durationは、00:00:00からの時間幅として構築します。\nコンストラクタ(local_datetime) # basic_value(local_datetime_type x) basic_value(local_datetime_type x, local_date_format_info fmt) basic_value(local_datetime_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(local_datetime_type x, local_date_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) local_datetime_typeと、そのフォーマット情報、コメントを受け取って構築します。\nコンストラクタ(offset_datetime) # basic_value(offset_datetime_type x) basic_value(offset_datetime_type x, offset_date_format_info fmt) basic_value(offset_datetime_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(offset_datetime_type x, offset_date_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) basic_value(std::chrono::system_clock::time_point x) basic_value(std::chrono::system_clock::time_point x, offset_date_format_info fmt) basic_value(std::chrono::system_clock::time_point x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(std::chrono::system_clock::time_point x, offset_date_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) offset_datetime_typeと、そのフォーマット情報、コメントを受け取って構築します。\nstd::chrono::system_clock::time_pointの場合、それが指す時点として構築します。\nコンストラクタ(array) # basic_value(array_type x) basic_value(array_type x, integer_format_info fmt) basic_value(array_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(array_type x, integer_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* T is array-like */\u0026gt; basic_value(T x) template\u0026lt;typename T, /* T is array-like */\u0026gt; basic_value(T x, array_format_info fmt) template\u0026lt;typename T, /* T is array-like */\u0026gt; basic_value(T x, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* T is array-like */\u0026gt; basic_value(T x, array_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) arrayと、そのフォーマット情報、コメントを受け取って構築します。\narray-likeは、以下の条件を満たす型です。\nT::iterator を持つ。 T::value_type を持つ。 T::key_type を持たない。 T::mapped_type を持たない。 std::string ではない。 std::string_view ではない。(C++17以降) コンストラクタ(table) # basic_value(table_type x) basic_value(table_type x, integer_format_info fmt) basic_value(table_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(table_type x, integer_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* T is table-like */\u0026gt; basic_value(T x) template\u0026lt;typename T, /* T is table-like */\u0026gt; basic_value(T x, table_format_info fmt) template\u0026lt;typename T, /* T is table-like */\u0026gt; basic_value(T x, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* T is table-like */\u0026gt; basic_value(T x, table_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) tableと、そのフォーマット情報、コメントを受け取って構築します。\ntable-likeは、以下の条件を満たす型です。\nT::iterator を持つ。 T::value_type を持つ。 T::key_type を持つ。 T::mapped_type を持つ。 コンストラクタ(user-defined) # template\u0026lt;typename T /* toml::into\u0026lt;T\u0026gt;が定義されていること */\u0026gt; basic_value(const T\u0026amp; ud); template\u0026lt;typename T /* toml::into\u0026lt;T\u0026gt;が定義されていること */\u0026gt; basic_value(const T\u0026amp; ud, std::vector\u0026lt;std::string\u0026gt; com); template\u0026lt;typename T /* into\u0026lt;T\u0026gt;は定義されておらず、T{}.into_toml()が存在すること */\u0026gt; basic_value(const T\u0026amp; ud); template\u0026lt;typename T /* into\u0026lt;T\u0026gt;は定義されておらず、T{}.into_toml()が存在すること */\u0026gt; basic_value(const T\u0026amp; ud, std::vector\u0026lt;std::string\u0026gt; com); toml::into\u0026lt;T\u0026gt; が定義されていた場合、 toml::into\u0026lt;T\u0026gt;(ud) の結果から構築します。\ntoml::into\u0026lt;T\u0026gt; が定義されておらず、 T に into_toml() メンバ関数が定義されていた場合、 ud.into_toml()の結果から構築します。\noperator=(basic_value) # basic_value\u0026amp; operator=(const basic_value\u0026amp; v) basic_value\u0026amp; operator=(basic_value\u0026amp;\u0026amp; v) template\u0026lt;typename TI\u0026gt; basic_value\u0026amp; operator=(basic_value\u0026lt;TI\u0026gt; other) 右辺のbasic_valueを代入します。\noperator=(T) # template\u0026lt;typename T\u0026gt; basic_value\u0026amp; operator=(T x) Tに対応する値を代入します。\nsource_locationの指す内容は破棄されます。\nもし同じ型の値を持っていたなら、元のフォーマット情報が保持されます。\nis\u0026lt;T\u0026gt;() # bool is\u0026lt;T\u0026gt;() const noexcept 条件 # Tは厳密にTOML型であること。つまり、値に対応するtoml::value::xxx_typeのいずれかであること。\n戻り値 # 格納している型がTと一致した場合trueを、そうでない場合はfalseを返します。\nis(toml::value_t) # bool is(toml::value_t t) const noexcept 戻り値 # 格納している型のタグがtと一致した場合trueを、そうでない場合はfalseを返します。\nis_xxx() # bool is_boolean() const noexcept; bool is_integer() const noexcept; bool is_floating() const noexcept; bool is_string() const noexcept; bool is_offset_datetime() const noexcept; bool is_local_datetime() const noexcept; bool is_local_date() const noexcept; bool is_local_time() const noexcept; bool is_array() const noexcept; bool is_table() const noexcept; 戻り値 # 格納している型がその型である場合trueを、そうでない場合はfalseを返します。\nis_empty() # bool is_empty() const noexcept; 戻り値 # デフォルト構築され値が代入されていない場合trueを、そうでない場合はfalseを返します。\nis_array_of_tables() # bool is_array_of_tables() const noexcept; 戻り値 # 格納している型が配列であり、空ではなく、全要素がテーブルの場合はtrueを、そうでない場合はfalseを返します。\ntype() # toml::value_t type() const noexcept 戻り値 # 格納している型に対応するタグを返します。\nas_xxx() # boolean_type const\u0026amp; as_boolean () const; integer_type const\u0026amp; as_integer () const; floating_type const\u0026amp; as_floating () const; string_type const\u0026amp; as_string () const; offset_datetime_type const\u0026amp; as_offset_datetime() const; local_datetime_type const\u0026amp; as_local_datetime () const; local_date_type const\u0026amp; as_local_date () const; local_time_type const\u0026amp; as_local_time () const; array_type const\u0026amp; as_array () const; table_type const\u0026amp; as_table () const; boolean_type \u0026amp; as_boolean (); integer_type \u0026amp; as_integer (); floating_type \u0026amp; as_floating (); string_type \u0026amp; as_string (); offset_datetime_type\u0026amp; as_offset_datetime(); local_datetime_type \u0026amp; as_local_datetime (); local_date_type \u0026amp; as_local_date (); local_time_type \u0026amp; as_local_time (); array_type \u0026amp; as_array (); table_type \u0026amp; as_table (); 戻り値 # 指定された型への参照を返します。\n例外 # 格納されている値の型が指定と異なる場合、toml::type_errorを送出します。\nas_xxx(std::nothrow) # std::nothrowオブジェクトを渡して呼び出します。\nboolean_type const\u0026amp; as_boolean (const std::nothrow_t\u0026amp;) const noexcept; integer_type const\u0026amp; as_integer (const std::nothrow_t\u0026amp;) const noexcept; floating_type const\u0026amp; as_floating (const std::nothrow_t\u0026amp;) const noexcept; string_type const\u0026amp; as_string (const std::nothrow_t\u0026amp;) const noexcept; offset_datetime_type const\u0026amp; as_offset_datetime(const std::nothrow_t\u0026amp;) const noexcept; local_datetime_type const\u0026amp; as_local_datetime (const std::nothrow_t\u0026amp;) const noexcept; local_date_type const\u0026amp; as_local_date (const std::nothrow_t\u0026amp;) const noexcept; local_time_type const\u0026amp; as_local_time (const std::nothrow_t\u0026amp;) const noexcept; array_type const\u0026amp; as_array (const std::nothrow_t\u0026amp;) const noexcept; table_type const\u0026amp; as_table (const std::nothrow_t\u0026amp;) const noexcept; boolean_type \u0026amp; as_boolean (const std::nothrow_t\u0026amp;) noexcept; integer_type \u0026amp; as_integer (const std::nothrow_t\u0026amp;) noexcept; floating_type \u0026amp; as_floating (const std::nothrow_t\u0026amp;) noexcept; string_type \u0026amp; as_string (const std::nothrow_t\u0026amp;) noexcept; offset_datetime_type\u0026amp; as_offset_datetime(const std::nothrow_t\u0026amp;) noexcept; local_datetime_type \u0026amp; as_local_datetime (const std::nothrow_t\u0026amp;) noexcept; local_date_type \u0026amp; as_local_date (const std::nothrow_t\u0026amp;) noexcept; local_time_type \u0026amp; as_local_time (const std::nothrow_t\u0026amp;) noexcept; array_type \u0026amp; as_array (const std::nothrow_t\u0026amp;) noexcept; table_type \u0026amp; as_table (const std::nothrow_t\u0026amp;) noexcept; 戻り値 # 指定された型への参照を返します。\n備考 # 格納されている値の型が指定と異なる場合、未定義動作となります。\nas_xxx_fmt() # フォーマット情報にアクセスします。\nboolean_format_info \u0026amp; as_boolean_fmt (); integer_format_info \u0026amp; as_integer_fmt (); floating_format_info \u0026amp; as_floating_fmt (); string_format_info \u0026amp; as_string_fmt (); offset_datetime_format_info\u0026amp; as_offset_datetime_fmt(); local_datetime_format_info \u0026amp; as_local_datetime_fmt (); local_date_format_info \u0026amp; as_local_date_fmt (); local_time_format_info \u0026amp; as_local_time_fmt (); array_format_info \u0026amp; as_array_fmt (); table_format_info \u0026amp; as_table_fmt (); boolean_format_info const\u0026amp; as_boolean_fmt () const; integer_format_info const\u0026amp; as_integer_fmt () const; floating_format_info const\u0026amp; as_floating_fmt () const; string_format_info const\u0026amp; as_string_fmt () const; offset_datetime_format_info const\u0026amp; as_offset_datetime_fmt() const; local_datetime_format_info const\u0026amp; as_local_datetime_fmt () const; local_date_format_info const\u0026amp; as_local_date_fmt () const; local_time_format_info const\u0026amp; as_local_time_fmt () const; array_format_info const\u0026amp; as_array_fmt () const; table_format_info const\u0026amp; as_table_fmt () const; 戻り値 # 指定された型のフォーマット情報を持つ構造体への参照を返します。\n例外 # 格納されている値の型が指定と異なる場合、toml::type_errorを送出します。\nas_xxx_fmt(std::nothrow) # std::nothrowオブジェクトを渡して呼び出します。\nboolean_format_info \u0026amp; as_boolean_fmt (const std::nothrow_t\u0026amp;) noexcept; integer_format_info \u0026amp; as_integer_fmt (const std::nothrow_t\u0026amp;) noexcept; floating_format_info \u0026amp; as_floating_fmt (const std::nothrow_t\u0026amp;) noexcept; string_format_info \u0026amp; as_string_fmt (const std::nothrow_t\u0026amp;) noexcept; offset_datetime_format_info\u0026amp; as_offset_datetime_fmt(const std::nothrow_t\u0026amp;) noexcept; local_datetime_format_info \u0026amp; as_local_datetime_fmt (const std::nothrow_t\u0026amp;) noexcept; local_date_format_info \u0026amp; as_local_date_fmt (const std::nothrow_t\u0026amp;) noexcept; local_time_format_info \u0026amp; as_local_time_fmt (const std::nothrow_t\u0026amp;) noexcept; array_format_info \u0026amp; as_array_fmt (const std::nothrow_t\u0026amp;) noexcept; table_format_info \u0026amp; as_table_fmt (const std::nothrow_t\u0026amp;) noexcept; boolean_format_info const\u0026amp; as_boolean_fmt (const std::nothrow_t\u0026amp;) const noexcept; integer_format_info const\u0026amp; as_integer_fmt (const std::nothrow_t\u0026amp;) const noexcept; floating_format_info const\u0026amp; as_floating_fmt (const std::nothrow_t\u0026amp;) const noexcept; string_format_info const\u0026amp; as_string_fmt (const std::nothrow_t\u0026amp;) const noexcept; offset_datetime_format_info const\u0026amp; as_offset_datetime_fmt(const std::nothrow_t\u0026amp;) const noexcept; local_datetime_format_info const\u0026amp; as_local_datetime_fmt (const std::nothrow_t\u0026amp;) const noexcept; local_date_format_info const\u0026amp; as_local_date_fmt (const std::nothrow_t\u0026amp;) const noexcept; local_time_format_info const\u0026amp; as_local_time_fmt (const std::nothrow_t\u0026amp;) const noexcept; array_format_info const\u0026amp; as_array_fmt (const std::nothrow_t\u0026amp;) const noexcept; table_format_info const\u0026amp; as_table_fmt (const std::nothrow_t\u0026amp;) const noexcept; 戻り値 # 指定された型のフォーマット情報を持つ構造体への参照を返します。\n備考 # 格納されている値の型が指定と異なる場合、未定義動作となります。\nat(key) # value_type\u0026amp; at(const key_type\u0026amp; key); value_type const\u0026amp; at(const key_type\u0026amp; key) const; 戻り値 # 今のvalueをtableにキャストしたあと、keyによって指定される要素を返します。\n例外 # もし格納している値がtableではなかった場合、toml::type_errorを送出します。\nもし格納しているtableが指定された要素を持っていなかった場合、std::out_of_rangeを送出します。\noperator[](key) # value_type\u0026amp; operator[](const key_type\u0026amp; k); 戻り値 # 今のvalueをtableにキャストしたあと、keyによって指定される要素への参照です。\nもしkeyによって指定される要素が存在しない場合、デフォルト構築されます。\n例外 # もし格納している値がtableではなかった場合、toml::type_errorを送出します。\ncount(key) # std::size_t count(const key_type\u0026amp; key) const; 戻り値 # 今のvalueをtableにキャストしたあと、keyに対応する要素が含まれていれば1、そうでなければ0を返します。\n例外 # もし格納している値がtableではなかった場合、toml::type_errorを送出します。\ncontains(key) # bool contains(const key_type\u0026amp; key) const; 戻り値 # 今のvalueをtableにキャストしたあと、keyに対応する要素が含まれていればtrue、そうでなければfalseを返します。\n例外 # もし格納している値がtableではなかった場合、toml::type_errorを送出します。\nat(idx) # value_type\u0026amp; at(const std::size_t idx); value_type const\u0026amp; at(const std::size_t idx) const; 戻り値 # 今のvalueをarrayにキャストしたあと、idxによって指定される要素を返します。\n例外 # もし格納している値がarrayではなかった場合、toml::type_errorを送出します。\nもし格納しているarrayが指定された要素を持っていなかった場合、std::out_of_rangeを送出します。\noperator[](idx) # value_type\u0026amp; operator[](const std::size_t idx) noexcept; value_type const\u0026amp; operator[](const std::size_t idx) const noexcept; 戻り値 # 今のvalueをarrayにキャストしたあと、idxによって指定される要素への参照を返します。\n備考 # 一切のチェックを行いません。\nもし格納している値がarrayではなかった場合、あるいはidxによって指定される要素が存在しない場合、未定義動作となります。\npush_back(value) # void push_back(const value_type\u0026amp; x); void push_back(value_type\u0026amp;\u0026amp; x); valueをarrayにキャストしたのち、そのarrayに対してpush_backを実行します。\n戻り値 # なし。\n例外 # 格納している値がarrayではなかった場合、toml::type_errorを送出します。\nemplace_back(args...) # template\u0026lt;typename ... Ts\u0026gt; value_type\u0026amp; emplace_back(Ts\u0026amp;\u0026amp; ... args) valueをarrayにキャストしたのち、そのarrayに対してemplace_backを実行します。\n戻り値 # 構築した値への参照。\n例外 # 格納している値がarrayではなかった場合、toml::type_errorを送出します。\nsize() # std::size_t size() const; 戻り値 # 今のvalueをarray、string、tableのどれかにキャストしたあと、その要素数を返します。 stringの場合、文字数を返します。\n例外 # 格納している値がarray, string, tableのどれでもなかった場合、toml::type_errorを送出します。\nlocation() # source_location location() const; 戻り値 # そのvalueが定義されたTOML文書内の位置を表すsource_locationオブジェクトを返します。\nもしTOML文書のパースによって構築されたものでない場合、どこも指示さないsource_locationを返します。\ncomments() # comment_type const\u0026amp; comments() const noexcept; comment_type\u0026amp; comments() noexcept; 戻り値 # コメント用コンテナへの参照を返します。\naccessed() # bool accessed() const; 戻り値 # そのvalueがパース後に一度でもas_xxxやis_xxxでアクセスされていた場合、trueを返します。 それ以外の場合、falseを返します。\n備考 # TOML11_ENABLE_ACCESS_CHECKが定義されている場合にのみ存在します。\n非メンバ関数 # operator== # template\u0026lt;typename TC\u0026gt; bool operator==(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); 以下を満たすとき、2つのbasic_value\u0026lt;T\u0026gt;は同値となります。\nTOML型が同一 含む値が同一 コメントがバイト単位で同一 operator!= # template\u0026lt;typename TC\u0026gt; bool operator!=(const basic_value\u0026lt;TC\u0026gt;\u0026amp; lhs, const basic_value\u0026lt;TC\u0026gt;\u0026amp; rhs) { return !(lhs == rhs); } operator\u0026lt; # array_typeとtable_typeがoperator\u0026lt;を持っている場合のみ定義されます。\ntemplate\u0026lt;typename TC\u0026gt; bool operator\u0026lt;(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); 以下の順番で比較されます。\nTOML型 TOML型が同一の場合、その値 TOML型とその値が同一の場合、コメント TOML型は、以下の順に小さい値を持ちます。\ntoml::value_t::empty toml::value_t::boolean toml::value_t::integer toml::value_t::floating toml::value_t::string toml::value_t::offset_datetime toml::value_t::local_datetime toml::value_t::local_date toml::value_t::local_time toml::value_t::array toml::value_t::table operator\u0026lt;= # array_typeとtable_typeがoperator\u0026lt;を持っている場合のみ定義されます。\ntemplate\u0026lt;typename TC\u0026gt; bool operator\u0026lt;=(const basic_value\u0026lt;TC\u0026gt;\u0026amp; lhs, const basic_value\u0026lt;TC\u0026gt;\u0026amp; rhs) { return (lhs \u0026lt; rhs) || (lhs == rhs); } operator\u0026gt; # array_typeとtable_typeがoperator\u0026lt;を持っている場合のみ定義されます。\ntemplate\u0026lt;typename TC\u0026gt; bool operator\u0026gt;(const basic_value\u0026lt;TC\u0026gt;\u0026amp; lhs, const basic_value\u0026lt;TC\u0026gt;\u0026amp; rhs) { return !(lhs \u0026lt;= rhs); } operator\u0026gt;= # array_typeとtable_typeがoperator\u0026lt;を持っている場合のみ定義されます。\ntemplate\u0026lt;typename TC\u0026gt; bool operator\u0026gt;=(const basic_value\u0026lt;TC\u0026gt;\u0026amp; lhs, const basic_value\u0026lt;TC\u0026gt;\u0026amp; rhs) { return !(lhs \u0026lt; rhs); } toml::type_error # 型エラーの際に送出される例外です。\n型エラーが生じた値の位置情報が格納されています。\nstruct type_error final : public ::toml::exception { public: type_error(std::string what_arg, source_location loc); ~type_error() noexcept override = default; const char* what() const noexcept override; source_location const\u0026amp; location() const noexcept; }; toml::make_error_info # template\u0026lt;typename TC, typename ... Ts\u0026gt; error_info make_error_info( std::string title, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, std::string msg, Ts\u0026amp;\u0026amp; ... tail); basic_value の location() を呼び出して、その source_location を make_error_info に渡して error_info を作成します。\n詳しくは error_info を参照してください。\ntoml::format_error # template\u0026lt;typename TC, typename ... Ts\u0026gt; std::string format_error(std::string title, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, std::string msg, Ts\u0026amp;\u0026amp; ... tail); basic_value の location() を呼び出して、その source_location を format_error に渡して error_info を作成し、それを文字列化して返します。\n詳しくは error_info を参照してください。\n関連項目 # comments.hpp source_location.hpp types.hpp visit.hpp "},{"id":35,"href":"/toml11/ja/docs/reference/version/","title":"version.hpp","section":"reference","content":" version.hpp # version.hppでは、toml11とC++のバージョン情報に関係するマクロが定義されます。\nマクロ # TOML11_VERSION_MAJOR # toml11のメジャーバージョンです。\nTOML11_VERSION_MINOR # toml11のマイナーバージョンです。\nTOML11_VERSION_PATCH # toml11のパッチバージョンです。\n関数 # license_notice # namespace toml { const char* license_notice() noexcept; } ライセンス条項を返します。\nソースコードを公開せずに頒布する際の利便性のために用意されています。\n"},{"id":36,"href":"/toml11/ja/docs/reference/visit/","title":"visit.hpp","section":"reference","content":" visit.hpp # visit.hppでは、toml::visitが定義されます。\ntoml::visit # 関数 # namespace toml { template\u0026lt;typename Visitor, typename ... Args\u0026gt; /* visitor にArgsの中身を渡した際の返り値 */ visit(Visitor\u0026amp;\u0026amp; visitor, Args\u0026amp;\u0026amp; ... args); } // toml basic_value\u0026lt;TC\u0026gt;が保持している型に対応するVisitorのオーバーロードを呼び出し、その結果を返します。\n条件 # Visitorは、basic_value\u0026lt;TC\u0026gt;が保持している型のどれに対しても呼び出し可能な関数または関数オブジェクトでなければなりません。\nまた、それぞれのオーバーロードで返り値は同じであることが要求されます。\n例 # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; struct type_name_of { std::string operator()(const toml::value::boolean_type \u0026amp;) const {return \u0026#34;boolean\u0026#34;;} std::string operator()(const toml::value::integer_type \u0026amp;) const {return \u0026#34;integer\u0026#34;;} std::string operator()(const toml::value::floating_type \u0026amp;) const {return \u0026#34;floating\u0026#34;;} std::string operator()(const toml::value::string_type \u0026amp;) const {return \u0026#34;string\u0026#34;;} std::string operator()(const toml::value::local_time_type \u0026amp;) const {return \u0026#34;local_time\u0026#34;;} std::string operator()(const toml::value::local_date_type \u0026amp;) const {return \u0026#34;local_date\u0026#34;;} std::string operator()(const toml::value::local_datetime_type \u0026amp;) const {return \u0026#34;local_datetime\u0026#34;;} std::string operator()(const toml::value::offset_datetime_type\u0026amp;) const {return \u0026#34;offset_datetime\u0026#34;;} std::string operator()(const toml::value::array_type \u0026amp;) const {return \u0026#34;array\u0026#34;;} std::string operator()(const toml::value::table_type \u0026amp;) const {return \u0026#34;table\u0026#34;;} }; int main() { toml::value v(3.14); std::cout \u0026lt;\u0026lt; toml::visit(type_name_of{}, v) \u0026lt;\u0026lt; std::endl; // floating return 0; } 関連項目 # value.hpp "}]