<!doctype html><html lang=ja dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  ordered_map.hpp
  #

ファイル中の値の順番を維持するために使用するtoml::ordered_mapを定義します。

  class ordered_map
  #

namespace toml
{
template<typename Key, typename Val, typename Cmp = std::equal_to<Key>,
         typename Allocator = std::allocator<std::pair<Key, Val>>>
class ordered_map;
}
ordered_mapは、値を追加した順序を保ったまま値を保持し、その順でイテレートできる map 型です。
線形コンテナなので、検索には要素数に対して O(n) の時間がかかります。
検索を行う機会が少なく、値の順序を守る必要がある場合に使用してください。

  非メンバ型
  #

namespace toml
{
struct ordered_type_config;

using ordered_value = basic_value<ordered_type_config>;
using ordered_table = typename ordered_value::table_type;
using ordered_array = typename ordered_value::array_type;
}
toml::type_config と toml::value の代わりに使用します。

  toml::parse はデフォルトで type_config を使用するので、パースする際に
const auto input = toml::parse<toml::ordered_type_config>("input.toml");
としてください。




  メンバ型
  #

using key_type       = Key;
using mapped_type    = Val;
using value_type     = std::pair<Key, Val>;
using key_compare    = Cmp;
using allocator_type = Allocator;

using container_type  = std::vector<value_type, Allocator>;
using reference       = typename container_type::reference;
using pointer         = typename container_type::pointer;
using const_reference = typename container_type::const_reference;
using const_pointer   = typename container_type::const_pointer;
using iterator        = typename container_type::iterator;
using const_iterator  = typename container_type::const_iterator;
using size_type       = typename container_type::size_type;
using difference_type = typename container_type::difference_type;

  メンバ関数
  #


  コンストラクタ
  #

ordered_map() = default;
空の ordered_map を構築します。'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://toruniina.github.io/toml11/ja/docs/reference/ordered_map/"><meta property="og:site_name" content="toml11"><meta property="og:title" content="ordered_map.hpp"><meta property="og:description" content='ordered_map.hpp # ファイル中の値の順番を維持するために使用するtoml::ordered_mapを定義します。
class ordered_map # namespace toml { template<typename Key, typename Val, typename Cmp = std::equal_to<Key>, typename Allocator = std::allocator<std::pair<Key, Val>>> class ordered_map; } ordered_mapは、値を追加した順序を保ったまま値を保持し、その順でイテレートできる map 型です。
線形コンテナなので、検索には要素数に対して O(n) の時間がかかります。 検索を行う機会が少なく、値の順序を守る必要がある場合に使用してください。
非メンバ型 # namespace toml { struct ordered_type_config; using ordered_value = basic_value<ordered_type_config>; using ordered_table = typename ordered_value::table_type; using ordered_array = typename ordered_value::array_type; } toml::type_config と toml::value の代わりに使用します。
toml::parse はデフォルトで type_config を使用するので、パースする際に
const auto input = toml::parse<toml::ordered_type_config>("input.toml"); としてください。
メンバ型 # using key_type = Key; using mapped_type = Val; using value_type = std::pair<Key, Val>; using key_compare = Cmp; using allocator_type = Allocator; using container_type = std::vector<value_type, Allocator>; using reference = typename container_type::reference; using pointer = typename container_type::pointer; using const_reference = typename container_type::const_reference; using const_pointer = typename container_type::const_pointer; using iterator = typename container_type::iterator; using const_iterator = typename container_type::const_iterator; using size_type = typename container_type::size_type; using difference_type = typename container_type::difference_type; メンバ関数 # コンストラクタ # ordered_map() = default; 空の ordered_map を構築します。'><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>ordered_map.hpp | toml11</title><link rel=manifest href=/toml11/manifest.json><link rel=icon href=/toml11/favicon.png><link rel=canonical href=https://toruniina.github.io/toml11/ja/docs/reference/ordered_map/><link rel=alternate hreflang=en href=https://toruniina.github.io/toml11/docs/reference/ordered_map/ title=ordered_map.hpp><link rel=stylesheet href=/toml11/book.min.6d8037b375fe949eee1b70501c5fb9478914c9c5eb3ef7696163fd3031c69421.css integrity="sha256-bYA3s3X+lJ7uG3BQHF+5R4kUycXrPvdpYWP9MDHGlCE=" crossorigin=anonymous><script defer src=/toml11/fuse.min.js></script><script defer src=/toml11/ja.search.min.b1a1e3e4be0fdf11fae2bb2370353d99ecd7abea7ccc29273319c021dda76dfd.js integrity="sha256-saHj5L4P3xH64rsjcDU9mezXq+p8zCknMxnAId2nbf0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/toml11/ja/><span>toml11</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=検索 aria-label=検索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/toml11/svg/translate.svg class=book-icon alt=Languages>
日本語</a></label><ul><li><a href=https://toruniina.github.io/toml11/docs/reference/ordered_map/>English</a></li></ul></li></ul><ul><li><a href=/toml11/ja/docs/installation/>installation</a><ul></ul></li><li><input type=checkbox id=section-b4cfb5b55e913a8d853eacf5e8fba05f class=toggle>
<label for=section-b4cfb5b55e913a8d853eacf5e8fba05f class="flex justify-between"><a href=/toml11/ja/docs/features/>features</a></label><ul><li><a href=/toml11/ja/docs/features/parsing_files/>parsing files</a></li><li><a href=/toml11/ja/docs/features/value/>getting values</a></li><li><a href=/toml11/ja/docs/features/error_message/>error message</a></li><li><a href=/toml11/ja/docs/features/serialize/>serializing values</a></li><li><a href=/toml11/ja/docs/features/configure_types/>configuring types</a></li><li><a href=/toml11/ja/docs/features/literal/>toml literal</a></li><li><a href=/toml11/ja/docs/features/toml_spec/>toml spec</a></li><li><a href=/toml11/ja/docs/features/extension/>extension</a></li></ul></li><li><input type=checkbox id=section-01b096afc5186aea96713b408b47c967 class=toggle checked>
<label for=section-01b096afc5186aea96713b408b47c967 class="flex justify-between"><a href=/toml11/ja/docs/reference/>reference</a></label><ul><li><a href=/toml11/ja/docs/reference/color/>color.hpp</a></li><li><a href=/toml11/ja/docs/reference/comments/>comments.hpp</a></li><li><a href=/toml11/ja/docs/reference/conversion/>conversion.hpp</a></li><li><a href=/toml11/ja/docs/reference/datetime/>datetime.hpp</a></li><li><a href=/toml11/ja/docs/reference/error_info/>error_info.hpp</a></li><li><a href=/toml11/ja/docs/reference/exception/>exception.hpp</a></li><li><a href=/toml11/ja/docs/reference/find/>find.hpp</a></li><li><a href=/toml11/ja/docs/reference/format/>format.hpp</a></li><li><a href=/toml11/ja/docs/reference/from/>from.hpp</a></li><li><a href=/toml11/ja/docs/reference/get/>get.hpp</a></li><li><a href=/toml11/ja/docs/reference/into/>into.hpp</a></li><li><a href=/toml11/ja/docs/reference/literal/>literal.hpp</a></li><li><a href=/toml11/ja/docs/reference/ordered_map/ class=active>ordered_map.hpp</a></li><li><a href=/toml11/ja/docs/reference/parser/>parser.hpp</a></li><li><a href=/toml11/ja/docs/reference/result/>result.hpp</a></li><li><a href=/toml11/ja/docs/reference/serializer/>serializer.hpp</a></li><li><a href=/toml11/ja/docs/reference/source_location/>source_location.hpp</a></li><li><a href=/toml11/ja/docs/reference/spec/>spec.hpp</a></li><li><a href=/toml11/ja/docs/reference/toml_fwd/>toml_fwd.hpp</a></li><li><a href=/toml11/ja/docs/reference/toml/>toml.hpp</a></li><li><a href=/toml11/ja/docs/reference/types/>types.hpp</a></li><li><a href=/toml11/ja/docs/reference/value_t/>value_t.hpp</a></li><li><a href=/toml11/ja/docs/reference/value/>value.hpp</a></li><li><a href=/toml11/ja/docs/reference/version/>version.hpp</a></li><li><a href=/toml11/ja/docs/reference/visit/>visit.hpp</a></li></ul></li><li><a href=/toml11/ja/docs/changelog/>changelog</a><ul></ul></li></ul><ul><li><a href=https://github.com/ToruNiina/toml11 target=_blank rel=noopener>GitHub</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/toml11/svg/menu.svg class=book-icon alt=Menu>
</label><strong>ordered_map.hpp</strong>
<label for=toc-control><img src=/toml11/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#ordered_maphpp>ordered_map.hpp</a></li><li><a href=#class-ordered_map><code>class ordered_map</code></a><ul><li><a href=#非メンバ型>非メンバ型</a></li><li><a href=#メンバ型>メンバ型</a></li><li><a href=#メンバ関数>メンバ関数</a><ul><li><a href=#コンストラクタ>コンストラクタ</a></li><li><a href=#コンストラクタコンパレータアロケータ>コンストラクタ（コンパレータ、アロケータ）</a></li><li><a href=#コピームーブコンストラクタ>コピー・ムーブコンストラクタ</a></li><li><a href=#コンストラクタiterator>コンストラクタ（<code>Iterator</code>）</a></li><li><a href=#コンストラクタstdinitializer_list>コンストラクタ（<code>std::initializer_list</code>）</a></li><li><a href=#コピームーブ代入演算子>コピー・ムーブ代入演算子</a></li><li><a href=#代入演算子stdinitializer_list>代入演算子（<code>std::initializer_list</code>）</a></li><li><a href=#デストラクタ>デストラクタ</a></li><li><a href=#begin-end><code>begin()</code>, <code>end()</code></a></li><li><a href=#empty><code>empty()</code></a></li><li><a href=#size><code>size()</code></a></li><li><a href=#max_size><code>max_size()</code></a></li><li><a href=#clear><code>clear()</code></a></li><li><a href=#push_backkv><code>push_back(kv)</code></a></li><li><a href=#emplace_backk-v><code>emplace_back(k, v)</code></a></li><li><a href=#pop_back><code>pop_back()</code></a></li><li><a href=#insertkv><code>insert(kv)</code></a></li><li><a href=#emplacek-v><code>emplace(k, v)</code></a></li><li><a href=#countk><code>count(k)</code></a></li><li><a href=#containsk><code>contains(k)</code></a></li><li><a href=#findk><code>find(k)</code></a></li><li><a href=#atk><code>at(k)</code></a></li><li><a href=#operatork><code>operator[](k)</code></a></li><li><a href=#erase><code>erase(...)</code></a></li><li><a href=#key_comp><code>key_comp()</code></a></li></ul></li><li><a href=#使用上の注意>使用上の注意</a><ul><li><a href=#キーの書き換え>キーの書き換え</a></li><li><a href=#保たれる順序の詳細>保たれる順序の詳細</a></li></ul></li><li><a href=#関連項目>関連項目</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ordered_maphpp>ordered_map.hpp
<a class=anchor href=#ordered_maphpp>#</a></h1><p>ファイル中の値の順番を維持するために使用する<code>toml::ordered_map</code>を定義します。</p><h1 id=class-ordered_map><code>class ordered_map</code>
<a class=anchor href=#class-ordered_map>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>namespace</span> toml
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Key, <span style=color:#66d9ef>typename</span> Val, <span style=color:#66d9ef>typename</span> Cmp <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>equal_to<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>typename</span> Allocator <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>allocator<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>Key, Val<span style=color:#f92672>&gt;&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ordered_map</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ordered_map</code>は、値を追加した順序を保ったまま値を保持し、その順でイテレートできる <code>map</code> 型です。</p><p>線形コンテナなので、検索には要素数に対して <code>O(n)</code> の時間がかかります。
検索を行う機会が少なく、値の順序を守る必要がある場合に使用してください。</p><h2 id=非メンバ型>非メンバ型
<a class=anchor href=#%e9%9d%9e%e3%83%a1%e3%83%b3%e3%83%90%e5%9e%8b>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>namespace</span> toml
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ordered_type_config</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ordered_value <span style=color:#f92672>=</span> basic_value<span style=color:#f92672>&lt;</span>ordered_type_config<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ordered_table <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> ordered_value<span style=color:#f92672>::</span>table_type;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ordered_array <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> ordered_value<span style=color:#f92672>::</span>array_type;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>toml::type_config</code> と <code>toml::value</code> の代わりに使用します。</p><blockquote class="book-hint info"><p><code>toml::parse</code> はデフォルトで <code>type_config</code> を使用するので、パースする際に</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> input <span style=color:#f92672>=</span> toml<span style=color:#f92672>::</span>parse<span style=color:#f92672>&lt;</span>toml<span style=color:#f92672>::</span>ordered_type_config<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;input.toml&#34;</span>);
</span></span></code></pre></div><p>としてください。</p></blockquote><h2 id=メンバ型>メンバ型
<a class=anchor href=#%e3%83%a1%e3%83%b3%e3%83%90%e5%9e%8b>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> key_type       <span style=color:#f92672>=</span> Key;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> mapped_type    <span style=color:#f92672>=</span> Val;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> value_type     <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>Key, Val<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> key_compare    <span style=color:#f92672>=</span> Cmp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> allocator_type <span style=color:#f92672>=</span> Allocator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> container_type  <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>value_type, Allocator<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> reference       <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>reference;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> pointer         <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>pointer;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> const_reference <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>const_reference;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> const_pointer   <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>const_pointer;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> iterator        <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>iterator;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> const_iterator  <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>const_iterator;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> size_type       <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>size_type;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> difference_type <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> container_type<span style=color:#f92672>::</span>difference_type;
</span></span></code></pre></div><h2 id=メンバ関数>メンバ関数
<a class=anchor href=#%e3%83%a1%e3%83%b3%e3%83%90%e9%96%a2%e6%95%b0>#</a></h2><h3 id=コンストラクタ>コンストラクタ
<a class=anchor href=#%e3%82%b3%e3%83%b3%e3%82%b9%e3%83%88%e3%83%a9%e3%82%af%e3%82%bf>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span></code></pre></div><p>空の <code>ordered_map</code> を構築します。</p><h3 id=コンストラクタコンパレータアロケータ>コンストラクタ（コンパレータ、アロケータ）
<a class=anchor href=#%e3%82%b3%e3%83%b3%e3%82%b9%e3%83%88%e3%83%a9%e3%82%af%e3%82%bf%e3%82%b3%e3%83%b3%e3%83%91%e3%83%ac%e3%83%bc%e3%82%bf%e3%82%a2%e3%83%ad%e3%82%b1%e3%83%bc%e3%82%bf>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>ordered_map</span>(<span style=color:#66d9ef>const</span> Cmp<span style=color:#f92672>&amp;</span> cmp, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc <span style=color:#f92672>=</span> Allocator());
</span></span><span style=display:flex><span><span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>ordered_map</span>(<span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc);
</span></span></code></pre></div><p>キーの比較に使用するコンパレータや、コンテナのメモリ確保に使用するアロケータを指定して構築します。</p><h3 id=コピームーブコンストラクタ>コピー・ムーブコンストラクタ
<a class=anchor href=#%e3%82%b3%e3%83%94%e3%83%bc%e3%83%a0%e3%83%bc%e3%83%96%e3%82%b3%e3%83%b3%e3%82%b9%e3%83%88%e3%83%a9%e3%82%af%e3%82%bf>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map(<span style=color:#66d9ef>const</span> ordered_map<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>ordered_map(ordered_map<span style=color:#f92672>&amp;&amp;</span>)      <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ordered_map(<span style=color:#66d9ef>const</span> ordered_map<span style=color:#f92672>&amp;</span> other, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc);
</span></span><span style=display:flex><span>ordered_map(ordered_map<span style=color:#f92672>&amp;&amp;</span> other, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc);
</span></span></code></pre></div><p>別の <code>ordered_map</code> の内容をコピー・ムーブして構築します。</p><p>コンテナのメモリ確保に使用するアロケータを指定することも可能です。</p><h3 id=コンストラクタiterator>コンストラクタ（<code>Iterator</code>）
<a class=anchor href=#%e3%82%b3%e3%83%b3%e3%82%b9%e3%83%88%e3%83%a9%e3%82%af%e3%82%bfiterator>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> InputIterator<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>ordered_map(InputIterator first, InputIterator last, <span style=color:#66d9ef>const</span> Cmp<span style=color:#f92672>&amp;</span> cmp <span style=color:#f92672>=</span> Cmp(), <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc <span style=color:#f92672>=</span> Allocator());
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> InputIterator<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>ordered_map(InputIterator first, InputIterator last, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc <span style=color:#f92672>=</span> Allocator());
</span></span></code></pre></div><p>イテレータ範囲を受け取って構築します。</p><p>順序は、イテレータの順序に従います。</p><h3 id=コンストラクタstdinitializer_list>コンストラクタ（<code>std::initializer_list</code>）
<a class=anchor href=#%e3%82%b3%e3%83%b3%e3%82%b9%e3%83%88%e3%83%a9%e3%82%af%e3%82%bfstdinitializer_list>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map(std<span style=color:#f92672>::</span>initializer_list<span style=color:#f92672>&lt;</span>value_type<span style=color:#f92672>&gt;</span> v, <span style=color:#66d9ef>const</span> Cmp<span style=color:#f92672>&amp;</span> cmp <span style=color:#f92672>=</span> Cmp(), <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc <span style=color:#f92672>=</span> Allocator());
</span></span><span style=display:flex><span>ordered_map(std<span style=color:#f92672>::</span>initializer_list<span style=color:#f92672>&lt;</span>value_type<span style=color:#f92672>&gt;</span> v, <span style=color:#66d9ef>const</span> Allocator<span style=color:#f92672>&amp;</span> alloc);
</span></span></code></pre></div><p><code>ordered_map{...}</code>の形式で初期化します。</p><h3 id=コピームーブ代入演算子>コピー・ムーブ代入演算子
<a class=anchor href=#%e3%82%b3%e3%83%94%e3%83%bc%e3%83%a0%e3%83%bc%e3%83%96%e4%bb%a3%e5%85%a5%e6%bc%94%e7%ae%97%e5%ad%90>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> ordered_map<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>ordered_map<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(ordered_map<span style=color:#f92672>&amp;&amp;</span>)      <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span></code></pre></div><p>別の <code>ordered_map</code> の内容をコピー・ムーブ代入します。</p><h3 id=代入演算子stdinitializer_list>代入演算子（<code>std::initializer_list</code>）
<a class=anchor href=#%e4%bb%a3%e5%85%a5%e6%bc%94%e7%ae%97%e5%ad%90stdinitializer_list>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ordered_map<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(std<span style=color:#f92672>::</span>initializer_list<span style=color:#f92672>&lt;</span>value_type<span style=color:#f92672>&gt;</span> v);
</span></span></code></pre></div><p><code>std::initializer_list</code> の内容を代入します。</p><h3 id=デストラクタ>デストラクタ
<a class=anchor href=#%e3%83%87%e3%82%b9%e3%83%88%e3%83%a9%e3%82%af%e3%82%bf>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>~</span>ordered_map() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span></code></pre></div><p><code>ordered_map</code> を破棄します。</p><h3 id=begin-end><code>begin()</code>, <code>end()</code>
<a class=anchor href=#begin-end>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>iterator       <span style=color:#a6e22e>begin</span>()        <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>iterator       <span style=color:#a6e22e>end</span>()          <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>begin</span>()  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>end</span>()    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>cbegin</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>cend</span>()   <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>コンテナの内容を順序通りにイテレートします。</p><h3 id=empty><code>empty()</code>
<a class=anchor href=#empty>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>empty</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p><code>ordered_map</code> が空の場合 <code>true</code> を、そうでない場合 <code>false</code> を返します。</p><h3 id=size><code>size()</code>
<a class=anchor href=#size>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t size() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p><code>ordered_map</code> の要素数を返します。</p><h3 id=max_size><code>max_size()</code>
<a class=anchor href=#max_size>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t max_size() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p><code>ordered_map</code> が持つことのできる最大の要素数を返します。</p><h3 id=clear><code>clear()</code>
<a class=anchor href=#clear>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clear</span>();
</span></span></code></pre></div><p>内容を消去します。</p><h3 id=push_backkv><code>push_back(kv)</code>
<a class=anchor href=#push_backkv>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push_back</span>(<span style=color:#66d9ef>const</span> value_type<span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push_back</span>(value_type<span style=color:#f92672>&amp;&amp;</span>);
</span></span></code></pre></div><p>キーと値のペアを末尾に追加します。</p><h3 id=emplace_backk-v><code>emplace_back(k, v)</code>
<a class=anchor href=#emplace_backk-v>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>emplace_back</span>(key_type, mapped_type);
</span></span></code></pre></div><p>キーと値のペアを末尾に追加します。</p><h3 id=pop_back><code>pop_back()</code>
<a class=anchor href=#pop_back>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pop_back</span>();
</span></span></code></pre></div><p>末尾の値を削除します。</p><h3 id=insertkv><code>insert(kv)</code>
<a class=anchor href=#insertkv>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(value_type);
</span></span></code></pre></div><p>キーと値のペアを末尾に追加します。</p><h3 id=emplacek-v><code>emplace(k, v)</code>
<a class=anchor href=#emplacek-v>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>emplace</span>(key_type, mapped_type);
</span></span></code></pre></div><p>キーと値のペアを末尾に追加します。</p><h3 id=countk><code>count(k)</code>
<a class=anchor href=#countk>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t count(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span>) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>キーに対応する値の数を返します。</p><p>同じキーに複数の値を代入することはできないので、値が存在する場合は <code>1</code>, そうでない場合は <code>0</code> を返します。</p><h3 id=containsk><code>contains(k)</code>
<a class=anchor href=#containsk>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>contains</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span>) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>キーに対応する値が存在するなら <code>true</code> を、そうでないなら <code>false</code> を返します。</p><h3 id=findk><code>find(k)</code>
<a class=anchor href=#findk>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>iterator       <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> key)       <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>const_iterator <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> key) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span></code></pre></div><p>キーに対応する値を検索し、それを指すイテレータを返します。</p><p>存在しなかった場合、<code>end()</code>を返します。</p><h3 id=atk><code>at(k)</code>
<a class=anchor href=#atk>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>mapped_type<span style=color:#f92672>&amp;</span>       at(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> k);
</span></span><span style=display:flex><span>mapped_type <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> at(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> k) <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><p>キーに対応する値を検索して返します。</p><p>存在しなかった場合、<code>std::out_of_range</code>を送出します。</p><h3 id=operatork><code>operator[](k)</code>
<a class=anchor href=#operatork>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>mapped_type<span style=color:#f92672>&amp;</span>       <span style=color:#66d9ef>operator</span>[](<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> k);
</span></span><span style=display:flex><span>mapped_type <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span>[](<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> k) <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><p>キーに対応する値を検索して返します。</p><p>存在しなかった場合、新規な値を構築して返します。</p><p><code>ordered_map</code> が <code>const</code> の場合は新規な値を構築できないので、 <code>std::out_of_range</code> を送出します。</p><h3 id=erase><code>erase(...)</code>
<a class=anchor href=#erase>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>iterator <span style=color:#a6e22e>erase</span>(iterator pos);
</span></span><span style=display:flex><span>iterator <span style=color:#a6e22e>erase</span>(const_iterator pos);
</span></span><span style=display:flex><span>iterator <span style=color:#a6e22e>erase</span>(const_iterator first, const_iterator last);
</span></span><span style=display:flex><span>size_type <span style=color:#a6e22e>erase</span>(<span style=color:#66d9ef>const</span> key_type<span style=color:#f92672>&amp;</span> key);
</span></span></code></pre></div><p>イテレータの指す位置の値、あるいはキーに該当する値を削除します。</p><h3 id=key_comp><code>key_comp()</code>
<a class=anchor href=#key_comp>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>key_compare <span style=color:#a6e22e>key_comp</span>() <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><p>比較に使用するコンパレータを返します。</p><h2 id=使用上の注意>使用上の注意
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e4%b8%8a%e3%81%ae%e6%b3%a8%e6%84%8f>#</a></h2><h3 id=キーの書き換え>キーの書き換え
<a class=anchor href=#%e3%82%ad%e3%83%bc%e3%81%ae%e6%9b%b8%e3%81%8d%e6%8f%9b%e3%81%88>#</a></h3><blockquote class="book-hint warning"><p><code>ordered_map</code> は <code>value_type</code> に <code>std::pair&lt;Key, Val></code> を使用しているので、イテレータを介してキーを書き換えることが可能になってしまっています。</p><p>この方法でキーを書き換えることは推奨されません。</p><p>キーを書き換えて既存のキーと衝突した場合、衝突したうちの片方が検索できなくなります。</p><p><code>operator[]</code> や <code>push_back</code>, <code>insert</code> による書き込みの場合は、既存のキーとの衝突が検出されます。</p></blockquote><h3 id=保たれる順序の詳細>保たれる順序の詳細
<a class=anchor href=#%e4%bf%9d%e3%81%9f%e3%82%8c%e3%82%8b%e9%a0%86%e5%ba%8f%e3%81%ae%e8%a9%b3%e7%b4%b0>#</a></h3><blockquote class="book-hint warning"><p><code>ordered_map</code> はキーの順序を保ちますが、ここで保たれる順序は同じテーブルで定義されたキーの順序のみです。
よって、テーブルをまたいだ順序は保たれないことに注意してください。</p><p>例えば、以下のファイルの順序は保たれます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>apple.type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fruit&#34;</span>
</span></span><span style=display:flex><span>apple.skin <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;thin&#34;</span>
</span></span><span style=display:flex><span>apple.color <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;red&#34;</span>
</span></span><span style=display:flex><span>orange.type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fruit&#34;</span>
</span></span><span style=display:flex><span>orange.skin <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;thick&#34;</span>
</span></span><span style=display:flex><span>orange.color <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;orange&#34;</span>
</span></span></code></pre></div><p>対して以下のファイルの順序は保たれません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>apple.type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fruit&#34;</span>
</span></span><span style=display:flex><span>orange.type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fruit&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>apple.skin <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;thin&#34;</span>
</span></span><span style=display:flex><span>orange.skin <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;thick&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>apple.color <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;red&#34;</span>
</span></span><span style=display:flex><span>orange.color <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;orange&#34;</span>
</span></span></code></pre></div><p><code>ordered_map</code> が保つ順序は、rootテーブルに定義された <code>apple</code> と <code>orange</code> の順序と、
<code>apple</code> 内で定義された <code>type</code>, <code>skin</code>, <code>color</code> の順序、
また <code>orange</code> 内で定義された <code>type</code>, <code>skin</code>, <code>color</code> の順序のみです。</p></blockquote><h2 id=関連項目>関連項目
<a class=anchor href=#%e9%96%a2%e9%80%a3%e9%a0%85%e7%9b%ae>#</a></h2><ul><li><a href=https://toruniina.github.io/toml11/ja/docs/reference/parser/>parser.hpp</a></li><li><a href=https://toruniina.github.io/toml11/ja/docs/reference/types/>types.hpp</a></li><li><a href=https://toruniina.github.io/toml11/ja/docs/reference/value/>value.hpp</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#ordered_maphpp>ordered_map.hpp</a></li><li><a href=#class-ordered_map><code>class ordered_map</code></a><ul><li><a href=#非メンバ型>非メンバ型</a></li><li><a href=#メンバ型>メンバ型</a></li><li><a href=#メンバ関数>メンバ関数</a><ul><li><a href=#コンストラクタ>コンストラクタ</a></li><li><a href=#コンストラクタコンパレータアロケータ>コンストラクタ（コンパレータ、アロケータ）</a></li><li><a href=#コピームーブコンストラクタ>コピー・ムーブコンストラクタ</a></li><li><a href=#コンストラクタiterator>コンストラクタ（<code>Iterator</code>）</a></li><li><a href=#コンストラクタstdinitializer_list>コンストラクタ（<code>std::initializer_list</code>）</a></li><li><a href=#コピームーブ代入演算子>コピー・ムーブ代入演算子</a></li><li><a href=#代入演算子stdinitializer_list>代入演算子（<code>std::initializer_list</code>）</a></li><li><a href=#デストラクタ>デストラクタ</a></li><li><a href=#begin-end><code>begin()</code>, <code>end()</code></a></li><li><a href=#empty><code>empty()</code></a></li><li><a href=#size><code>size()</code></a></li><li><a href=#max_size><code>max_size()</code></a></li><li><a href=#clear><code>clear()</code></a></li><li><a href=#push_backkv><code>push_back(kv)</code></a></li><li><a href=#emplace_backk-v><code>emplace_back(k, v)</code></a></li><li><a href=#pop_back><code>pop_back()</code></a></li><li><a href=#insertkv><code>insert(kv)</code></a></li><li><a href=#emplacek-v><code>emplace(k, v)</code></a></li><li><a href=#countk><code>count(k)</code></a></li><li><a href=#containsk><code>contains(k)</code></a></li><li><a href=#findk><code>find(k)</code></a></li><li><a href=#atk><code>at(k)</code></a></li><li><a href=#operatork><code>operator[](k)</code></a></li><li><a href=#erase><code>erase(...)</code></a></li><li><a href=#key_comp><code>key_comp()</code></a></li></ul></li><li><a href=#使用上の注意>使用上の注意</a><ul><li><a href=#キーの書き換え>キーの書き換え</a></li><li><a href=#保たれる順序の詳細>保たれる順序の詳細</a></li></ul></li><li><a href=#関連項目>関連項目</a></li></ul></li></ul></nav></div></aside></main></body></html>