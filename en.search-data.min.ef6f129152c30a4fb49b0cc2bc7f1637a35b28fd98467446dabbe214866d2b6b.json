[{"id":0,"href":"/toml11/docs/installation/","title":"installation","section":"Docs","content":" Installation # Using single_include # The ingle_include/toml.hpps is a single-file, header-only library that consolidates all the functionalities of toml11 into one file.\nThe simplest way to use it is to copy this file to a location included in your INCLUDE_PATH and then add #include \u0026lt;toml.hpp\u0026gt; to your source code.\nThe MIT license notice is included in both the comments and the toml::license_notice() function. If you are redistributing the software without releasing the source code, you must either copy the toml11 license file and include it with your distribution, or ensure that the toml::license_notice() function can be called.\nCloning toml11 and using cmake # If you place toml11 within your repository, for example by using git submodule, and you are using cmake, you can make use of it by adding add_subdirectory(toml11) to your CMakeLists.txt.\nadd_subdirectory(toml11) add_executable(main main.cpp) target_link_libraries(main PUBLIC toml11::toml11) toml11 will only run tests and install when it is the root project.\nCMake FetchContent # Using FetchContent, you can automatically download toml11 to your build directory.\ninclude(FetchContent) FetchContent_Declare( toml11 GIT_REPOSITORY https://github.com/ToruNiina/toml11.git GIT_TAG v4.4.0 ) FetchContent_MakeAvailable(toml11) add_executable(main main.cpp) target_link_libraries(main PRIVATE toml11::toml11) CMake Package Manager (CPM) # After adding cpm to your project, you can use toml11 by doing:\ninclude(cmake/CPM.cmake) CPMAddPackage(\u0026#34;gh:ToruNiina/toml11@4.4.0\u0026#34;) # OR CPMAddPackage( NAME toml11 GITHUB_REPOSITORY \u0026#34;ToruNiina/toml11\u0026#34; VERSION 4.4.0 OPTIONS \u0026#34;TOML11_PRECOMPILE ON\u0026#34; # to pre-compile \u0026#34;TOML11_ENABLE_ACCESS_CHECK ON\u0026#34; # to use value.accessed() ) add_executable(main main.cpp) target_link_libraries(main PUBLIC toml11::toml11) Installing using cmake # After cloning toml11, you can install it using cmake.\n$ cmake -B ./build/ -DTOML11_BUILD_TESTS=ON $ cmake --install ./build/ --prefix=/opt/toml11 If you want to run the test programs before installation, make sure to set -DTOML11_BUILD_TESTS=ON first.\nOnce the installation is complete, you can use it as follows:\nfind_package(toml11) add_executable(main main.cpp) target_link_libraries(main PRIVATE toml11::toml11) Compiling with cmake to Create a Static Library # By defining -DTOML11_PRECOMPILE=ON when running cmake, you can precompile some of the functions in toml11, thereby reducing the overall compile time.\n$ cmake -B ./build/ -DTOML11_PRECOMPILE=ON When linking the library, use target_link_libraries in CMake\ntarget_link_libraries(your_target PUBLIC toml11::toml11) or pass -DTOML11_COMPILE_SOURCES to the compiler to suppress header-only features.\nHowever, since toml11 supports multiple C++ versions and may switch types based on the value of __cplusplus, there is a possibility of link failures if the version used during build differs from the version used during usage. If you encounter issues, set the required version using CMAKE_CXX_STANDARD during compilation. If this is difficult, use it as a header-only library as usual.\nThe find_package(toml11) command defines TOML11_INCLUDE_DIR. Even if you install it as a precompiled library, you can still use it as a header-only library by adding TOML11_INCLUDE_DIR to target_include_directories and avoiding the use of target_link_libraries.\nfind_package(toml11) add_executable(main main.cpp) # Include only, do not link target_include_directories(main PRIVATE ${TOML11_INCLUDE_DIR}) Compiling Examples # You can compile the examples/ directory by setting -DTOML11_BUILD_EXAMPLES=ON.\n$ cmake -B ./build/ -DTOML11_BUILD_EXAMPLES=ON $ cmake --build ./build/ The executable binaries for the examples will be generated in the examples/ directory.\nRunning Tests # To build the tests, set -DTOML11_BUILD_TESTS=ON.\n$ git submodule update --init --recursive $ cmake -B ./build/ -DTOML11_BUILD_TESTS=ON $ cmake --build ./build/ $ ctest --test-dir ./build/ To run the toml-lang/toml-tests, set -DTOML11_BUILD_TOML_TESTS=ON. This will build toml11_decoder and toml11_encoder in the tests/ directory.\n$ git submodule update --init --recursive $ cmake -B ./build/ -DTOML11_BUILD_TOML_TESTS=ON $ cmake --build ./build/ $ ctest --test-dir ./build/ "},{"id":1,"href":"/toml11/docs/features/","title":"features","section":"Docs","content":" Features # This section explains the main features provided by toml11, with examples.\nParsing Files and Strings # Describes the functions for parsing files and strings, and how to handle the errors they produce.\nIncludes:\nParsing files Parsing strings Parsing byte arrays Parsing files without throwing exceptions Parsing strings without throwing exceptions Parsing byte arrays without throwing exceptions Extracting Values from toml::value # Explains how to examine, extract, and convert the data types held by toml::value.\nIncludes:\nChecking the type of a value using member functions Accessing values using member functions Accessing comments Handling inline tables and dotted keys Handling date information Using toml::get\u0026lt;T\u0026gt; for conversion Using toml::get_or to specify a fallback value Using toml::find\u0026lt;T\u0026gt; for searching and conversion Using toml::find_or to specify a fallback value Defining conversions with user-defined types Applying functions with toml::visit Constructing toml::value Creating Error Messages # Explains how to generate error messages with location information from a TOML file using toml::value.\nIncludes:\nExtracting location information from toml::value Constructing error messages Adding color to the output Serializing TOML Files # Describes how to format the values of toml::value and the available formatting options.\nIncludes:\nSpecifying formats for each value of toml::value Formatting toml::value into a string Configuring Types of toml::value # Explains how to customize the types stored in toml::value (such as integer_type and table_type).\nIncludes:\nDefining type_config Using ordered_type_config Disabling comment preservation Using different containers like std::deque Using different numeric types like boost::multiprecision TOML Literals # Explains the _toml literal for embedding TOML files directly in C++ code.\nIncludes:\nUsing TOML literals TOML Language Version # Describes the versions of the TOML language supported by toml11 and how to control language features added in TOML-v1.1.0.\nIncludes:\nUsing TOML language version 1.1.0 Using specific features of TOML language version 1.1.0 TOML Language Extensions # Explains the custom extensions to the TOML language provided by toml11.\nIncludes:\nSupporting null Supporting hexadecimal format for floating-point numbers Allowing units for numbers "},{"id":2,"href":"/toml11/docs/reference/","title":"reference","section":"Docs","content":" Reference # Here, we explain the effects of the classes and functions provided by toml11.\nDirectory Structure # toml.hpp and toml_fwd.hpp reside in ${TOML11_INCLUDE_DIR}. Other files are located in ${TOML11_INCLUDE_DIR}/toml11.\nIf you want to #include each feature\u0026rsquo;s file individually, use #include \u0026lt;toml11/color.hpp\u0026gt;. If you want to include all at once, use #include \u0026lt;toml.hpp\u0026gt;.\ncolor.hpp # Defines functions related to colorizing error messages.\ncomments.hpp # Defines types preserve_comment and discard_comment for preserving comments.\nconversion.hpp # Defines macros to automatically convert toml::value and user-defined classes.\ndatetime.hpp # Defines classes for datetime information.\nerror_info.hpp # Defines a class for error information.\nexception.hpp # Defines the base class for exceptions used in toml11, toml::exception.\nfind.hpp # Defines the toml::find function to search for and convert values.\nformat.hpp # Defines classes for formatting information of values.\nfrom.hpp # Forward declaration of the from\u0026lt;T\u0026gt; type for converting user-defined types.\nget.hpp # Defines the toml::get\u0026lt;T\u0026gt; function to retrieve and convert values from toml::value.\ninto.hpp # Forward declaration of the into\u0026lt;T\u0026gt; type for converting user-defined types.\nliteral.hpp # Defines the operator\u0026quot;\u0026quot; _toml literal.\nordered_map.hpp # Defines toml::ordered_map.\nparser.hpp # Defines functions to parse files or strings.\nresult.hpp # Defines the result\u0026lt;T, E\u0026gt; type for representing success or failure values used as return types in other functions.\nserializer.hpp # Defines the toml::format function and toml::serializer used for serialization.\nsource_location.hpp # Defines the source_location type used for error information, pointing to a location within a file.\nspec.hpp # Defines the toml::semantic_version and toml::spec types to control TOML language version information and feature flags.\ntoml.hpp # toml.hpp includes all other headers, making all toml11 features available.\ntoml_fwd.hpp # toml_fwd.hpp contains forward declarations of structs defined in toml11 and macro definitions.\ntypes.hpp # Defines the toml::type_config type for controlling the types held by toml::value.\nvalue.hpp # Defines the toml::value type.\nvalue_t.hpp # Defines the toml::value_t enumeration.\nversion.hpp # Defines the version information for toml11.\nvisit.hpp # Defines the toml::visit function to apply functions to the values held by toml::value.\nNotes # Functions not explicitly mentioned here (mostly those defined under namespace toml::detail or namespace toml::cxx) are available by inspecting the source code but are not guaranteed to maintain their interface across future versions (including patch version updates).\n"},{"id":3,"href":"/toml11/docs/changelog/","title":"changelog","section":"Docs","content":" Change Log # v4.4.0 # Added # Add toml::find_or_default() (#280) (by Ken Matsui @ken-matsui) Add erase to ordered_map (#282) (#283) (by Sunlight @SunPodder) Add bool basic_value::accessed() const to detect whether the value has been accessed enabled only if TOML11_ENABLE_ACCESS_CHECK is defined Add compare operators to toml::spec Fixed # Use is_void\u0026lt;T\u0026gt; instead of is_same\u0026lt;T, void\u0026gt; (#281) (by Ken Matsui @ken-matsui) Changed # Improve toml::parse performance by 2x Stop using deprecated Ubuntu 20 image on GitHub Actions v4.3.0 # Added # Support std::optional as a template argument of toml::find Support multiple arguments toml::visit(visitor, args...) Fixed # toml::detail::region::last_ may be used uninitialized (#267) (#268) (by amatej @kontura) Fix use with CMake 3.21 and older (#271) (by Severin Leonhardt @SeverinLeonhardt) fix: prevent size_t-max length string allocation (#275) (#276) (by @hayt) update README.md (#277) (by somebody @oldoldtea) (by lz) Make parsing faster for very long line (#278) Avoid known problem in MSVC (#279) Check if source_location::file_name() is null before formatting Changed # Update hugo-book theme Add MSVC 2017 to appveyor build v4.2.0 # Added # Support std::optional members for TOML11_DEFINE_CONVERSION_NON_INTRUSIVE (by Ken Matsui) Make thread_local for color_mode optional (by Ken Matsui) add usage with CPM to README add explanation about ordered_map to README and update doc Fixed # Manually cast file size to std::streamsize (by Pino Toscano) Typographical error in table_format output Format an empty array specified as array-of-table in one line Added a missing include file Fix typos in documentation template syntax (by Jack W) Fix toml::find_or for deeply nested tables v4.1.0 # Added # support std::get\u0026lt;std::u8string\u0026gt; support toml::value(std::u8string) support string_type = std::u8string support operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, toml::value) add bool uppercase to toml::integer_format support template into_toml() (by 萧迩珀) Fixed # Fix not checking for \\r\\n when parsing line comments (by Andreas Keller) Changed # speedup CI tests by multicore build v4.0.3 # Fixed # remove default template argument from forward declaration in toml_fwd.hpp enable to call toml::make_error_info with multiple toml::values enable to copy/move toml::result having std::reference_wrapper fix document generation error with the latest version of hugo fix several tiny errors that causes warning fix CMake compatibility warning Changed # add -Werror / /WX to build script set MSVC warning level to /W4 add explanation of features to README\nv4.0.2 # Fixed # check return value of fread in parse(FILE*) version macro defined in toml11/version.hpp update docs about compilation update docs about file open mode Changed # use version macros defined in toml11/version.hpp as the project version in CMakeLists.txt v4.0.1 # Fixed # Resolved naming conflict of sematic_version::{major, minor} with macros defined in \u0026lt;sys/sysmacro.h\u0026gt; Fixed the definition of operator\u0026lt;\u0026lt; in discard_comments (by Egor Pugin) Fixed the issue where the first blank line was not output in format_location Fixed the issue where error messages pointing to source_location referring to lines containing only newline characters were displayed in two lines Corrected links in the README Corrected the title of the README in example/unicode Added # Configured CI to automatically update single_include/toml.hpp when changes are made to main Changes from v3 to v4 # Breaking Changes # Changed template Parameters of toml::basic_value # In toml11 v3, toml::basic_value took separate template arguments for the comment container, table-type container, and array-type container.\ntemplate\u0026lt;typename Comment, template\u0026lt;typename ...\u0026gt; class Table = std::unordered_map, template\u0026lt;typename ...\u0026gt; class Array = std::vector\u0026gt; class basic_value; However, this approach does not accommodate changes to types such as integer_type.\nIn toml11 v4, toml::basic_value now accepts a single TypeConfig, allowing for more types to be customized.\ntemplate\u0026lt;typename TypeConfig\u0026gt; class basic_value; By default, the types stored in toml::value remain unchanged.\nFor more information on changing types, please refer to the type_config documentation.\nRemoved std::initializer_list Support for toml::basic_value # In toml11 v3, there was an overload for toml::value that accepted std::initializer_list. This allowed for more intuitive initialization of toml::value with arrays and tables.\n// toml11 v3 toml::value v{1,2,3,4,5}; toml::value v{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;b\u0026#34;, \u0026#34;foo\u0026#34;} }; However, this caused the following issues:\nFirst, it was impossible to distinguish between a single-element array and a regular value, as it always became an array.\n// toml11 v3 toml::value v{1}; // Becomes [1,] instead of 1 With the widespread use of uniform initialization, this became very inconvenient.\nSecond, it was unclear whether the value represented a table with all string values or a nested array.\n// toml11 v3 toml::value v{ {\u0026#34;a\u0026#34;, \u0026#34;foo\u0026#34;}, {\u0026#34;b\u0026#34;, \u0026#34;bar\u0026#34;} }; // Could be either: // {a = \u0026#34;foo\u0026#34;, b = \u0026#34;bar\u0026#34;} // [[\u0026#34;a\u0026#34;, \u0026#34;foo\u0026#34;], [\u0026#34;b\u0026#34;, \u0026#34;bar\u0026#34;]] These issues were difficult to resolve due to language specifications.\nTo avoid confusion, toml11 v4 has removed std::initializer_list support.\nWhen initializing toml::value with an array, you must explicitly specify toml::array, and when initializing with a table, you must explicitly specify toml::table.\n// toml11 v4 toml::value v(toml::array{1,2,3,4,5}); toml::value v(toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;b\u0026#34;, \u0026#34;foo\u0026#34;} }); toml::value v{toml::array{1}}; // [1,] toml::value v{1} // 1 toml::value v{toml::table{{\u0026#34;a\u0026#34;, \u0026#34;foo\u0026#34;}, {\u0026#34;b\u0026#34;, \u0026#34;bar\u0026#34;}}}; toml::value v{toml::array{toml::array{\u0026#34;a\u0026#34;, \u0026#34;foo\u0026#34;}, toml::array{\u0026#34;b\u0026#34;, \u0026#34;bar\u0026#34;}}}; While this makes initializing toml::value with tables or arrays slightly less convenient, it ensures that the values will not become unpredictable by requiring explicit type information.\nRenamed toml::basic_value::is_uninitialized() to is_empty() # In toml11 v3, the function to check whether a basic_value was uninitialized was called is_uninitialized.\nHowever, in toml11 v4, the library supports null values as an extension, allowing for the intentional construction of empty values. Therefore, the function has been renamed to is_empty to reflect this change.\nAdded Format Information and Removed toml::string # In toml11 v3, to retain information on whether a string was basic or literal, the library used a thin wrapper around std::string called toml::string.\n// toml11 v3 namespace toml { enum class string_t : std::uint8_t { basic = 0, literal = 1, }; struct string { string_t kind; std::string str; }; } // namespace toml In toml11 v4, to accommodate more format information such as the numeric base or whether arrays should be multiline, every type now has an associated xxx_format type, which is stored alongside the value.\n// toml11 v4 enum class string_format : std::uint8_t { basic = 0, literal = 1, multiline_basic = 2, multiline_literal = 3 }; struct string_format_info { string_format fmt = string_format::basic; bool start_with_newline = false; }; This change allows for more detailed format information to be preserved, ensuring that format specifics for numeric types, arrays, and tables are maintained even after parsing.\nChanged Arguments of toml::format # In toml11 v3, toml::format accepted values such as the precision and width of numeric types.\nHowever, this approach did not allow for detailed formatting specifications, resulting in serialized files that did not match expectations.\nIn toml11 v4, each toml::value now carries its own format information, enabling more detailed formatting options to be preserved within the toml::value itself.\nAs a result, toml::format no longer accepts specific formatting values. Instead, it now only takes a toml::spec, which includes language feature flags used during formatting.\nChanged Member Functions of toml::source_location # In toml11 v3, the member types of toml::source_location were designed to handle only single lines.\nIn toml11 v4, the member types of toml::source_location are designed to handle multiple lines.\nRenamed toml::format_underline to toml::format_location # In toml11 v3, the function used to format location information from toml::source_location was called toml::format_underline.\nTo make the name clearer, it has been renamed to toml::format_location.\nChanged Arguments of toml::format_error # In toml11 v3, there was no class to represent error information, resulting in complex arguments for toml::format_error.\ntemplate\u0026lt;typename C, template\u0026lt;typename ...\u0026gt; class T, template\u0026lt;typename ...\u0026gt; class A\u0026gt; std::string format_error(const std::string\u0026amp; err_msg, const basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v, const std::string\u0026amp; comment, std::vector\u0026lt;std::string\u0026gt; hints = {}, const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED); template\u0026lt;typename C, template\u0026lt;typename ...\u0026gt; class T, template\u0026lt;typename ...\u0026gt; class A\u0026gt; inline std::string format_error(const std::string\u0026amp; err_msg, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v1, const std::string\u0026amp; comment1, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v2, const std::string\u0026amp; comment2, std::vector\u0026lt;std::string\u0026gt; hints = {}, const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED); template\u0026lt;typename C, template\u0026lt;typename ...\u0026gt; class T, template\u0026lt;typename ...\u0026gt; class A\u0026gt; inline std::string format_error(const std::string\u0026amp; err_msg, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v1, const std::string\u0026amp; comment1, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v2, const std::string\u0026amp; comment2, const toml::basic_value\u0026lt;C, T, A\u0026gt;\u0026amp; v3, const std::string\u0026amp; comment3, std::vector\u0026lt;std::string\u0026gt; hints = {}, const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED); In toml11 v4, we have introduced class error_info and make_error_info, simplifying the arguments for format_error.\nstd::string format_error(const error_info\u0026amp; err); std::string format_error(const std::string\u0026amp; errkind, const error_info\u0026amp; err); template\u0026lt;typename ... Ts\u0026gt; std::string format_error(std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); template\u0026lt;typename TC, typename ... Ts\u0026gt; std::string format_error(std::string title, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, std::string msg, Ts\u0026amp;\u0026amp; ... tail); Changed Control of toml::color # In toml11 v3, to control whether to colorize the output, we used the manipulator toml::colorize in conjunction with toml::color::enable/disable.\nThe manipulator allowed us to decide whether to apply color to each stream, but in v4, the frequency of using streams has decreased, and issues such as the fact that std::ios_base::xalloc used internally is not thread-safe in C++11 have arisen. Therefore, we have decided to use only toml::color::enable/disable and have removed toml::colorize.\nNon-Breaking Changes # Added parse_str # In toml11 v3, there was no function to directly parse a string itself. Therefore, when parsing a string, it was necessary to use std::istringstream.\nTo address this inconvenience, we have added toml::parse_str, allowing for direct parsing of strings.\nAdded try_parse # In toml11 v3, when a parser encountered an error, it threw toml::syntax_error.\nHowever, there are cases where you do not want to throw exceptions due to environments where exceptions cannot be thrown, or for reasons of performance.\nIn toml11 v4, we have implemented toml::try_parse using toml::result, which communicates parsing failures without throwing exceptions.\nThis doesn\u0026rsquo;t mean exceptions are never thrown. Errors in the standard library being used, such as std::bad_alloc due to allocation failure from memory exhaustion, may still be thrown.\nSupport for Parsing Byte Sequences # To allow for parsing TOML content obtained through means other than files, we have added toml::parse and toml::try_parse functions that accept std::vector\u0026lt;unsigned char\u0026gt;.\nAdded toml::spec # In toml11 v3, all new features of the TOML language were incorporated, and features that were decided to be introduced in future versions of the TOML language were controlled by the macro TOML11_USE_UNRELEASED_TOML_FEATURES.\nThis was because, at the time of developing toml11 v3, the TOML language had not yet reached version 1.0.0, being at versions 0.4.0 to 0.5.0.\nAs not all users are familiar with the latest TOML language specification, displaying error messages based on an older language usage could confuse the entire community. Therefore, until reaching version 1.0.0, it was necessary to provide new language specifications as quickly as possible and encourage users to update.\nHowever, the current TOML language specification is at version 1.0.0. Therefore, there was a need to be mindful of the choice to continue using version 1.0.0 even after TOML v1.1.0 was released.\nTo allow for more flexibility in selecting the TOML language specification, we introduced toml::spec, enabling the TOML language version to be changed at runtime.\nAdditionally, in toml::spec, flags are set for each language feature, allowing for the testing of specific language features only.\nThis mechanism is also used for TOML-specific language extensions in toml11 v4.\nAdded Format Information # In toml11 v3, format information was not saved except for strings, and during serialization, only width and precision were considered.\nHowever, this resulted in hexadecimal integers being serialized as decimal integers and no reliable way to ensure inline tables.\nIn toml11 v4, format information (integer_format, etc.) has been added to all TOML types, and it is now considered during parsing and serialization.\nThis allows for more detailed format information to be set for values, such as hexadecimal integers or inline tables.\nChanged to preserve_comments by Default # In toml11 v3, comments were not parsed by default and were also not serialized.\nThis was because comments were a later introduced feature and were being read through a special hack.\nIn toml11 v4, comments are parsed, preserved, and serialized by default.\nFurthermore, the parser implementation has been significantly changed to ensure comments are parsed alongside other elements.\nChanged to Preserve Comments by Default # In toml11 v3, comments were neither parsed nor serialized by default. This was because comment support was a late addition, implemented through a special hack.\nIn toml11 v4, comments are now parsed, preserved, and serialized by default. The parser implementation has also been significantly revised so that comments are parsed just like any other element.\nAdded single_include/toml.hpp # toml11 is a versatile library with different header files for various features to enhance development efficiency. However, this required a certain amount of effort to install.\nStarting with toml11 v4, a single_include/toml.hpp file has been added, which combines all the header files in the correct order. This allows the library to be installed by simply copying a single file.\nOption to Use Precompiled Library # Due to the extensive use of templates in toml11, compile times have been long.\nIn toml11 v4, the number of precompilable functions has been increased, allowing them to be compiled ahead of time into a library. This is expected to reduce compile times when using the library in large-scale development projects.\nReference Documentation # Previously, all features were documented in the README, with no detailed function definitions or reference materials available in Japanese.\nIn toml11 v4, reference documentation has been included, provided in both Japanese and English. However, since the library author is a native Japanese speaker, the Japanese content is considered primary. If there are discrepancies between the Japanese and English content, the Japanese version takes precedence.\n"},{"id":4,"href":"/toml11/docs/features/parsing_files/","title":"parsing files","section":"features","content":" Parsing Files and Strings # In toml11, you can parse files, strings, and byte arrays using toml::parse or toml::try_parse.\nUpon success, these functions return a toml::value. Although the parsed file is always a table, the return type is not toml::table. This is because toml::value contains metadata about the file, whereas toml::table is merely an alias for std::unordered_map\u0026lt;std::string, toml::value\u0026gt;. To include metadata, a toml::value is returned instead of a toml::table. The toml::value corresponding to the root of the file will always hold a table_type.\nParsing Files # To parse files, use either toml::parse or toml::try_parse.\ntoml::parse # Specifying the Filename with std::string # toml::parse accepts a filename as a string, opens the file, and parses it.\nThe following sample code parses a file named input.toml, extracts the title variable as a string, and prints it.\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { const toml::value input = toml::parse(\u0026#34;input.toml\u0026#34;); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; return 0; } Specifying a File with std::filesystem::path # toml::parse can accept a std::filesystem::path.\nThis requires C++17 or later, as it relies on the \u0026lt;filesystem\u0026gt; support.\nSpecifying an Input Stream with std::istream # toml::parse can also accept an std::istream.\nOpen a stream in binary mode by passing std::ios::binary to avoid inconsistency between the file size and the number of characters due to automatic conversion of newline characters by the standard library.\nWithout the filename information, error messages will display \u0026quot;unknown file\u0026quot;. To avoid this, you can pass the filename as a std::string in the second argument when using std::istream.\nYou can use streams other than std::ifstream, such as std::istringstream. Note that the entire content is readable at the time of the call.\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::string filename(\u0026#34;input.toml\u0026#34;); std::ifstream ifs(filename); const toml::value input = toml::parse(ifs, filename); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; return 0; } Specifying a File with FILE* # toml::parse can also accept a FILE*.\nOpen a stream in binary mode by passing \u0026quot;rb\u0026quot; to avoid inconsistency between the file size and the number of characters due to automatic conversion of newline characters by the standard library.\nAs with std::istream, you need to provide the filename as a string in the second argument.\nWhen passing a FILE*, if the file read fails, errno will be reported.\nError Handling # toml::parse throws a toml::syntax_error if it encounters a syntax error.\ntoml::syntax_error is derived from toml::exception, which in turn is derived from std::exception.\nTherefore, you can use the what() member function to retrieve the error message from a toml::syntax_error.\nAdditionally, toml::syntax_error contains a std::vector\u0026lt;toml::error_info\u0026gt;, which can be accessed using the errors() member function.\ntoml::parse attempts to recover from minor errors and report multiple errors whenever possible. While it can often recover from simple errors like number format issues, errors within arrays or tables might not be recoverable and may lead to multiple similar error reports. If you find the error messages redundant, you can use only the front() of the std::vector\u0026lt;toml::error_info\u0026gt; to get a message about the most critical issue.\n#include \u0026lt;toml.hpp\u0026gt; int main() { try { const toml::value input = toml::parse(\u0026#34;input.toml\u0026#34;); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; } catch(const toml::syntax_error\u0026amp; err) { // report all the errors std::cerr \u0026lt;\u0026lt; err.what() \u0026lt;\u0026lt; std::endl; // report the first error only std::cerr \u0026lt;\u0026lt; err.errors().front() \u0026lt;\u0026lt; std::endl; } } toml::try_parse # While toml::parse throws an exception on failure, toml::try_parse does not throw exceptions when it fails.\nInstead, its return type is toml::result\u0026lt;toml::value, std::vector\u0026lt;toml::error_info\u0026gt;\u0026gt;.\nThe result type holds either a success value or a failure value, similar to Rust\u0026rsquo;s Result or Haskell\u0026rsquo;s Either.\n#include \u0026lt;toml.hpp\u0026gt; int main() { const auto parse_result = toml::try_parse(\u0026#34;input.toml\u0026#34;); if(parse_result.is_ok()) { std::cout \u0026lt;\u0026lt; parse_result.unwrap().at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; } else { std::cerr \u0026lt;\u0026lt; parse_result.unwrap_err().at(0) \u0026lt;\u0026lt; std::endl; } return 0; } To check which value the result type holds, use the is_ok() and is_err() functions. The success or failure value can be retrieved using unwrap() and unwrap_err(), respectively. If unwrap fails, it throws a bad_result_access exception. Using the as_ok() and as_err() functions does not throw exceptions on failure, but results in undefined behavior.\nAlthough try_parse does not throw syntax_error or file_io_error, it returns the same toml::error_info as the failure type in the result. However, it is not entirely exception-free.\nIf an internal standard library error occurs, such as std::bad_alloc when a vector fails to allocate memory, toml::try_parse does not catch this and will let it propagate. Thus, exceptions originating from the standard library may still be thrown.\nParsing Strings # toml::parse_str # toml::parse_str accepts the string to be parsed directly, instead of a filename.\nFor the part of the error message that corresponds to the TOML file\u0026rsquo;s name, if the std::source_location equivalent compiler extension is available, the name and line number of the C++ file that called parse_str will be used instead.\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { const toml::value input = toml::parse_str(\u0026#34;title = \\\u0026#34;parse_str\\\u0026#34;\u0026#34;); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; return 0; } toml::try_parse_str # toml::try_parse_str also takes the string to be parsed directly, similar to parse_str. Like try_parse, it uses toml::result to report errors.\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { const auto parse_result = toml::try_parse_str(\u0026#34;title = \\\u0026#34;parse_str\\\u0026#34;\u0026#34;); if(parse_result.is_ok()) { std::cout \u0026lt;\u0026lt; parse_result.unwrap().at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; } else { std::cerr \u0026lt;\u0026lt; parse_result.unwrap_err().at(0) \u0026lt;\u0026lt; std::endl; } return 0; } Parsing Byte Arrays # It is also possible to parse byte arrays instead of files.\nSince the byte arrays must be encoded in UTF-8, unsigned char is used.\ntoml::parse(std::vector\u0026lt;unsigned char\u0026gt;) # The behavior is the same as toml::parse.\nWhen parsing byte arrays, a filename is required.\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::vector\u0026lt;unsigned char\u0026gt; bytes{/* ... */}; const toml::value input = toml::parse(bytes, \u0026#34;internal bytes\u0026#34;); std::cout \u0026lt;\u0026lt; input.at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; return 0; } toml::try_parse(std::vector\u0026lt;unsigned char\u0026gt;) # The behavior is the same as toml::try_parse.\nWhen parsing byte arrays, a filename is required.\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::vector\u0026lt;unsigned char\u0026gt; bytes{/* ... */}; const auto parse_result = toml::try_parse(bytes, \u0026#34;internal bytes\u0026#34;); if(parse_result.is_ok()) { std::cout \u0026lt;\u0026lt; parse_result.unwrap().at(\u0026#34;title\u0026#34;).as_string() \u0026lt;\u0026lt; std::endl; } else { std::cerr \u0026lt;\u0026lt; parse_result.unwrap_err().at(0) \u0026lt;\u0026lt; std::endl; } return 0; } "},{"id":5,"href":"/toml11/docs/features/value/","title":"getting values","section":"features","content":" Retrieving Values # This section explains how to access the values stored in toml::value.\nAccessing Values Using Member Functions # is_something and as_something # toml::value has member functions like is_boolean() and is_integer() which allow you to check the type of the stored value.\nAdditionally, it has member functions like as_boolean() and as_integer() that allow you to access the value of that type.\nFor a complete list, refer to the toml::value reference.\ntoml::value v = /* ... */; if(v.is_string()) { std::cout \u0026lt;\u0026lt; v.as_string() \u0026lt;\u0026lt; std::endl; } If the stored value is of a different type than specified, a toml::type_error is thrown.\nThe what() method will contain a message like the following:\n[error] toml::value::as_string(): bad_cast to string --\u0026gt; input.toml | 1 | a = 123_456 | ^^^^^^^-- the actual type is integer toml::value_t # Type information can be identified using enum class toml::value_t.\nThe type() member function returns the type information of the currently stored value.\ntoml::value v = /* ... */; switch(v.type()) { case toml:value_t::empty : { /*...*/ break; } case toml:value_t::boolean : { /*...*/ break; } case toml:value_t::integer : { /*...*/ break; } case toml:value_t::floating : { /*...*/ break; } case toml:value_t::string : { /*...*/ break; } case toml:value_t::offset_datetime: { /*...*/ break; } case toml:value_t::local_datetime : { /*...*/ break; } case toml:value_t::local_date : { /*...*/ break; } case toml:value_t::local_time : { /*...*/ break; } case toml:value_t::array : { /*...*/ break; } case toml:value_t::table : { /*...*/ break; } default: {break;} } The is(toml::value_t) member function returns true if the stored value is of the given value_t type, otherwise it returns false.\ntoml::value v = /* ... */; if(v.is(toml::value_t::integer)) { std::cout \u0026lt;\u0026lt; v.as_integer() \u0026lt;\u0026lt; std::endl; } at, [], contains, size, push_back, emplace_back # toml::value provides some member functions similar to those of standard library containers.\nThese functions internally convert toml::value to the corresponding type and call the respective member functions.\nat(std::size_t i), operator[](std::size_t i) # These are equivalent to as_array().at(i) and as_array()[i].\ntoml::value uses std::vector\u0026lt;toml::value\u0026gt; as array_type by default, so at throws std::out_of_range on error, while operator[] results in undefined behavior.\ntoml::value v(toml::array{1,2,3}); std::cout \u0026lt;\u0026lt; v.at(1); If the stored type is not array_type, a type_error is thrown.\nat(std::string key), operator[](std::string key) # These are equivalent to as_table().at(key) and as_table()[key].\ntoml::value uses std::unordered_map\u0026lt;std::string, toml::value\u0026gt; as table_type by default, so if the corresponding value does not exist, at throws std::out_of_range, while operator[] constructs a new toml::value and returns a reference to it. Therefore, there is no const version of operator[].\ntoml::value v(toml::table{}); v[\u0026#34;a\u0026#34;] = 42; If the stored type is not table_type, a type_error is thrown.\nsize() # Returns the length.\nFor array_type or table_type, it returns the number of elements; for string_type, it returns the number of characters (in bytes).\nIf the stored type is none of these, a type_error is thrown.\npush_back(), emplace_back() # These are equivalent to as_array().push_back() and as_array().emplace_back().\nIf the stored type is not array_type, a type_error is thrown.\nAccessing Comments # In toml11, comments are parsed by default and saved line by line with the corresponding value.\nA comment corresponds to the value that comes immediately after the consecutive lines of comments, or to the value on the same line as the comment.\nIf there is no value immediately before or after the comment, it is not associated with any value and is ignored.\n# input.toml # This is a comment about a. a = 42 b = 3.14 # This is a comment about b. # This comment is ignored because it has no corresponding value. # This is the 1st comment about c. # This is the 2nd comment about c. c = \u0026#34;foo\u0026#34; # This is the final comment about c. # This comment is NOT a comment about c. Comments corresponding to a value can be accessed using the comments() member function of toml::value.\ncomments() returns a container that has the same member functions as std::vector\u0026lt;std::string\u0026gt;.\nconst auto v = toml::parse(\u0026#34;input.toml\u0026#34;); const auto\u0026amp; a = v.at(\u0026#34;a\u0026#34;); const auto\u0026amp; b = v.at(\u0026#34;b\u0026#34;); const auto\u0026amp; c = v.at(\u0026#34;c\u0026#34;); assert(a.comments().size() == 1); assert(a.comments().at(0) == \u0026#34;# This is a comment about a.\u0026#34;); assert(b.comments().size() == 1); assert(b.comments().at(0) == \u0026#34;# This is a comment about b.\u0026#34;); assert(c.comments().size() == 3); assert(c.comments().at(0) == \u0026#34;# This is the 1st comment about c.\u0026#34;); assert(c.comments().at(1) == \u0026#34;# This is the 2nd comment about c.\u0026#34;); assert(c.comments().at(2) == \u0026#34;# This is the final comment about c.\u0026#34;); Comments related to the root table of the entire file are written at the beginning of the file.\n# This is a comment about the root table. # This is also a comment about the root table. # This comment is ignored. # This is a comment about a. a = 42 However, if a value immediately follows the initial comment, the comment is interpreted as pertaining to that value, and there are no comments for the root table.\n# This is a comment about a. # This is also a comment about a. a = 42 Handling Inline Tables and Dotted Keys # An inline table is simply a table, and there is no difference in handling it compared to other tables in C++ code.\na = {b = 42, c = \u0026#34;foo\u0026#34;} Dotted keys are also just tables, with no difference in handling compared to other tables in C++ code.\na.b = 42 a.c = \u0026#34;foo\u0026#34; These TOML files are identical to the following file.\n[a] b = 42 c = \u0026#34;foo\u0026#34; Thus, they can all be processed with the exact same code.\nconst auto input = toml::parse(\u0026#34;input.toml\u0026#34;); assert(input.at(\u0026#34;a\u0026#34;).at(\u0026#34;b\u0026#34;).as_integer() == 42); assert(input.at(\u0026#34;a\u0026#34;).at(\u0026#34;c\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); However, it is possible to distinguish them based on format information.\nconst auto input = toml::parse(\u0026#34;input.toml\u0026#34;); switch(input.at(\u0026#34;a\u0026#34;).as_table_fmt().fmt) { case toml::table_format::oneline: { std::cout \u0026lt;\u0026lt; \u0026#34;inline table\u0026#34; \u0026lt;\u0026lt; std::endl; break; } case toml::table_format::multiline: { std::cout \u0026lt;\u0026lt; \u0026#34;normal table\u0026#34; \u0026lt;\u0026lt; std::endl; break; } case toml::table_format::dotted: { std::cout \u0026lt;\u0026lt; \u0026#34;dotted keys\u0026#34; \u0026lt;\u0026lt; std::endl; break; } } This format information is also considered during serialization, which will be described later.\nHandling Date and Time Information # local_date, local_time, local_datetime, and offset_datetime are parsed into dedicated structures with corresponding member variables in toml11.\nWhen using these, you can directly extract the values or use toml::get and toml::find to convert them into types such as std::chrono::system_clock::time_point or std::tm.\nConverting Using toml::get\u0026lt;T\u0026gt; # toml::get\u0026lt;T\u0026gt; is a function that converts and retrieves the value stored in toml::value. Specify the desired target type as T.\nconst toml::value v = /*...*/; std::cout \u0026lt;\u0026lt; toml::get\u0026lt;int\u0026gt;(v) \u0026lt;\u0026lt; std::endl; The toml::find\u0026lt;T\u0026gt; function, described later, also has the same functionality for type conversion.\nIf an unsupported type is specified for the stored value, a toml::type_error is thrown.\nSimple Conversions # boolean_type # Conversion from boolean_type is possible only to bool.\ninteger_type # Any type for which std::is_integral\u0026lt;T\u0026gt; is true, except bool, can be converted from integer_type.\ntoml::value v(42); const auto u32 = toml::get\u0026lt;std::uint32_t\u0026gt;(v); const auto i16 = toml::get\u0026lt;short\u0026gt;(v); floating_type # Any type for which std::is_floating_point\u0026lt;T\u0026gt; is true can be converted from floating_type.\ntoml::value v(3.14); const auto f64 = toml::get\u0026lt;double\u0026gt;(v); const auto f32 = toml::get\u0026lt;float \u0026gt;(v); string_type # string_type can be converted to std::string. From C++17 onwards, it can also be converted to std::string_view.\ntoml::value v(\u0026#34;foo\u0026#34;); const auto s = toml::get\u0026lt;std::string\u0026gt;(v); // C++17 const auto sv = toml::get\u0026lt;std::string_view\u0026gt;(v); datetime variants # local_date, local_datetime, and offset_datetime represent specific dates and times, so they can be converted to std::chrono::system_clock::time_point.\nHowever, since local_time does not include date information, it supports conversion to std::chrono::duration as the elapsed time from 00:00.00.\nAdditionally, local_date and local_datetime conversions take the executing machine\u0026rsquo;s timezone into account.\ndate = 2024-01-23 time = 12:30:00 l_dt = 2024-01-23T12:30:00 o_dt = 2024-01-23T12:30:00+09:00 const auto input = toml::parse(\u0026#34;input.toml\u0026#34;); const auto date = toml::get\u0026lt;std::chrono::system_clock::time_point\u0026gt;(input.at(\u0026#34;date\u0026#34;)); const auto l_dt = toml::get\u0026lt;std::chrono::system_clock::time_point\u0026gt;(input.at(\u0026#34;l_dt\u0026#34;)); const auto o_dt = toml::get\u0026lt;std::chrono::system_clock::time_point\u0026gt;(input.at(\u0026#34;o_dt\u0026#34;)); const auto time = toml::get\u0026lt;std::chrono::minutes\u0026gt;(input.at(\u0026#34;time\u0026#34;)); // 12 * 60 + 30 min Conditions for Obtaining References # toml::get\u0026lt;T\u0026gt; can return a reference if T is the exact type stored in toml::value.\nConversely, if a conversion is necessary (e.g., extracting an integer stored as std::int64_t into std::uint32_t), it is not possible to return a reference to the converted type.\nWhen no conversion is needed, the returned reference can be used to modify the value.\ntoml::value v(42); toml::get\u0026lt;toml::value::integer_type\u0026gt;(v) = 6 * 9; assert(v.as_integer() == 54); Converting Arrays to STL Containers # If all elements in an array have the same type and can be converted to T, it is possible to convert them to std::vector\u0026lt;T\u0026gt;.\na = [1, 2, 3, 4, 5] const auto a = toml::get\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); Other STL containers can also be used.\nconst auto a1 = toml::get\u0026lt;std::deque\u0026lt;int\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); const auto a2 = toml::get\u0026lt;std::list \u0026lt;int\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); const auto a3 = toml::get\u0026lt;std::array\u0026lt;int, 5\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); When converting to std::array, the number of elements must match. If they don\u0026rsquo;t match, a std::out_of_range exception is thrown.\nNon-STL containers that have a default constructor and a push_back method can also be converted using toml::get.\nconst auto a = toml::get\u0026lt;boost::container::small_vector\u0026lt;int, 8\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); Converting Arrays to std::pair or std::tuple # If an array contains elements of different types, it can be converted to std::pair or std::tuple.\na = [true, 3.14] b = [42, 2.718, \u0026#34;foo\u0026#34;] const auto a = toml::get\u0026lt;std::pair\u0026lt;bool, double\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); const auto b = toml::get\u0026lt;std::tuple\u0026lt;int, double, std::string\u0026gt;\u0026gt;(input.at(\u0026#34;b\u0026#34;)); As with std::array, the length of the array must match the number of elements in the std::pair or std::tuple. If they don\u0026rsquo;t match, a std::out_of_range exception is thrown.\nAdditionally, each element must be convertible to the corresponding element in the std::pair or std::tuple. If conversion is not possible, a toml::type_error exception is thrown.\nConverting Nested Arrays # Nested arrays can be converted to nested containers.\na = [ [1, 2, 3], [4, 5, 6] ] const auto a = toml::get\u0026lt;std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(input.at(\u0026#34;a\u0026#34;)); If the types are different, std::pair or std::tuple can be useful.\na = [ [1, 2, 3], [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;] ] const auto a = toml::get\u0026lt; std::pair\u0026lt;std::vector\u0026lt;int\u0026gt;, std::vector\u0026lt;std::string\u0026gt;\u0026gt; \u0026gt;(input.at(\u0026#34;a\u0026#34;)); Converting Tables to std::map # If all values in a table have the same type, they can be converted to std::map or std::unordered_map.\nt = {a = 1, b = 2} const auto t = toml::get\u0026lt;std::map\u0026lt;std::string, int\u0026gt;\u0026gt;(input.at(\u0026#34;t\u0026#34;)); Non-STL containers that have a default constructor and an emplace(key, mapped) method can also be converted using toml::get.\nconst auto t = toml::get\u0026lt;boost::container::flat_map\u0026lt;std::string, int\u0026gt;\u0026gt;(input.at(\u0026#34;t\u0026#34;)); If the conversion of any element fails, a toml::type_error exception is thrown.\nUsing toml::get_or to Specify a Value on Failure # toml::get throws a toml::type_error exception if the conversion fails.\nBy using toml::get_or, you can specify a default value to return instead of an exception in case of a conversion failure.\nUnlike toml::get\u0026lt;T\u0026gt;, get_or infers the target type from the arguments, so there is no need to specify \u0026lt;T\u0026gt;.\nconst auto a = toml::get_or(input.at(\u0026#34;a\u0026#34;), 42); The types that can be converted are the same as for toml::get.\nIf you specify toml::value::xxx_type, you can also retrieve a reference, but in that case, the argument must also be a reference.\ntoml::value::integer_type a_default = 42; auto a\u0026amp; = toml::get_or(input.at(\u0026#34;a\u0026#34;), a_default); Using toml::find\u0026lt;T\u0026gt; to Search and Convert Simultaneously # toml::find\u0026lt;T\u0026gt; is a function that searches for a value in a toml::value holding a table and simultaneously performs the same type conversion as toml::get.\nconst auto a = toml::find\u0026lt;int\u0026gt;(input, \u0026#34;a\u0026#34;); // Equivalent to: const auto a = toml::get\u0026lt;int\u0026gt;(input.at(\u0026#34;a\u0026#34;)); toml::find\u0026lt;T\u0026gt; can also be used with arrays.\nconst auto a = input.at(\u0026#34;a\u0026#34;); const auto a2 = toml::find\u0026lt;int\u0026gt;(a, 2); // Equivalent to: const auto a2 = toml::get\u0026lt;int\u0026gt;(input.at(\u0026#34;a\u0026#34;).at(2)); If an error occurs during type conversion, toml::find\u0026lt;T\u0026gt; throws the same toml::type_error as toml::get. If the key is not found or the index does not exist, it throws std::out_of_range.\nIf no type is specified, toml::find returns a toml::value without type conversion.\nconst auto a = toml::find(input, \u0026#34;a\u0026#34;); // Equivalent to: const auto a = input.at(\u0026#34;a\u0026#34;); toml::find\u0026lt;T\u0026gt; can access values recursively.\na = {b = {c = 42}} const auto a_b_c = toml::find\u0026lt;int\u0026gt;(input, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // Equivalent to: const auto a = toml::get\u0026lt;int\u0026gt;(input.at(\u0026#34;a\u0026#34;).at(\u0026#34;b\u0026#34;).at(\u0026#34;c\u0026#34;)); You can mix keys and indexes.\na = [ {b = 1}, {b = 2}, {b = 3} ] const auto a_2_b = toml::find\u0026lt;int\u0026gt;(input, \u0026#34;a\u0026#34;, 2, \u0026#34;b\u0026#34;); // Equivalent to: const auto a = toml::get\u0026lt;int\u0026gt;(input.at(\u0026#34;a\u0026#34;).at(2).at(\u0026#34;c\u0026#34;)); TOML supports a feature called quoted keys, which allows using normally disallowed characters in keys by enclosing them in \u0026quot;\u0026quot; or ''. Within quoted keys, . does not introduce tables.\n\u0026#34;127.0.0.1\u0026#34; = \u0026#34;value\u0026#34; site.\u0026#34;google.com\u0026#34; = true You can read this TOML file as follows:\nconst auto input = toml::parse(\u0026#34;input.toml\u0026#34;); assert(input.at(\u0026#34;127.0.0.1\u0026#34;).as_string() == \u0026#34;value\u0026#34;); assert(input.at(\u0026#34;site\u0026#34;).at(\u0026#34;google.com\u0026#34;).as_boolean()); To handle such cases seamlessly, toml11 does not automatically split keys containing .. Explicitly specifying the table hierarchy helps in structuring the input file correctly.\nReference: toml.io/Key\nUsing toml::find_or to Search and Specify a Value on Failure # toml::find_or works similarly to toml::find\u0026lt;T\u0026gt;, but allows specifying a default value to return if the search or conversion fails.\nThis is useful when you want to provide a fallback value instead of handling exceptions.\nconst auto a = toml::find_or(input, \u0026#34;a\u0026#34;, 42); Using toml::find_or_default to Search and Use the Default Value on Failure # toml::find_or_default works similarly to toml::find_or\u0026lt;T\u0026gt; but returns the default constructor result if the search or conversion fails.\nThis is useful when you want to use the default value instead of handling exceptions, especially when the default construction is costly, as this delays it until the actual failure happens.\nconst auto a = toml::find_or(input, \u0026#34;a\u0026#34;, expensive()); // ctor is called before the function call const auto a = toml::find_or_default\u0026lt;expensive\u0026gt;(input, \u0026#34;a\u0026#34;); // ctor will be called only on failure toml::find\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt; # If std::optional is available, you can specify std::optional as a template argument of toml::find.\nRecursive access is also supported.\nconst auto input = toml::parse_str(R\u0026#34;( integer = 1 [table] key = 2 [[array-of-tables]] key = 3 )\u0026#34;); const auto a = toml::find\u0026lt;std::optional\u0026lt;int\u0026gt;\u0026gt;(input, \u0026#34;integer\u0026#34;); const auto b = toml::find\u0026lt;std::optional\u0026lt;int\u0026gt;\u0026gt;(input, \u0026#34;table\u0026#34;, \u0026#34;key\u0026#34;); const auto c = toml::find\u0026lt;std::optional\u0026lt;int\u0026gt;\u0026gt;(input, \u0026#34;array-of-tables\u0026#34;, 0, \u0026#34;key\u0026#34;); If a key does not exist, no exception is thrown, and std::nullopt is returned.\nHowever, if a type conversion fails, or if you attempt to access a key on a value that is not a table, or an index on a value that is not an array, a toml::type_error is thrown.\nDefining Conversions for User-Defined Types # With toml::get and toml::find, you can use user-defined types by employing one of the following methods.\nDefining toml::from # In toml11, there is a toml::from type that supports conversions from user-defined types by specializing it as follows:\nnamespace extlib { struct foo { int a; std::string b; }; } // extlib namespace toml { template\u0026lt;\u0026gt; struct from\u0026lt;extlib::foo\u0026gt; { static extlib::foo from_toml(const toml::value\u0026amp; v) { return extlib::foo{ toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;), toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;) }; } }; } // toml If you also want to support toml::value with a modified type configuration, do as follows:\nnamespace extlib { struct foo { int a; std::string b; }; } // extlib namespace toml { template\u0026lt;\u0026gt; struct from\u0026lt;extlib::foo\u0026gt; { template\u0026lt;typename TC\u0026gt; static extlib::foo from_toml(const toml::basic_value\u0026lt;TC\u0026gt;\u0026amp; v) { return extlib::foo{ toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;), toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;) }; } }; } // toml This definition can be automatically generated using TOML11_DEFINE_CONVERSION_NON_INTRUSIVE.\nnamespace extlib { struct foo { int a; std::string b; }; } // extlib TOML11_DEFINE_CONVERSION_NON_INTRUSIVE(extlib::foo, a, b) Alternatively, you can use a reflection library. Refer to the sample in example using boost-ext/reflect.\nDefining a from_toml Member Function # You can also define a conversion by defining a from_toml member function.\nWhen using this method, a default constructor is required.\nstruct bar { int a; std::string b; void from_toml(const toml::value\u0026amp; v) { this-\u0026gt;a = toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;); this-\u0026gt;b = toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;); return ; } }; If both are defined, toml::from takes precedence.\nConstructor Accepting toml::value # If there is a constructor that accepts toml::value, conversion via toml::get can be performed.\nstruct baz { explicit baz(const toml::value\u0026amp; v) : a(toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;)), b(toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;)) {} int a; std::string b; }; If both are defined, toml::from and from_toml take precedence.\nApplying Functions with toml::visit # If you have a function object that can be applied to all types stored in toml::value, you can directly call that function without type conversion using toml::visit.\nstruct type_name_of { std::string operator()(const toml::value::boolean_type \u0026amp;) const {return \u0026#34;boolean\u0026#34;;} std::string operator()(const toml::value::integer_type \u0026amp;) const {return \u0026#34;integer\u0026#34;;} std::string operator()(const toml::value::floating_type \u0026amp;) const {return \u0026#34;floating\u0026#34;;} std::string operator()(const toml::value::string_type \u0026amp;) const {return \u0026#34;string\u0026#34;;} std::string operator()(const toml::value::local_time_type \u0026amp;) const {return \u0026#34;local_time\u0026#34;;} std::string operator()(const toml::value::local_date_type \u0026amp;) const {return \u0026#34;local_date\u0026#34;;} std::string operator()(const toml::value::local_datetime_type \u0026amp;) const {return \u0026#34;local_datetime\u0026#34;;} std::string operator()(const toml::value::offset_datetime_type\u0026amp;) const {return \u0026#34;offset_datetime\u0026#34;;} std::string operator()(const toml::value::array_type \u0026amp;) const {return \u0026#34;array\u0026#34;;} std::string operator()(const toml::value::table_type \u0026amp;) const {return \u0026#34;table\u0026#34;;} }; toml::value v(3.14); std::cout \u0026lt;\u0026lt; toml::visit(type_name_of{}, v) \u0026lt;\u0026lt; std::endl; // floating Constructing toml::value # toml::value can be constructed not only internally by the parser but also in user code.\nYou can construct it by passing a type that is either the same as or convertible to the types stored in toml::value.\ntoml::value v1(true); toml::value v2(42); toml::value v3(3.14); For arrays, you can use toml::array:\ntoml::value v(toml::array{1, 2, 3}); Alternatively, you can pass containers such as std::vector directly:\nconst std::vector\u0026lt;toml::value\u0026gt; a{1,2,3}; toml::value v(a); For tables, you can use toml::table:\ntoml::value v(toml::table{{\u0026#34;foo\u0026#34;, 1}, {\u0026#34;bar\u0026#34;, 2}, {\u0026#34;baz\u0026#34;, 3}}); Or pass containers such as std::map directly:\nconst std::map\u0026lt;std::string, toml::value\u0026gt; t{ {\u0026#34;foo\u0026#34;, 1}, {\u0026#34;bar\u0026#34;, 2}, {\u0026#34;baz\u0026#34;, 3} } toml::value v(t); You can pass format_info and comments to the constructor.\nThe type of comments is std::vector\u0026lt;std::string\u0026gt;. Each element corresponds to a line.\ntoml::integer_format_info fmt; fmt.fmt = toml::integer_format::hex; fmt.spacer = 4; toml::value v1(0xDEADBEEF, fmt); toml::value v2(0xC0FFEE, fmt, {\u0026#34;hex value!\u0026#34;}); Converting to toml::value # When constructing toml::value from user-defined types, you can customize the behavior by defining toml::into or into_toml.\ntoml::into is particularly useful when converting types from other libraries.\nDefining toml::into # By specializing toml::into, you can enable conversions to toml::value.\nThis is useful for types from external libraries that do not provide a conversion to toml::value.\nSince toml::value passes type_config during conversion, you need to accept the template argument of basic_value.\nnamespace extlib { struct foo { int a; std::string b; }; } // extlib template\u0026lt;\u0026gt; struct into\u0026lt;extlib::foo\u0026gt; { template\u0026lt;typename TC\u0026gt; static toml::basic_value\u0026lt;TC\u0026gt; into_toml(const extlib::foo\u0026amp; f) { return toml::basic_value\u0026lt;TC\u0026gt;(typename toml::basic_value\u0026lt;TC\u0026gt;::table_type{{\u0026#34;a\u0026#34;, f.a}, {\u0026#34;b\u0026#34;, f.b}}); } }; Defining into_toml Member Function # Similar to from_toml, you can define the conversion through a member function.\nIf toml::into is defined, it takes precedence.\nstruct bar { int a; std::string b; template\u0026lt;typename TC\u0026gt; toml::basic_value\u0026lt;TC\u0026gt; into_toml() const { return toml::basic_value\u0026lt;TC\u0026gt;(typename toml::basic_value\u0026lt;TC\u0026gt;::table_type{ {\u0026#34;a\u0026#34;, this-\u0026gt;a}, {\u0026#34;b\u0026#34;, this-\u0026gt;b} }); } }; Checking Whether a Value Has Been Accessed # When compiled with the TOML11_ENABLE_ACCESS_CHECK macro defined, the toml::value class gains an additional method: bool accessed() const. This allows you to check whether a value has been accessed after parsing.\n$ g++ -std=c++17 -O2 -DTOML11_ENABLE_ACCESS_CHECK -I/path/to/toml11/include main.cpp or\n$ cmake -B ./build -DTOML11_ENABLE_ACCESS_CHECK=ON or\nCPMAddPackage( NAME toml11 GITHUB_REPOSITORY \u0026#34;ToruNiina/toml11\u0026#34; VERSION 4.4.0 OPTIONS \u0026#34;CMAKE_CXX_STANDARD 17\u0026#34; \u0026#34;TOML11_PRECOMPILE ON\u0026#34; \u0026#34;TOML11_ENABLE_ACCESS_CHECK ON\u0026#34; ) This feature allows users to implement code that warns about values defined in a table but never used.\n#include \u0026lt;toml.hpp\u0026gt; namespace yours { Config read_config(const toml::value\u0026amp; input) { const auto cfg = read_your_config(input); for (const auto\u0026amp; [k, v] : input.as_table()) { if (!v.accessed()) { std::cerr \u0026lt;\u0026lt; toml::format_error(\u0026#34;value defined but not used\u0026#34;, v.source_location(), \u0026#34;not used\u0026#34;); } } return cfg; } } // namespace yours This feature is useful when a value is mistakenly defined under the wrong name but is never accessed. For example:\n# The correct key is \u0026#34;reactions\u0026#34; # reactions = [ \u0026#34;:+1:\u0026#34;, \u0026#34;star\u0026#34; ] # This key is incorrect and will not be read reaction = [ \u0026#34;:+1:\u0026#34;, \u0026#34;star\u0026#34; ] If this file is read using the above code, read_your_config will search for reactions. Since it is not defined, it will process reactions as an empty array. In this case, input.at(\u0026quot;reaction\u0026quot;).accessed() will be false, allowing it to be detected as an error.\n"},{"id":6,"href":"/toml11/docs/features/error_message/","title":"error message","section":"features","content":" Outputting Error Messages # toml11 provides error messages that include location information within the file when using functions like toml::parse, toml::get\u0026lt;T\u0026gt;/find\u0026lt;T\u0026gt;, and as_integer(), among others.\nFor instance, if a syntax error in an integer is detected during parsing, an error message might look like this:\n[error] bad integer: `_` must be surrounded by digits --\u0026gt; internal string at line 64 in file main.cpp | 1 | a = 123__456 | ^-- invalid underscore Hint: valid : -42, 1_000, 1_2_3_4_5, 0xC0FFEE, 0b0010, 0o755 Hint: invalid: _42, 1__000, 0123 Or, if a type different from the one actually stored is requested:\n[error] toml::value::as_string(): bad_cast to string --\u0026gt; input.toml | 1 | a = 123_456 | ^^^^^^^-- the actual type is integer toml11 provides methods to create such error messages from toml::value.\nBy utilizing this feature, you can inform users not only about TOML syntax errors but also about application-specific errors. For example, if a negative number appears where only positive values are allowed, you can highlight the location within the TOML file to convey the error to the user.\nCreating Error Messages from toml::value Location Information # toml::value retains information about the location where it was parsed.\nThis information is encapsulated in toml::source_location and can be retrieved using toml::value::location().\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); const toml::source_location src = a.location(); When a file is parsed with toml::parse, the TOML filename and line numbers are stored.\nIf parsed with toml::parse_str, the TOML filename is not available, but instead, the filename and line number of the C++ source code that called toml::parse_str are stored as the TOML filename. The first example on this page was output from toml::parse_str. Note the filename part.\nFor details, see the reference.\nYou can build error information by passing a toml::source_location or toml::value and the associated error message to toml::make_error_info. Passing this to toml::format_error formats the error message into a std::string.\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); if(a.as_integer() \u0026lt; 0) { const toml::error_info err = toml::make_error_info( \u0026#34;positive integer is required\u0026#34;, // Error title a, \u0026#34;but got negative value\u0026#34; // Message next to the value ); std::cerr \u0026lt;\u0026lt; toml::format_error(err) \u0026lt;\u0026lt; std::endl; } This will output:\n[error] positive integer is required --\u0026gt; input.toml | 1 | a = -123456 | ^^^^^^^-- but got negative value You can also add a supplementary message at the end. This part is not indented.\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); if(a.as_integer() \u0026lt; 0) { const toml::error_info err = toml::make_error_info( \u0026#34;positive integer is required\u0026#34;, // Error title a, \u0026#34;but got negative value\u0026#34;, // Message next to the value \u0026#34;Hint: `a` means length of the data\u0026#34; // Supplementary message ); std::cerr \u0026lt;\u0026lt; toml::format_error(err) \u0026lt;\u0026lt; std::endl; } This will output:\n[error] positive integer is required --\u0026gt; input.toml | 1 | a = -123456 | ^^^^^^^-- but got negative value Hint: `a` means length of the data The ability to output lines from the file using toml::value is because the parsed file is retained in memory as a string.\nThe parsed string is shared by toml::value via a std::shared_ptr. Copying it does not duplicate the entire file string. The file information is freed from memory when all toml::value instances constructed from parsing the file are destructed.\nTherefore, when using this in an application, it is recommended to extract and store the required values during loading rather than directly storing toml::value.\nAdding Colors to Strings # You can add color to error messages using ANSI escape codes.\nIf TOML11_COLORIZE_ERROR_MESSAGE is defined at compile time, the error messages output by toml11 will be colored by default.\nIf not, you can enable color for subsequent error messages by calling toml::color::enable(). Conversely, if you do not want colored output, for example, because the output is not to a console, call toml::color::disable(). You can check whether coloring is enabled at any point by calling toml::color::should_color().\nAdditionally, while the error title, error message, and supplementary information are not colored by default, you can use manipulators from toml::color to add color to them.\nstd::ostringstream oss; oss \u0026lt;\u0026lt; toml::color::red \u0026lt;\u0026lt; \u0026#34;but got negative value\u0026#34;; const toml::error_info err = toml::make_error_info( \u0026#34;positive integer is required\u0026#34;, // Error title a, oss.str(), // Message next to the value \u0026#34;Hint: `a` means length of the data\u0026#34; // Supplementary message ); For more details, see the reference.\nChanging the Prefix of Error Messages from [error] # There may be different types of errors, and the default [error] prefix might not always be appropriate.\nWith toml::format_error, you can provide a std::string before toml::error_info to replace the [error] prefix.\nFor example:\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); if(a.as_integer() \u0026lt; 0) { const toml::error_info err = toml::make_error_info( \u0026#34;positive integer is required\u0026#34;, // Error title a, \u0026#34;but got negative value\u0026#34; // Message next to the value ); std::ostringstream prefix; prefix \u0026lt;\u0026lt; toml::color::bold \u0026lt;\u0026lt; toml::color::yellow \u0026lt;\u0026lt; \u0026#34;[warn]\u0026#34;; std::cerr \u0026lt;\u0026lt; toml::format_error(prefix.str(), err) \u0026lt;\u0026lt; std::endl; return 0; } else { return a.as_integer(); } This will output a warning starting with [warn].\nAdditionally, you can create error messages without the [error] prefix by directly passing the components of error_info to toml::format_error.\nconst toml::value\u0026amp; a = input.at(\u0026#34;a\u0026#34;); if(a.as_integer() \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; toml::format_error( \u0026#34;[warn] positive integer is required\u0026#34;, // Error title a, \u0026#34;but got negative value\u0026#34; // Message next to the value ) \u0026lt;\u0026lt; std::endl; return 0; } else { return a.as_integer() } Creating Error Messages Referencing Multiple toml::value # In application settings, the range of permissible values might change based on previously read values.\nIn such cases, you may want to output the values causing the error simultaneously.\ntoml::format_error and toml::make_error_info can take multiple pairs of toml::value and their corresponding error messages as std::string.\nstd::cerr \u0026lt;\u0026lt; toml::format_error( \u0026#34;[error] invalid range\u0026#34;, a, \u0026#34;minimum value is defined here\u0026#34;, b, \u0026#34;maximum value is defined here\u0026#34;, c, \u0026#34;and it exceeds the range\u0026#34; ) \u0026lt;\u0026lt; std::endl; You can also add supplementary information at the end.\nstd::cerr \u0026lt;\u0026lt; toml::format_error( \u0026#34;[error] invalid range\u0026#34;, a, \u0026#34;minimum value is defined here\u0026#34;, b, \u0026#34;maximum value is defined here\u0026#34;, c, \u0026#34;and it exceeds the range\u0026#34;, \u0026#34;Hint: all the values must be in the range [a, b)\u0026#34; ) \u0026lt;\u0026lt; std::endl; When passing toml::value or toml::source_location, an error message related to it must follow. If not, it will result in a very confusing compilation error.\n"},{"id":7,"href":"/toml11/docs/features/serialize/","title":"serializing values","section":"features","content":" Outputting TOML Files # Using toml::format, you can convert a toml::value to a string.\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;cassert\u0026gt; int main() { const toml::value v(toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;b\u0026#34;, \u0026#34;foo\u0026#34;}, }); const std::string s = toml::format(v); const toml::value u = toml::parse_str(s); assert(u.at(\u0026#34;a\u0026#34;).as_integer() == 42); assert(u.at(\u0026#34;b\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); return 0; } If the toml::value contains a table_type, it is interpreted as the root table of the file.\nIf a toml::value containing anything other than table_type is passed, only that value is formatted.\nCertain format specifications may require a key to be provided for formatting. For example, toml::array_format::array_of_tables formats as [[array.of.tables]], which requires key access.\nIf a format specification that requires a key is provided without a key, a toml::serialization_error is thrown.\nAdditionally, if there are values that contradict the format specification, a toml::serialization_error is thrown. For instance, specifying integer_format::hex for a negative integer, or string_format::literal for a string containing newlines, will cause an error.\nThe method for specifying formats is explained later.\nOutputting with Keys # You can pass a key to toml::format as a std::string.\nIn this case, the key is considered to be under the root table, and the passed value corresponds to that key.\nFor nested keys, you can pass a std::vector\u0026lt;std::string\u0026gt;.\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;cassert\u0026gt; int main() { const toml::value v(toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;b\u0026#34;, \u0026#34;foo\u0026#34;}, }); const std::string s = toml::format(\u0026#34;bar\u0026#34;, v); const toml::value u = toml::parse_str(s); assert(u.at(\u0026#34;bar\u0026#34;).at(\u0026#34;a\u0026#34;).as_integer() == 42); assert(u.at(\u0026#34;bar\u0026#34;).at(\u0026#34;b\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); return 0; } Specifying Formats # Each type in toml::value has a corresponding format information type.\nFor toml::value::integer_type, there is toml::integer_format_info. For toml::value::table_type, there is toml::table_format_info.\nThese format information types are set when parsing and are retained even if the value is changed, as long as the type remains the same.\nYou can access and directly edit these formats using member functions like as_integer_fmt() or as_table_fmt().\nBelow are some examples explaining how to use these formats.\nFor more details on how to access formats, refer to the toml::value reference. For a complete list and detailed information on format information classes, see the format reference.\nSpecifying Integer Formats # For integers, you can specify the radix, width, and the position of _.\nWhen using hex, oct, or bin, values are padded with zeros until the specified width is reached. For dec, the width specification adds spaces, which are not parsed.\nFor more details, see the integer format reference.\nSingle-Line and Multi-Line Arrays # For arrays, you can specify toml::array_format::oneline or toml::array_format::multiline.\n# oneline a = [1, 2, 3, 4, 5] # multiline a = [ 1, 2, 3, 4, 5 ] When using multiline, you can specify the indentation. Each element is indented by the amount specified in body_indent, and the closing bracket ] is indented by the amount specified in closing_indent.\nThe type of character used for indentation is specified by indent_type, and you can choose between toml::indent_char::space or toml::indent_char::tab.\nEnsure that the same type of character is used for indentation throughout the document.\nIf different types of characters are specified for indentation within the same file, the result is undefined. Some form of indentation will be applied, but the type of character and the depth of the indentation may be inconsistent.\nIf all elements of an array have table_type, you can specify toml::array_format::array_of_tables.\nIf you do not specify array_of_tables and use multiline, the tables will be formatted as inline tables.\n# multiline a = [ {foo = 42}, {bar = \u0026#34;hoge\u0026#34;}, ] # array_of_tables [[a]] foo = 42 [[a]] bar = \u0026#34;hoge\u0026#34; By default, toml::array_format::default_format is used. This automatically selects an appropriate format.\nFor example, with default_format, if all elements are table_type, it will choose array_of_tables. Short arrays are formatted as oneline, while long or nested arrays, or those with complex elements, are formatted as multiline.\nFor more details, see the array format reference.\nInline Tables # To format a table as an inline table, specify toml::table_format::oneline. For standard tables, use toml::table_format::multiline.\noneline = {a = 42, b = \u0026#34;foo\u0026#34;} [multiline] a = 42 b = \u0026#34;foo\u0026#34; In TOML v1.1.0, line breaks within inline tables are allowed. In this case, use toml::table_format::multiline_oneline. This is only applied if the corresponding feature flag is set to true as per the TOML version specification described later.\nmultiline_oneline = { a = 42, b = \u0026#34;foo\u0026#34; } For more details, see the table format reference.\nSpecifying the TOML Language Version for Output # Certain language features, such as line breaks within inline tables and \\x escape sequences, are only available after TOML v1.1.0.\nThe toml::format function accepts a toml::spec as its argument.\nThis allows you to specify the version of TOML to use during serialization.\nWhen you use toml::parse with a toml::spec to leverage new features, the parsed values may contain format information that is only compatible with that specific version. Ensure that you pass the same toml::spec to toml::format to maintain compatibility.\n#include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { const auto spec = toml::spec::v(1, 1, 0); const toml::value v = toml::parse(\u0026#34;input.toml\u0026#34;, spec); std::cout \u0026lt;\u0026lt; toml::format(v, spec) \u0026lt;\u0026lt; std::endl; return 0; } "},{"id":8,"href":"/toml11/docs/features/configure_types/","title":"configuring types","section":"features","content":" Customizing Types # The toml::value class uses std::int64_t for integer_type and std::unordered_map\u0026lt;key_type, value_type\u0026gt; for table_type.\nHowever, in some cases, you may want to use boost::multiprecision::int128_t or std::map.\nTo accommodate this, toml::value is implemented with template parameters that allow you to change the stored types.\nJust as std::string is actually an alias for std::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt;\u0026gt;, toml::value is an alias for toml::basic_value\u0026lt;toml::type_config\u0026gt;.\nHere, we will explain the types contained in toml::type_config and how to define a different config type.\ntype_config # The type_config class contains the following member types and static member functions:\nnamespace toml { struct type_config { using comment_type = preserve_comments; using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = std::unordered_map\u0026lt;K, T\u0026gt;; static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base); static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex); }; } toml::basic_value\u0026lt;TypeConfig\u0026gt; defines the stored boolean_type as TypeConfig::boolean_type, the stored integer_type as TypeConfig::integer_type, and so on.\nAdditionally, array_type is defined as TypeConfig::array_type\u0026lt;toml::basic_value\u0026lt;TypeConfig\u0026gt;\u0026gt; and table_type is defined as TypeConfig::table_type\u0026lt;key_type, toml::basic_value\u0026lt;TypeConfig\u0026gt;\u0026gt;.\nBy passing a class that defines these member types and functions to toml::basic_value, you can customize the types used by that toml::basic_value.\nThe parse_int and parse_float functions provide parsing methods when custom numeric types are used. These functions receive strings with prefixes like 0x and digit separators like _ removed, such as 123456 or DEADBEEF. The base parameter will be one of 10, 16, 8, or 2. Implement these functions to parse your custom integer_type and floating_type.\nAs a default implementation, toml::read_int and toml::read_float are provided.\nstatic result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base) { return toml::read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex) { return toml::read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } The read_int function uses istream and employs std::hex and std::oct for hexadecimal and octal parsing, respectively. For binary parsing, it is implemented using multiplication and addition. If your type supports these operations, you can use read_int as-is.\nThe read_float function also uses istream. Hexadecimal floating-point numbers are only supported for double and float types. If read_float is called with any other type and hexfloat is used, it will always return a parse error. Therefore, if you need to use a floating-point type other than double or float with hexfloat, you will need to implement support for that. If hexfloat is not used, no additional implementation is necessary.\nPreserving Order of Values in Tables # In addition to the default toml::type_config, there is also toml::ordered_type_config. This changes the table_type to an ordered_map.\nUsing this, toml::ordered_value is defined, along with aliases for its array and table types as toml::ordered_array and toml::ordered_table, respectively.\nYou can use toml::ordered_value by calling toml::parse(...) as toml::parse\u0026lt;toml::ordered_type_config\u0026gt;(...).\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::ordered_value input = toml::parse\u0026lt;toml::ordered_type_config\u0026gt;(\u0026#34;example.toml\u0026#34;); std::cout \u0026lt;\u0026lt; toml::format(input) \u0026lt;\u0026lt; std::endl; return 0; } Not Preserving Comments # The type_config defines a container for storing comments via comment_type.\nIf comments do not contain significant information and can be discarded during parsing, specify toml::discard_comments for comment_type.\nstruct wo_comment_config { using comment_type = toml::discard_comments; // XXX using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = std::unordered_map\u0026lt;K, T\u0026gt;; static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base) { return toml::read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex) { return toml::read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } }; Using Containers Other Than std::vector for Arrays # To use a container other than vector (e.g., std::deque) for implementing TOML arrays, modify array_type as follows.\nSimilarly, to use a container other than unordered_map (e.g., std::map) for table types, modify table_type as shown below.\nstruct deque_map_config { using comment_type = toml::preserve_comments; using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::deque\u0026lt;T\u0026gt;; // XXX template\u0026lt;typename K, typename T\u0026gt; using table_type = std::map\u0026lt;K, T\u0026gt;; // XXX static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base) { return toml::read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex) { return toml::read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } }; Using boost::multiprecision for Numeric Types # By using boost::multiprecision::cpp_int and boost::multiprecision::cpp_bin_float_oct, you can utilize a wider integer type and a more precise floating-point type.\nThese types implement stream operators, so you can use the default implementations of read_int and read_float without modification.\nstruct large_num_config { using comment_type = toml::preserve_comments; using boolean_type = bool; using integer_type = boost::multiprecision::cpp_int; using floating_type = boost::multiprecision::cpp_bin_float_oct; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = std::unordered_map\u0026lt;K, T\u0026gt;; static toml::result\u0026lt;integer_type, toml::error_info\u0026gt; parse_int(const std::string\u0026amp; str, const toml::source_location src, const std::uint8_t base) { return toml::read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static toml::result\u0026lt;floating_type, toml::error_info\u0026gt; parse_float(const std::string\u0026amp; str, const toml::source_location src, const bool is_hex) { return toml::read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } }; "},{"id":9,"href":"/toml11/docs/features/literal/","title":"toml literal","section":"features","content":" _toml Literal # With the \u0026quot;\u0026quot;_toml literal, you can format TOML files inline.\n#include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto v = \u0026#34;a = 42\u0026#34;_toml; assert(v.at(\u0026#34;a\u0026#34;).as_integer() == 42); return 0; } When including line breaks, raw string literals come in handy.\n#include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto v = R\u0026#34;( a = 42 b = \u0026#34;foo\u0026#34; )\u0026#34;_toml; assert(v.at(\u0026#34;a\u0026#34;).as_integer() == 42); assert(v.at(\u0026#34;b\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); return 0; } If a value is written on its own, that value is returned.\n#include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto a = \u0026#34;42\u0026#34;_toml; const auto b = \u0026#34;12:34:56\u0026#34;_toml; assert(a.as_integer() == 42); assert(b.as_local_time().hour == 12); assert(b.as_local_time().minute == 34); assert(b.as_local_time().second == 56); return 0; } TOML allows keys consisting solely of numbers. Therefore, [1] is a valid table name.\nWhen there\u0026rsquo;s ambiguity between table definitions and arrays, table definitions take precedence.\nTo interpret as an array, please use a trailing comma.\n#include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto t = \u0026#34;[1]\u0026#34;_toml; // {1 = {}} const auto a = \u0026#34;[1,]\u0026#34;_toml; // [1,] assert(t.is_table()); assert(t.at(\u0026#34;1\u0026#34;).is_table()); assert(a.is_array()); assert(a.at(0).as_integer() == 1); return 0; } "},{"id":10,"href":"/toml11/docs/features/toml_spec/","title":"toml spec","section":"features","content":" TOML Language Version # You can specify the version of the TOML language and individual feature flags to use with toml::parse or toml::format through toml::spec.\nSpecifying TOML Version # You can construct a toml::spec from toml::semantic_version.\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec(toml::semantic_version(1, 1, 0)); return 0; } However, to make this shorter, the toml::spec::v() function is provided.\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec = toml::spec::v(1, 1, 0); return 0; } If not specified explicitly, toml::spec::default_version() is used to construct with default values.\nThe default value depends on the version of toml11 and follows the latest version of the TOML language released at that time.\nAs of v4.4.0, TOML v1.1.0 has not been released yet, so the default TOML version is v1.0.0.\nSome features of TOML v1.1.0 are still under fairly lengthy discussion and may still be reverted.\nIf they are indeed reverted, toml11 will remove those features in a minor version upgrade or move them to a corresponding later version.\nAs such, any features related to future versions should be considered unstable.\nParsing with Version Specification # The overload of toml::parse takes a toml::spec following the file name.\nThis allows you to change the TOML version being used.\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::value input = toml::parse(\u0026#34;input.toml\u0026#34;, toml::spec::v(1, 1, 0)); return 0; } Serializing with Version Specification # The overload of toml::format takes a toml::spec following the toml::value.\nThis allows you to change the TOML version being used.\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::value v = toml::parse(\u0026#34;input.toml\u0026#34;, toml::spec::v(1, 1, 0)); std::cout \u0026lt;\u0026lt; toml::format(v, toml::spec::v(1, 1, 0)) \u0026lt;\u0026lt; std::endl; return 0; } If a format is passed that is not permitted by the provided toml::spec, it will be ignored, and another format will be used as a fallback.\nSpecifying Newly Added Features in TOML # With version upgrades in TOML, multiple new features are introduced, and it\u0026rsquo;s possible to enable only some of them.\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec = toml::spec::v(1, 0, 0); // Allowing newlines in inline tables spec.v1_1_0_allow_newlines_in_inline_tables = true; toml::value input = toml::parse(\u0026#34;input.toml\u0026#34;, spec); return 0; } For a full list of all flags, refer to toml::spec.\n"},{"id":11,"href":"/toml11/docs/features/extension/","title":"extension","section":"features","content":" TOML Language Extensions # The TOML language is currently at version v1.0.0, but several new features have been discussed and merged, with ongoing discussions for v1.1.0.\nAmong the proposed features, some were deemed to have limited use cases, some faced implementation challenges in their proposed form, and others were not adopted at all.\nIn toml11, we have experimentally implemented a selection of these features. Please note that these features are supported in toml11 but are not supported by other parsers and are unlikely to be supported in the future.\nAdditionally, these features are disabled by default. To use them, you must explicitly set the corresponding feature flags to true. This design choice ensures that non-standard features are only used intentionally.\nSome of these features may eventually be merged into the TOML language itself. If a feature is officially adopted, the corresponding experimental implementation in toml11 may be removed in a minor version update after the official feature is implemented.\nnull # This feature allows the use of null as a value in TOML files.\na = null b = [ 1, 2, 3, null, 5] To enable this, set the ext_null_value flag in toml::spec to true.\nWhen parsed, it will be treated as toml::value_t::empty, similar to a default-constructed value. However, the location information within the file will be set.\nnull is parsed only in the context of values. Therefore, if null is used as a key, it will be interpreted as the string \u0026quot;null\u0026quot;, as it has been in the standard TOML.\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec; spec.ext_null_value = true; const auto v = toml::parse_str(\u0026#34;a = null\u0026#34;, spec); assert(v.at(\u0026#34;a\u0026#34;).is_empty()); assert(v.at(\u0026#34;a\u0026#34;).is(toml::value_t::empty)); return 0; } Hexadecimal Format for Floating-Point Numbers # This feature allows the use of hexadecimal format for floating-point numbers in TOML files.\na = 0x1.91eb851eb851fp+1 # 3.14 To enable this, set the ext_hex_float flag in toml::spec to true.\nThe format follows the printf specification for %a/%A.\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec; spec.ext_hex_float = true; const auto v = toml::parse_str(\u0026#34;a = 0x1.91eb851eb851fp+1\u0026#34;, spec); assert(v.at(\u0026#34;a\u0026#34;).is_floating()); assert(v.at(\u0026#34;a\u0026#34;).as_floating() == 3.14); return 0; } Suffixes for Integers and Floating-Point Numbers # This feature allows the use of suffixes for numbers in TOML files. It can be applied to integers and floating-point numbers in decimal notation.\nThis is particularly useful for displaying units.\na = 86_400_sec b = 3.1416_rad c = 10_μm However, these are purely suffixes and do not perform any unit conversion. If unit conversion is needed, users should implement it by referencing the suffix.\nTo enable this, set the ext_num_suffix flag in toml::spec to true.\nThe suffix must be separated from the number by an underscore (_).\nFor clarity, the suffix cannot start with a digit.\ndistance = 100_m # valid distance = 10_0m # invalid distance = 10_0_m # valid The suffix is stored as std::string suffix in the format information.\n#include \u0026lt;toml.hpp\u0026gt; int main() { toml::spec spec; spec.ext_hex_float = true; const auto v = toml::parse_str(\u0026#34;a = 86_400_sec\u0026#34;, spec); assert(v.at(\u0026#34;a\u0026#34;).is_integer()); assert(v.at(\u0026#34;a\u0026#34;).as_integer() == 86400); assert(v.at(\u0026#34;a\u0026#34;).as_integer_fmt().suffix == \u0026#34;sec\u0026#34;); return 0; } "},{"id":12,"href":"/toml11/docs/reference/color/","title":"color.hpp","section":"reference","content":" color.hpp # In color.hpp, functions related to colorizing error messages are defined.\nColors are specified using ANSI escape code. In terminals or other output destinations that do not support ANSI escape code, the output may become difficult to read.\nMacros # TOML11_COLORIZE_ERROR_MESSAGE # If this macro is defined during compilation (-DTOML11_COLORIZE_ERROR_MESASGE), error messages are colored by default.\nIf not defined, colors are not applied by default. You need to specify them using toml::color::enable().\nTOML11_USE_THREAD_LOCAL_COLORIZATION # If this macro is defined during compilation (-DTOML11_USE_THREAD_LOCAL_COLORIZATION), the colorization flag becomes thread_local. In this case, toml::color::enable() or toml::color::disable() will only affect the colorization flag in the thread that called it. This means that if you want to use a different setting from the default, you will need to set it again when starting a new thread. This makes toml::color::enable() and toml::color::disable() thread safe.\nBy default, the setting is global. When it is global, if one thread executes toml::color::enable(), the error messages will be colored in all threads. However, if one thread executes enable() or disable() while another executes enable(), disable() or should_color(), the result is undefined.\nFunctions # enable() # namespace toml { namespace color { void enable(); } // color } // toml Enables colorization using ANSI escape code.\nExample # #include \u0026lt;toml.hpp\u0026gt; int main() { toml::color::enable(); // All subsequent errors will be colored. const auto input = toml::parse(\u0026#34;input.toml\u0026#34;); return 0; } disable() # namespace toml { namespace color { void disable(); } // color } // toml Disables colorization using ANSI escape code.\nExample # #include \u0026lt;toml.hpp\u0026gt; int main() { toml::color::disable(); // All subsequent errors will not be colored. const auto input = toml::parse(\u0026#34;input.toml\u0026#34;); return 0; } should_color() # namespace toml { namespace color { bool should_color(); } // color } // toml Returns true if colorization is enabled, false otherwise.\nExample # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;colorized? : \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; toml::color::should_color() \u0026lt;\u0026lt; std::endl; return 0; } Manipulators # namespace toml { namespace color { std::ostream\u0026amp; reset (std::ostream\u0026amp;); std::ostream\u0026amp; bold (std::ostream\u0026amp;); std::ostream\u0026amp; grey (std::ostream\u0026amp;); std::ostream\u0026amp; gray (std::ostream\u0026amp;); std::ostream\u0026amp; red (std::ostream\u0026amp;); std::ostream\u0026amp; green (std::ostream\u0026amp;); std::ostream\u0026amp; yellow (std::ostream\u0026amp;); std::ostream\u0026amp; blue (std::ostream\u0026amp;); std::ostream\u0026amp; magenta(std::ostream\u0026amp;); std::ostream\u0026amp; cyan (std::ostream\u0026amp;); std::ostream\u0026amp; white (std::ostream\u0026amp;); } // color } // toml Colorizes the foreground with ANSI escape code.\nExample # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; toml::color::red \u0026lt;\u0026lt; \u0026#34;red!\u0026#34; \u0026lt;\u0026lt; toml::color::reset \u0026lt;\u0026lt; std::endl; return 0; } Related # error_info.hpp "},{"id":13,"href":"/toml11/docs/reference/comments/","title":"comments.hpp","section":"reference","content":" comments.hpp # In comments.hpp, comment containers are provided.\ntoml::preserve_comments # preserve_comments is a container that preserves comments.\nIt has all the member functions of std::vector\u0026lt;std::string\u0026gt;.\nComments are preserved as std::string. If the comment does not start with #, it will be prefixed with # during output. However, this prefixing is not done when adding comments to the container.\nSpaces are not automatically added, so if you want a space immediately after #, either start the comment with a space or pass the comment with #.\nnamespace toml { class preserve_comments; bool operator==(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator!=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026lt; (const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026lt;=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026gt; (const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026gt;=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); void swap(preserve_comments\u0026amp;, preserve_comments\u0026amp;); void swap(preserve_comments\u0026amp;, std::vector\u0026lt;std::string\u0026gt;\u0026amp;); void swap(std::vector\u0026lt;std::string\u0026gt;\u0026amp;, preserve_comments\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, const preserve_comments\u0026amp;); } //toml Member types # using container_type = std::vector\u0026lt;std::string\u0026gt;; using size_type = container_type::size_type; using difference_type = container_type::difference_type; using value_type = container_type::value_type; using reference = container_type::reference; using const_reference = container_type::const_reference; using pointer = container_type::pointer; using const_pointer = container_type::const_pointer; using iterator = container_type::iterator; using const_iterator = container_type::const_iterator; using reverse_iterator = container_type::reverse_iterator; using const_reverse_iterator = container_type::const_reverse_iterator; Member Functions # Default Constructor # preserve_comments() = default; Constructs an empty preserve_comments.\nCopy and Move Constructors # preserve_comments(preserve_comments const\u0026amp;) = default; preserve_comments(preserve_comments \u0026amp;\u0026amp;) = default; Constructs a preserve_comments by copying or moving.\nConstructor (std::vector\u0026lt;std::string\u0026gt;) # explicit preserve_comments(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; c); explicit preserve_comments(std::vector\u0026lt;std::string\u0026gt;\u0026amp;\u0026amp; c); Constructs a preserve_comments holding the contents of std::vector\u0026lt;std::string\u0026gt;.\nConstructor (discard_comments) # explicit preserve_comments(const discard_comments\u0026amp;); Constructs an empty preserve_comments.\nConstructor (Iterator) # template\u0026lt;typename InputIterator\u0026gt; preserve_comments(InputIterator first, InputIterator last); Constructs a preserve_comments from the range represented by InputIterator pointing to std::string.\nConstructor (std::initializer_list) # preserve_comments(std::initializer_list\u0026lt;std::string\u0026gt; x); Constructs a preserve_comments from the range represented by std::initializer_list\u0026lt;std::string\u0026gt;.\nConstructor (Size Specified) # explicit preserve_comments(size_type n); preserve_comments(size_type n, const std::string\u0026amp; x); Constructs a preserve_comments with n comments.\nIf a std::string is passed, it replicates that comment n times.\nDestructor # ~preserve_comments() = default; Destroys the preserve_comments.\noperator=(preserve_comments) # preserve_comments\u0026amp; operator=(preserve_comments const\u0026amp;) = default; preserve_comments\u0026amp; operator=(preserve_comments \u0026amp;\u0026amp;) = default; Assigns a preserve_comments by copying or moving.\noperator=(std::vector\u0026lt;std::string\u0026gt;) # preserve_comments\u0026amp; operator=(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; c); preserve_comments\u0026amp; operator=(std::vector\u0026lt;std::string\u0026gt;\u0026amp;\u0026amp; c); Assigns a std::vector\u0026lt;std::string\u0026gt; by copying or moving.\nassign # template\u0026lt;typename InputIterator\u0026gt; void assign(InputIterator first, InputIterator last); void assign(std::initializer_list\u0026lt;std::string\u0026gt; ini); void assign(size_type n, const std::string\u0026amp; val); The same as std::vector\u0026lt;std::string\u0026gt;::assign.\ninsert # iterator insert(const_iterator p, const std::string\u0026amp; x); iterator insert(const_iterator p, std::string\u0026amp;\u0026amp; x); iterator insert(const_iterator p, size_type n, const std::string\u0026amp; x); template\u0026lt;typename InputIterator\u0026gt; iterator insert(const_iterator p, InputIterator first, InputIterator last); iterator insert(const_iterator p, std::initializer_list\u0026lt;std::string\u0026gt; ini); The same as std::vector\u0026lt;std::string\u0026gt;::insert.\nemplace # template\u0026lt;typename ... Ts\u0026gt; iterator emplace(const_iterator p, Ts\u0026amp;\u0026amp; ... args); The same as std::vector\u0026lt;std::string\u0026gt;::emplace.\nerase # iterator erase(const_iterator pos); iterator erase(const_iterator first, const_iterator last); The same as std::vector\u0026lt;std::string\u0026gt;::erase.\nswap # void swap(preserve_comments\u0026amp; other); Swaps the comments.\npush_back # void push_back(const std::string\u0026amp; v); void push_back(std::string\u0026amp;\u0026amp; v); The same as std::vector\u0026lt;std::string\u0026gt;::push_back.\npop_back # void pop_back(); The same as std::vector\u0026lt;std::string\u0026gt;::pop_back.\nemplace_back # template\u0026lt;typename ... Ts\u0026gt; void emplace_back(Ts\u0026amp;\u0026amp; ... args); The same as std::vector\u0026lt;std::string\u0026gt;::emplace_back.\nclear # void clear(); The same as std::vector\u0026lt;std::string\u0026gt;::clear.\nsize # size_type size() const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::size.\nmax_size # size_type max_size() const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::max_size.\ncapacity # size_type capacity() const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::capacity.\nempty # bool empty() const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::empty.\nreserve # void reserve(size_type n); The same as std::vector\u0026lt;std::string\u0026gt;::reserve.\nresize # void resize(size_type n); void resize(size_type n, const std::string\u0026amp; c); The same as std::vector\u0026lt;std::string\u0026gt;::resize.\nshrink_to_fit # void shrink_to_fit(); The same as std::vector\u0026lt;std::string\u0026gt;::shrink_to_fit.\noperator[] # reference operator[](const size_type n) noexcept; const_reference operator[](const size_type n) const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::operator[].\nat # reference at(const size_type n) ; const_reference at(const size_type n) const; The same as std::vector\u0026lt;std::string\u0026gt;::at.\nfront # reference front() noexcept; const_reference front() const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::front.\nback # reference back() noexcept; const_reference back() const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::back.\ndata # pointer data() noexcept; const_pointer data() const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::data.\nbegin/end # iterator begin() noexcept; iterator end() noexcept; const_iterator begin() const noexcept; const_iterator end() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::begin/end.\nrbegin/rend # reverse_iterator rbegin() noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rbegin() const noexcept; const_reverse_iterator rend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; The same as std::vector\u0026lt;std::string\u0026gt;::rbegin/rend\nnon-member functions # Comparison operator # bool operator==(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator!=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026lt; (const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026lt;=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026gt; (const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); bool operator\u0026gt;=(const preserve_comments\u0026amp;, const preserve_comments\u0026amp;); It compares two preserve_comments in the same way as std::vector\u0026lt;std::string\u0026gt;.\nswap # void swap(preserve_comments\u0026amp;, preserve_comments\u0026amp;); void swap(preserve_comments\u0026amp;, std::vector\u0026lt;std::string\u0026gt;\u0026amp;); void swap(std::vector\u0026lt;std::string\u0026gt;\u0026amp;, preserve_comments\u0026amp;); Stream operator # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, const preserve_comments\u0026amp;); Outputs as TOML comments.\nIf the first character is not #, it adds #.\ntoml::discard_comments # discard_comments serves as a container for discarding comments.\nIt encompasses all the member functions of std::vector\u0026lt;std::string\u0026gt;, but invoking functions that modify the content has no effect, leaving it perpetually empty.\nnamespace toml { class discard_comments; bool operator==(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator!=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026lt; (const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026lt;=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026gt; (const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026gt;=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); void swap(discard_comments\u0026amp;, discard_comments\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, const discard_comments\u0026amp;); } //toml Member types # // container_type is not defined using size_type = std::size_t; using difference_type = std::ptrdiff_t; using value_type = std::string; using reference = std::string\u0026amp;; using const_reference = std::string const\u0026amp;; using pointer = std::string*; using const_pointer = std::string const*; using iterator = /* internal type: empty-iterator */ using const_iterator = /* internal type: empty-iterator */ using reverse_iterator = /* internal type: empty-iterator */ using const_reverse_iterator = /* internal type: empty-iterator */ Default Constructor # discard_comments() = default; Constructs an empty discard_comments.\nCopy / Move Constructor # discard_comments(discard_comments const\u0026amp;) = default; discard_comments(discard_comments \u0026amp;\u0026amp;) = default; Constructs a discard_comments by copying or moving.\nConstructor(std::vector\u0026lt;std::string\u0026gt;) # explicit discard_comments(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; c); explicit discard_comments(std::vector\u0026lt;std::string\u0026gt;\u0026amp;\u0026amp; c); Constructs an empty discard_comments. Arguments are ignored.\nConstructor(preserve_comments) # explicit discard_comments(const preserve_comments\u0026amp;); Constructs an empty discard_comments. Arguments are ignored.\nConstructor(Iterator) # template\u0026lt;typename InputIterator\u0026gt; discard_comments(InputIterator first, InputIterator last); Constructs an empty discard_comments. Arguments are ignored.\nConstructor(std::initializer_list) # discard_comments(std::initializer_list\u0026lt;std::string\u0026gt; x); Constructs an empty discard_comments. Arguments are ignored.\nConstructor(サイズ指定) # explicit discard_comments(size_type n); discard_comments(size_type n, const std::string\u0026amp; x); Constructs an empty discard_comments. Arguments are ignored.\nDestructor # ~discard_comments() = default; Destroys discard_comments.\noperator=(discard_comments) # discard_comments\u0026amp; operator=(discard_comments const\u0026amp;) = default; discard_comments\u0026amp; operator=(discard_comments \u0026amp;\u0026amp;) = default; Assigns discard_comments by copying or moving.\noperator=(std::vector\u0026lt;std::string\u0026gt;) # discard_comments\u0026amp; operator=(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; c); discard_comments\u0026amp; operator=(std::vector\u0026lt;std::string\u0026gt;\u0026amp;\u0026amp; c); Does nothing.\nassign # template\u0026lt;typename InputIterator\u0026gt; void assign(InputIterator first, InputIterator last); void assign(std::initializer_list\u0026lt;std::string\u0026gt; ini); void assign(size_type n, const std::string\u0026amp; val); Does nothing.\ninsert # iterator insert(const_iterator p, const std::string\u0026amp; x); iterator insert(const_iterator p, std::string\u0026amp;\u0026amp; x); iterator insert(const_iterator p, size_type n, const std::string\u0026amp; x); template\u0026lt;typename InputIterator\u0026gt; iterator insert(const_iterator p, InputIterator first, InputIterator last); iterator insert(const_iterator p, std::initializer_list\u0026lt;std::string\u0026gt; ini); Does nothing.\nemplace # template\u0026lt;typename ... Ts\u0026gt; iterator emplace(const_iterator p, Ts\u0026amp;\u0026amp; ... args); Does nothing.\nerase # iterator erase(const_iterator pos); iterator erase(const_iterator first, const_iterator last); Does nothing.\nswap # void swap(discard_comments\u0026amp; other); Swaps two discard_comments. Effectively it does nothing.\npush_back # void push_back(const std::string\u0026amp; v); void push_back(std::string\u0026amp;\u0026amp; v); Does nothing.\npop_back # void pop_back(); Does nothing.\nemplace_back # template\u0026lt;typename ... Ts\u0026gt; void emplace_back(Ts\u0026amp;\u0026amp; ... args); Does nothing.\nclear # void clear(); Does nothing.\nsize # size_type size() const noexcept; Returns 0.\nmax_size # size_type max_size() const noexcept; Returns 0.\ncapacity # size_type capacity() const noexcept; Returns 0.\nempty # bool empty() const noexcept; Returns true.\nreserve # void reserve(size_type n); Does nothing.\nresize # void resize(size_type n); void resize(size_type n, const std::string\u0026amp; c); Does nothing.\nshrink_to_fit # void shrink_to_fit(); Does nothing.\noperator[] # reference operator[](const size_type n) noexcept; const_reference operator[](const size_type n) const noexcept; Causes undefined behavior.\nat # reference at(const size_type n) ; const_reference at(const size_type n) const; Throws std::out_of_range.\nfront # reference front() noexcept; const_reference front() const noexcept; Causes undefined behavior.\nback # reference back() noexcept; const_reference back() const noexcept; Causes undefined behavior.\ndata # pointer data() noexcept; const_pointer data() const noexcept; Returns nullptr.\nbegin/end # iterator begin() noexcept; iterator end() noexcept; const_iterator begin() const noexcept; const_iterator end() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; Returns an internally defined empty-iterator.\nThe empty-iterator remains at the same value after incrementing or decrementing and all values are equivalent.\nAccessing the target of the empty-iterator always calls std::terminate.\nrbegin/rend # reverse_iterator rbegin() noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rbegin() const noexcept; const_reverse_iterator rend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; Returns an internally defined empty-iterator.\nThe empty-iterator remains at the same value after incrementing or decrementing and all values are equivalent.\nAccessing the target of the empty-iterator always calls std::terminate.\nnon-member functions # Comparison operator # bool operator==(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator!=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026lt; (const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026lt;=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026gt; (const discard_comments\u0026amp;, const discard_comments\u0026amp;); bool operator\u0026gt;=(const discard_comments\u0026amp;, const discard_comments\u0026amp;); All the instances of discard_comments are the same value. operator== returns true, operator=! returns false.\nswap # void swap(discard_comments\u0026amp;, discard_comments\u0026amp;); Swaps discard_comments. Effectively it does nothing.\nStream operator # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;, const discard_comments\u0026amp;); Outputs nothing.\nRelated # value.hpp "},{"id":14,"href":"/toml11/docs/reference/conversion/","title":"conversion.hpp","section":"reference","content":" conversion.hpp # Provides macros to automatically define conversion functions for supporting user-defined types with toml::get and toml::find.\nTOML11_DEFINE_CONVERSION_NON_INTRUSIVE(NAME, ...) Example # namespace foo { struct Foo { std::string s; double d; int i; }; } // foo TOML11_DEFINE_CONVERSION_NON_INTRUSIVE(foo::Foo, s, d, i) Related # from.hpp into.hpp "},{"id":15,"href":"/toml11/docs/reference/datetime/","title":"datetime.hpp","section":"reference","content":" datetime.hpp # Defines a class that stores date and time information used in TOML\u0026rsquo;s datetime.\nenum class month_t # Enum class to specify months.\nDue to its relationship with std::tm, local_date treats January as 0. To avoid confusion, month_t allows specification of months by their names.\nnamespace toml { enum class month_t : std::uint8_t { Jan = 0, Feb = 1, Mar = 2, Apr = 3, May = 4, Jun = 5, Jul = 6, Aug = 7, Sep = 8, Oct = 9, Nov = 10, Dec = 11 }; } local_date # local_date holds a date.\nyear represents the year in AD. For month, January is represented as 0 to align with std::tm. day holds the day of the month.\nnamespace toml { struct local_date { std::int16_t year; std::uint8_t month; std::uint8_t day; local_date() = default; ~local_date() = default; local_date(local_date const\u0026amp;) = default; local_date(local_date\u0026amp;\u0026amp;) = default; local_date\u0026amp; operator=(local_date const\u0026amp;) = default; local_date\u0026amp; operator=(local_date\u0026amp;\u0026amp;) = default; local_date(int y, month_t m, int d); explicit local_date(const std::tm\u0026amp; t); explicit local_date(const std::chrono::system_clock::time_point\u0026amp; tp); explicit local_date(const std::time_t t); operator std::chrono::system_clock::time_point() const; operator std::time_t() const; }; bool operator==(const local_date\u0026amp;, const local_date\u0026amp;); bool operator!=(const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026lt; (const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026lt;=(const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026gt; (const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026gt;=(const local_date\u0026amp;, const local_date\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_date\u0026amp; date); std::string to_string(const local_date\u0026amp; date); } Member Variables # year # std::int16_t year; Represents the year in AD. There\u0026rsquo;s no offset. 2024 is simply 2024.\nmonth # std::uint8_t month; Represents the month. To align with std::tm, January is 0, February is 1, and so on.\nTo avoid confusion, use month_t during construction.\nday # std::uint8_t day; Represents the day of the month. The first day is 1.\nMember Functions # Constructor # local_date() = default; Uses the default implementation.\nDestructor # ~local_date() = default; Uses the default implementation.\nCopy and Move Constructors # local_date(local_date const\u0026amp;) = default; local_date(local_date\u0026amp;\u0026amp;) = default; Uses the default implementations.\nCopy and Move Assignment Operators # local_date\u0026amp; operator=(local_date const\u0026amp;) = default; local_date\u0026amp; operator=(local_date\u0026amp;\u0026amp;) = default; Uses the default implementations.\nConstructor (int year, month_t month, int day) # local_date(int y, month_t m, int d); Constructs a local_date from the specified values.\nDoes not perform boundary checks.\nConstructor (std::tm) # local_date(const std::tm\u0026amp;); Constructs a local_date from the specified std::tm value.\nConstructor (std::chrono::system_clock::time_point) # local_date(const std::chrono::system_clock::time_point\u0026amp;); Constructs a local_date from the specified std::chrono::system_clock::time_point value.\nTime zone is determined by the environment.\nConstructor (std::time_t) # local_date(const std::time_t); Constructs a local_date from the specified std::time_t value.\nTime zone is determined by the environment.\noperator std::chrono::system_clock::time_point # operator std::chrono::system_clock::time_point() const; Converts to std::chrono::system_clock::time_point.\nTime zone is determined by the environment.\nTime is set to 0 hours and 0 minutes.\noperator std::time_t # operator std::time_t() const; Converts to std::time_t.\nTime zone is determined by the execution environment.\nTime is set to 0 hours and 0 minutes.\nNon-member Functions # Comparison Operators # bool operator==(const local_date\u0026amp;, const local_date\u0026amp;); bool operator!=(const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026lt; (const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026lt;=(const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026gt; (const local_date\u0026amp;, const local_date\u0026amp;); bool operator\u0026gt;=(const local_date\u0026amp;, const local_date\u0026amp;); Compares two dates.\nStream Operators # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_date\u0026amp; date); Outputs in the default TOML format.\nto_string # std::string to_string(const local_date\u0026amp; date); Converts to a string in the default TOML format.\nlocal_time # namespace toml { struct local_time { std::uint8_t hour; // [0, 23] std::uint8_t minute; // [0, 59] std::uint8_t second; // [0, 60] std::uint16_t millisecond; // [0, 999] std::uint16_t microsecond; // [0, 999] std::uint16_t nanosecond; // [0, 999] local_time(int h, int m, int s, int ms = 0, int us = 0, int ns = 0); explicit local_time(const std::tm\u0026amp; t); template\u0026lt;typename Rep, typename Period\u0026gt; explicit local_time(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; t); operator std::chrono::nanoseconds() const; local_time() = default; ~local_time() = default; local_time(local_time const\u0026amp;) = default; local_time(local_time\u0026amp;\u0026amp;) = default; local_time\u0026amp; operator=(local_time const\u0026amp;) = default; local_time\u0026amp; operator=(local_time\u0026amp;\u0026amp;) = default; }; bool operator==(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator!=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026lt; (const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026lt;=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026gt; (const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026gt;=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_time\u0026amp; time); std::string to_string(const local_time\u0026amp; time); } Member Values # hour # std::uint8_t hour; Represents the hour. Values range from 0 to 23.\nminute # std::uint8_t minute; // [0, 59] Represents the minute. Values range from 0 to 59.\nsecond # std::uint8_t second; // [0, 60] Represents the second. Values range from 0 to 60.\nmillisecond # std::uint16_t millisecond; // [0, 999] Represents the millisecond. Values range from 0 to 999.\nmicrosecond # std::uint16_t microsecond; // [0, 999] Represents the microsecond. Values range from 0 to 999.\nnanosecond # std::uint16_t nanosecond; // [0, 999] Represents the nanosecond. Values range from 0 to 999.\nMember Functions # default constructor # local_time() = default; Initializes all values to 0.\nconstructor (h, m, s, ms = 0, us = 0, ns = 0) # local_time(int h, int m, int s, int ms = 0, int us = 0, int ns = 0); Constructs using the specified time components.\nNo boundary checks are performed.\nconstructor(std::tm) # explicit local_time(const std::tm\u0026amp; t); Constructs using tm_hour, tm_min, and tm_sec from std::tm.\nSubseconds are initialized to 0.\nconstructor(std::chrono::duration) # template\u0026lt;typename Rep, typename Period\u0026gt; explicit local_time(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; t); Constructs as the time of day from 0 hours of the day specified by duration.\noperator std::chrono::nanoseconds # operator std::chrono::nanoseconds() const; Converts to std::chrono::nanoseconds.\nNon-member Functions # Comparison Operators # bool operator==(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator!=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026lt; (const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026lt;=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026gt; (const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); bool operator\u0026gt;=(const local_time\u0026amp; lhs, const local_time\u0026amp; rhs); Compares based on time values.\nStream Operator # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_time\u0026amp; time); Outputs in the default TOML format.\nto_string # std::string to_string(const local_time\u0026amp; time); Converts to a string in the default TOML format.\ntime_offset # namespace toml { struct time_offset { std::int8_t hour{0}; // [-12, 12] std::int8_t minute{0}; // [-59, 59] time_offset(int h, int m); operator std::chrono::minutes() const; time_offset() = default; ~time_offset() = default; time_offset(time_offset const\u0026amp;) = default; time_offset(time_offset\u0026amp;\u0026amp;) = default; time_offset\u0026amp; operator=(time_offset const\u0026amp;) = default; time_offset\u0026amp; operator=(time_offset\u0026amp;\u0026amp;) = default; }; bool operator==(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator!=(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026lt; (const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026lt;=(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026gt; (const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026gt;=(const time_offset\u0026amp;, const time_offset\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const time_offset\u0026amp; offset); std::string to_string(const time_offset\u0026amp; offset); } Member Variables # hour # std::int8_t hour{0}; // [-12, 12] Represents the hour offset, ranging from -12 to +12.\nminute # std::int8_t minute{0}; // [-59, 59] Represents the minute offset, ranging from -59 to +59.\nMember Functions # Constructor # time_offset(int h, int m); Constructs with given hours and minutes.\nNo boundary checking is performed.\noperator std::chrono::minutes # operator std::chrono::minutes() const; Converts to std::chrono::minutes.\nNon-member Functions # Comparison Operators # bool operator==(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator!=(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026lt; (const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026lt;=(const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026gt; (const time_offset\u0026amp;, const time_offset\u0026amp;); bool operator\u0026gt;=(const time_offset\u0026amp;, const time_offset\u0026amp;); Compares based on time length.\nStream Output Operator # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const time_offset\u0026amp;); Outputs in the default TOML format.\nto_string # std::string to_string(const time_offset\u0026amp;); Converts to a string in the default TOML format.\nlocal_datetime # namespace toml { struct local_datetime { local_date date; local_time time; local_datetime(local_date d, local_time t); explicit local_datetime(const std::tm\u0026amp; t); explicit local_datetime(const std::chrono::system_clock::time_point\u0026amp; tp); explicit local_datetime(const std::time_t t); operator std::chrono::system_clock::time_point() const; operator std::time_t() const; local_datetime() = default; ~local_datetime() = default; local_datetime(local_datetime const\u0026amp;) = default; local_datetime(local_datetime\u0026amp;\u0026amp;) = default; local_datetime\u0026amp; operator=(local_datetime const\u0026amp;) = default; local_datetime\u0026amp; operator=(local_datetime\u0026amp;\u0026amp;) = default; }; bool operator==(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator!=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026lt; (const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026lt;=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026gt; (const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026gt;=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_datetime\u0026amp; dt); std::string to_string(const local_datetime\u0026amp; dt); } Member Variables # local_date date # local_date date; Stores the date component data.\nlocal_time time # local_time time; Stores the time component data.\nMember Functions # Default Constructor # Constructs both date and time with default values.\nConstructor (local_date, local_time) # Constructs with the specified date and time.\nConstructor (std::tm) # Constructs from std::tm.\nThe timezone is selected based on the execution environment.\nConstructor (std::chrono::system_clock::time_point) # Constructs from std::chrono::system_clock::time_point.\nThe timezone is selected based on the execution environment.\nConstructor (std::time_t) # Constructs from std::time_t.\nThe timezone is selected based on the execution environment.\noperator std::chrono::system_clock::time_point # Converts to std::chrono::system_clock::time_point.\noperator std::time_t # Converts to std::time_t.\nNon-member Functions # Comparison Operators # bool operator==(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator!=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026lt; (const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026lt;=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026gt; (const local_datetime\u0026amp;, const local_datetime\u0026amp;); bool operator\u0026gt;=(const local_datetime\u0026amp;, const local_datetime\u0026amp;); Compares based on chronological order.\nStream Output Operator # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const local_datetime\u0026amp;); Outputs in the default TOML format.\nto_string # std::string to_string(const local_datetime\u0026amp;); Converts to a string in the default TOML format.\noffset_datetime # namespace toml { struct offset_datetime { local_date date; local_time time; time_offset offset; offset_datetime(local_date d, local_time t, time_offset o); offset_datetime(const local_datetime\u0026amp; dt, time_offset o); explicit offset_datetime(const local_datetime\u0026amp; ld); explicit offset_datetime(const std::chrono::system_clock::time_point\u0026amp; tp); explicit offset_datetime(const std::time_t\u0026amp; t); explicit offset_datetime(const std::tm\u0026amp; t); operator std::chrono::system_clock::time_point() const; operator std::time_t() const; offset_datetime() = default; ~offset_datetime() = default; offset_datetime(offset_datetime const\u0026amp;) = default; offset_datetime(offset_datetime\u0026amp;\u0026amp;) = default; offset_datetime\u0026amp; operator=(offset_datetime const\u0026amp;) = default; offset_datetime\u0026amp; operator=(offset_datetime\u0026amp;\u0026amp;) = default; }; bool operator==(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator!=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026lt; (const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026lt;=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026gt; (const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026gt;=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const offset_datetime\u0026amp; dt); std::string to_string(const offset_datetime\u0026amp; dt); } Member Variables # date # local_date date; Stores the date component.\ntime # local_time time; Stores the time component.\noffset # time_offset offset; Stores the offset component.\nMember Functions # Default Constructor # Constructs date, time, and offset with default values.\nConstructor (local_date, local_time, time_offset) # Constructs with the specified date, time, and offset.\nConstructor (local_datetime, time_offset) # Constructs from local_datetime and offset.\nConstructor (std::tm) # Constructs from std::tm.\nThe timezone is UTC (00:00).\nConstructor (std::chrono::system_clock::time_point) # Constructs from std::chrono::system_clock::time_point.\nThe timezone is UTC (00:00).\nConstructor (std::time_t) # Constructs from std::time_t.\nThe timezone is UTC (00:00).\noperator std::chrono::system_clock::time_point # Converts to std::chrono::system_clock::time_point.\nThe timezone is UTC (00:00).\noperator std::time_t # Converts to std::time_t.\nThe timezone is UTC (00:00).\nNon-member Functions # Comparison Operators # bool operator==(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator!=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026lt; (const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026lt;=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026gt; (const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); bool operator\u0026gt;=(const offset_datetime\u0026amp;, const offset_datetime\u0026amp;); Compares based on chronological order.\nIf dates are the same, compares based on timezone order.\nStream Output Operator # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const offset_datetime\u0026amp;); Outputs in the default TOML format.\nto_string # std::string to_string(const offset_datetime\u0026amp;); Converts to a string in the default TOML format.\n"},{"id":16,"href":"/toml11/docs/reference/error_info/","title":"error_info.hpp","section":"reference","content":" error_info.hpp # In error_info.hpp, definitions for error_info and functions to format it are provided.\ntoml::error_info # namespace toml { struct error_info { error_info(std::string t, source_location l, std::string m, std::string s = \u0026#34;\u0026#34;); error_info(std::string t, std::vector\u0026lt;std::pair\u0026lt;source_location, std::string\u0026gt;\u0026gt; l, std::string s = \u0026#34;\u0026#34;); std::string const\u0026amp; title() const noexcept; std::string \u0026amp; title() noexcept; std::vector\u0026lt;std::pair\u0026lt;source_location, std::string\u0026gt;\u0026gt; const\u0026amp; locations() const noexcept; void add_locations(source_location loc, std::string msg) noexcept; std::string const\u0026amp; suffix() const noexcept; std::string \u0026amp; suffix() noexcept; }; template\u0026lt;typename ... Ts\u0026gt; error_info make_error_info( std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); std::string format_error(const std::string\u0026amp; errkind, const error_info\u0026amp; err); std::string format_error(const error_info\u0026amp; err); template\u0026lt;typename ... Ts\u0026gt; std::string format_error(std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const error_info\u0026amp; e); } Member Functions # Constructor (title, loc, msg, suffix) # Constructs error_info with specified title, location information loc, message msg, and optional suffix.\nsuffix defaults to empty.\nConstructor (title, [{loc, msg}, ...], suffix) # Constructs error_info with specified title, an array of location-message pairs [{loc, msg}, ...], and optional suffix.\nsuffix defaults to empty.\nstd::string title() # Returns the title of the error message.\nstd::vector\u0026lt;std::pair\u0026lt;source_location, std::string\u0026gt;\u0026gt; locations() # Returns the list of locations where errors occurred along with their respective messages.\nMultiple locations can be specified.\nstd::string suffix() # Returns the suffix message to display at the end, providing hints or additional information.\nNon-Member Functions # make_error_info # template\u0026lt;typename ... Ts\u0026gt; error_info make_error_info( std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); Creates a new error_info.\nMust be followed by a msg related to source_location or basic_value.\nOverloads are added in value.hpp when passing toml::basic_value instead of source_location.\nPossible to pass suffix at the end.\nformat_error # Formats error_info as follows:\n{title} --\u0026gt; {locations().at(0).first.file_name()} | 1 | {locations().at(0).first.line()} | ^-- {locations().at(0).second} | 2 | {locations().at(1).first.line()} | ^-- {locations().at(1).second} {suffix} If file names differ between two source_location, the file name is displayed again.\nstd::string format_error(const std::string\u0026amp; errkind, const error_info\u0026amp; err); std::string format_error(const error_info\u0026amp; err); Formats error_info.\nIf errkind is not provided, a red-bold [error] prefix is added before title.\nIf errkind is provided (including an empty string), it replaces [error].\nnamespace toml { template\u0026lt;typename ... Ts\u0026gt; std::string format_error(std::string title, source_location loc, std::string msg, Ts\u0026amp;\u0026amp; ... tail); } // toml Returns a formatted string using format_error for error_info created with make_error_info.\nOverloads are added in value.hpp when passing toml::basic_value instead of source_location.\nStream Operator # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const error_info\u0026amp; e); Calls format_error(e) and outputs it.\nRelated # color.hpp parser.hpp source_location.hpp "},{"id":17,"href":"/toml11/docs/reference/exception/","title":"exception.hpp","section":"reference","content":" exception.hpp # toml::exception # Base class for exception types defined in toml11.\nnamespace toml { struct exception : public std::exception { public: virtual ~exception() noexcept override = default; virtual const char* what() const noexcept override {return \u0026#34;\u0026#34;;} }; } // toml Member Functions # Destructor # virtual ~exception() noexcept override = default; Override when derived.\nwhat # virtual const char* what() const noexcept override {return \u0026#34;\u0026#34;;} Returns the error message. Override when derived.\n"},{"id":18,"href":"/toml11/docs/reference/find/","title":"find.hpp","section":"reference","content":" find.hpp # This function searches for a value in a toml::value and performs type conversion if necessary.\ntoml::value can change the type it stores, and toml::find accommodates these types. Technically, all functions use toml::basic_value\u0026lt;TC\u0026gt;. However, for simplicity, we refer to it as toml::value in explanations unless a distinction is necessary. In the documentation, if the template parameter TC changes the type, assume that types like toml::value::integer_type will also change accordingly. toml::find # Overview # toml::find uses template arguments for the type you want to retrieve and function arguments for the key of the value you want to find.\ntemplate\u0026lt;typename T, typename TC, typename ... Keys\u0026gt; T find(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, Keys ... keys); The supported types for T and the behavior of the conversion are the same as for toml::get.\nIf T is not specified, a toml::value will be returned.\nKeys can be of type toml::value::key_type or std::size_t. When multiple keys are provided, the function will search recursively through sub-tables or arrays. If a toml::value::key_type is given, toml::value is interpreted as a toml::table; if a std::size_t is given, toml::value is interpreted as a toml::array.\nNote on Recursive Search # TOML allows for bare keys as well as quoted keys (enclosed in \u0026quot; or '). Using a quoted key like \u0026quot;foo.bar\u0026quot; = \u0026quot;baz\u0026quot; means no sub-table is constructed, and the key is \u0026quot;foo.bar\u0026quot;. To handle such patterns, toml11 does not split keys containing . and searches using the full string.\nConsider the following TOML file:\n[foo] [foo.bar] baz = \u0026#34;hoge\u0026#34; [\u0026#34;foo.bar\u0026#34;] baz = \u0026#34;fuga\u0026#34; The corresponding usage of toml::find is shown below:\nconst auto input = toml::parse(\u0026#34;input.toml\u0026#34;); const auto baz1 = toml::find\u0026lt;std::string\u0026gt;(input, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;); // hoge const auto baz2 = toml::find\u0026lt;std::string\u0026gt;(input, \u0026#34;foo.bar\u0026#34;, \u0026#34;baz\u0026#34;); // fuga cf. toml.io/en/v1.0.0#keys\ntoml::find(value, key) # Searches for key in value as if value were a toml::table, then converts using toml::get.\ntemplate\u0026lt;typename T, typename TC\u0026gt; /* Equivalent to toml::get\u0026lt;T\u0026gt;(const value\u0026amp;) */ find( const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); template\u0026lt;typename T, typename TC\u0026gt; /* Equivalent to toml::get\u0026lt;T\u0026gt;(value\u0026amp;) */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); template\u0026lt;typename T, typename TC\u0026gt; /* Equivalent to toml::get\u0026lt;T\u0026gt;(value\u0026amp;\u0026amp;) */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); If T is not specified, the function returns a toml::value without conversion.\ntemplate\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; const\u0026amp; find( basic_value\u0026lt;TC\u0026gt; const\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt;\u0026amp; find( basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; find( basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; ky); Exceptions # If the toml::value does not contain a table, a toml::type_error is thrown.\nIf the contained table does not have the specified element, a std::out_of_range is thrown.\nIf the specified element cannot be converted to T (i.e., toml::get fails), a toml::type_error is thrown.\ntoml::find(value, index) # Accesses the index-th element of value as if value were a toml::array, then converts using toml::get.\ntemplate\u0026lt;typename T, typename TC\u0026gt; /* Equivalent to toml::get\u0026lt;T\u0026gt;(const value\u0026amp;) */ find( const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const std::size_t index); template\u0026lt;typename T, typename TC\u0026gt; /* Equivalent to toml::get\u0026lt;T\u0026gt;(value\u0026amp;) */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const std::size_t index); template\u0026lt;typename T, typename TC\u0026gt; /* Equivalent to toml::get\u0026lt;T\u0026gt;(value\u0026amp;\u0026amp;) */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const std::size_t index); If T is not specified, the function returns a toml::value without conversion.\ntemplate\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; const\u0026amp; find(basic_value\u0026lt;TC\u0026gt; const\u0026amp; v, const std::size_t ky); template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt;\u0026amp; find(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const std::size_t ky); template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; find(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const std::size_t ky); Exceptions # If the toml::value does not contain an array, a toml::type_error is thrown.\nIf the contained array does not have the specified number of elements, a std::out_of_range is thrown.\nIf the specified element cannot be converted to T (i.e., toml::get fails), a toml::type_error is thrown.\ntoml::find(value, keys...) # template\u0026lt;typename T, typename TC, typename K1, typename K2, typename ... Ks\u0026gt; /* Equivalent to toml::get\u0026lt;T\u0026gt;(const value\u0026amp;) */ find( const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K1\u0026amp; k1, const K2\u0026amp; k2, const Ks\u0026amp; ... ks); template\u0026lt;typename T, typename TC, typename K1, typename K2, typename ... Ks\u0026gt; /* Equivalent to toml::get\u0026lt;T\u0026gt;(value\u0026amp;) */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K1\u0026amp; k1, const K2\u0026amp; k2, const Ks\u0026amp; ... ks); template\u0026lt;typename T, typename TC, typename K1, typename K2, typename ... Ks\u0026gt; /* Equivalent to toml::get\u0026lt;T\u0026gt;(value\u0026amp;\u0026amp;) */ find( basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, const K1\u0026amp; k1, const K2\u0026amp; k2, const Ks\u0026amp; ... ks); This function calls toml::find recursively.\nThe failure conditions and the exceptions thrown are the same as those for toml::find.\ntoml::find_or(value, key, fallback) # template\u0026lt;typename T, typename TC, typename Key\u0026gt; T find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const Key\u0026amp; key, T\u0026amp;\u0026amp; opt); The find_or function takes a default value to avoid throwing an exception when the search fails.\nThe default value must be of the same type as the return type T. Therefore, unlike toml::find\u0026lt;T\u0026gt;, find_or infers the type T.\nYou can specify T explicitly with find_or\u0026lt;T\u0026gt;, but this always returns a new value. To obtain a reference, do not specify T.\nWhen T is basic_value # template\u0026lt;typename TC, typename K\u0026gt; basic_value\u0026lt;TC\u0026gt;\u0026amp; find_or(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, basic_value\u0026lt;TC\u0026gt;\u0026amp; opt) noexcept template\u0026lt;typename TC, typename K\u0026gt; basic_value\u0026lt;TC\u0026gt; const\u0026amp; find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, const basic_value\u0026lt;TC\u0026gt;\u0026amp; opt) noexcept Searches for the corresponding value and returns it without conversion. Because no conversion is needed, a reference can be returned.\nIf the value is not found, the default value is returned.\nWhen T is toml::value::{some_type} # template\u0026lt;typename T, typename TC, typename K\u0026gt; T\u0026amp; find_or(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, T\u0026amp; opt) noexcept template\u0026lt;typename T, typename TC, typename K\u0026gt; T const\u0026amp; find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, const T\u0026amp; opt) noexcept Searches for the corresponding value and returns it without conversion. Because no conversion is needed, a reference can be returned.\nIf the value is not found or if a different type is stored, the default value is returned.\nWhen T is const char* # template\u0026lt;typename T, typename TC, typename K\u0026gt; T find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, T opt) Searches for the corresponding value and returns it as a std::string.\nSince the fallback is constructed from const char* to std::string, a reference cannot be returned in case of failure.\nWhen T is any other type # template\u0026lt;typename T, typename TC, typename K\u0026gt; T find_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const K\u0026amp; key, T opt); Searches for the corresponding value and converts it to T before returning it.\nBecause conversion is performed, a reference cannot be returned.\nWhen multiple keys are provided # template\u0026lt;typename Value, typename K1, typename K2, typename K3, typename ... Ks\u0026gt; auto find_or(Value\u0026amp;\u0026amp; v, const K1\u0026amp; k1, const K2\u0026amp; k2, K3\u0026amp;\u0026amp; k3, Ks\u0026amp;\u0026amp; ... keys) noexcept -\u0026gt; decltype(find_or(v, k2, std::forward\u0026lt;K3\u0026gt;(k3), std::forward\u0026lt;Ks\u0026gt;(keys)...)) Interprets the last element in the key sequence as the default value and applies find_or recursively.\nIf the inferred type of T is toml::value or toml::value::some_type, a reference can be returned.\nIf T is explicitly specified, conversion is always performed.\nRelated # get.hpp value.hpp "},{"id":19,"href":"/toml11/docs/reference/format/","title":"format.hpp","section":"reference","content":" format.hpp # Defines structures and enumerations related to formatting information for toml::value.\nindent_char # An enumeration representing the indentation character choice.\nenum class indent_char : std::uint8_t { space, // use space tab, // use tab none // no indent }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const indent_char\u0026amp; c); std::string to_string(const indent_char); Choosing none means no indentation is used, regardless of the value in super tables.\nIf both space and tab are specified within the serializable value, the behavior is unspecified; typically, the unspecified indentation character appears.\nboolean_format_info # Formatting information for boolean.\nstruct boolean_format_info {}; bool operator==(const boolean_format_info\u0026amp;, const boolean_format_info\u0026amp;) noexcept; bool operator!=(const boolean_format_info\u0026amp;, const boolean_format_info\u0026amp;) noexcept; There is only one way to format boolean, so no configurable values are provided.\ninteger_format # enum class integer_format : std::uint8_t { dec = 0, bin = 1, oct = 2, hex = 3, }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const integer_format f); std::string to_string(const integer_format); Specifies the radix of an integer.\ninteger_format_info # struct integer_format_info { integer_format fmt = integer_format::dec; bool uppercase = true; // use uppercase letters std::size_t width = 0; // minimal width (may exceed) std::size_t spacer = 0; // position of `_` (if 0, no spacer) std::string suffix = \u0026#34;\u0026#34;; // _suffix (library extension) }; bool operator==(const integer_format_info\u0026amp;, const integer_format_info\u0026amp;) noexcept; bool operator!=(const integer_format_info\u0026amp;, const integer_format_info\u0026amp;) noexcept; example # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value v(0xDEADBEEF); std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 3735928559 v.as_integer_fmt().uppercase = true; v.as_integer_fmt().fmt = toml::integer_format::hex; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 0xDEADBEEF v.as_integer_fmt().spacer = 4; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 0xDEAD_BEEF v.as_integer_fmt().spacer = 8; v.as_integer_fmt().width = 16; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 0x00000000_DEADBEEF } Member Variables # integer_format fmt # Specifies the radix.\nbool uppercase # Uses uppercase letters when formatted as a hexadecimal integer.\nstd::size_t width # Specifies the minimum width. The formatted value may exceed this width.\nFor values smaller than this width, if integer_format::dec, no effect. Otherwise, leading zeros are added.\nstd::size_t spacer # Specifies the width at which underscores _ are inserted.\nIf 3, formatted as 1_234_567. If 4, formatted as 0xdead_beef. If 0, no underscores are inserted. Irregular widths are not allowed.\nstd::string suffix # Stores the suffix when spec::ext_num_suffix of toml11 extension is true.\ncf. spec.hpp\nfloating_format # enum class floating_format : std::uint8_t { defaultfloat = 0, fixed = 1, // does not include exponential part scientific = 2, // always include exponential part hex = 3 // hexfloat extension }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const floating_format f); std::string to_string(const floating_format); Specifies the formatting style for floating numbers. Corresponds to std::defaultfloat, std::fixed, std::scientific, std::hexfloat.\nhexfloat is available only if toml::spec::ext_hex_float is true.\ncf. spec.hpp\nfloating_format_info # struct floating_format_info { floating_format fmt = floating_format::defaultfloat; std::size_t prec = 0; // precision (if 0, use the default) std::string suffix = \u0026#34;\u0026#34;; // 1.0e+2_suffix (library extension) }; bool operator==(const floating_format_info\u0026amp;, const floating_format_info\u0026amp;) noexcept; bool operator!=(const floating_format_info\u0026amp;, const floating_format_info\u0026amp;) noexcept; example # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value pi(3.141592653589793); std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; // 3.14159 pi.as_floating_fmt().fmt = toml::floating_format::fixed; std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; // 3.141593 pi.as_floating_fmt().prec = 16; std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; // 3.1415926535897931 toml::value na(6.02214076e+23); std::cout \u0026lt;\u0026lt; na \u0026lt;\u0026lt; std::endl; // 6.022e+23 na.as_floating_fmt().fmt = toml::floating_format::fixed; std::cout \u0026lt;\u0026lt; na \u0026lt;\u0026lt; std::endl; // 602214075999999987023872.000000 na.as_floating_fmt().fmt = toml::floating_format::scientific; std::cout \u0026lt;\u0026lt; na \u0026lt;\u0026lt; std::endl; // 6.022141e+23 na.as_floating_fmt().prec = 16; std::cout \u0026lt;\u0026lt; na \u0026lt;\u0026lt; std::endl; // 6.0221407599999999e+23 return 0; } Member Variables # floating_format fmt # Specifies the formatting style.\nstd::size_t prec # Specifies the precision after the decimal point.\nstd::string suffix # Stores the suffix when spec::ext_num_suffix of toml11 extension is true.\ncf. spec.hpp\nstring_format # enum class string_format : std::uint8_t { basic = 0, literal = 1, multiline_basic = 2, multiline_literal = 3 }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const string_format f); std::string to_string(const string_format); Specifies the formatting style for strings.\nstring_format_info # struct string_format_info { string_format fmt = string_format::basic; bool start_with_newline = false; }; bool operator==(const string_format_info\u0026amp;, const string_format_info\u0026amp;) noexcept; bool operator!=(const string_format_info\u0026amp;, const string_format_info\u0026amp;) noexcept; example # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value s(\u0026#34;foo\u0026#34;); std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; // \u0026#34;foo\u0026#34; s.as_string_fmt().fmt = toml::string_format::literal; std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; // \u0026#39;foo\u0026#39; s.as_string_fmt().fmt = toml::string_format::multiline_basic; std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; // \u0026#34;\u0026#34;\u0026#34;foo\u0026#34;\u0026#34;\u0026#34; s.as_string_fmt().fmt = toml::string_format::multiline_literal; std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; // \u0026#39;\u0026#39;\u0026#39;foo\u0026#39;\u0026#39;\u0026#39; toml::value multiline(\u0026#34;foo\\nbar\u0026#34;); std::cout \u0026lt;\u0026lt; multiline \u0026lt;\u0026lt; std::endl; // \u0026#34;foo\\nbar\u0026#34; multiline.as_string_fmt().fmt = toml::string_format::multiline_basic; std::cout \u0026lt;\u0026lt; multiline \u0026lt;\u0026lt; std::endl; // \u0026#34;\u0026#34;\u0026#34;foo // bar\u0026#34;\u0026#34;\u0026#34; multiline.as_string_fmt().start_with_newline = true; std::cout \u0026lt;\u0026lt; multiline \u0026lt;\u0026lt; std::endl; // \u0026#34;\u0026#34;\u0026#34; // foo // bar\u0026#34;\u0026#34;\u0026#34; multiline.as_string_fmt().fmt = toml::string_format::multiline_literal; std::cout \u0026lt;\u0026lt; multiline \u0026lt;\u0026lt; std::endl; // \u0026#39;\u0026#39;\u0026#39; // foo // bar\u0026#39;\u0026#39;\u0026#39; return 0; } Member Variables # string_format fmt # Specifies the formatting information for strings.\nbool start_with_newline # For multiline_basic or multiline_literal, specifies whether to include a newline after the initial \u0026quot;\u0026quot;\u0026quot; or '''.\ndatetime_delimiter_kind # enum class datetime_delimiter_kind : std::uint8_t { upper_T = 0, lower_t = 1, space = 2, }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const datetime_delimiter_kind d); std::string to_string(const datetime_delimiter_kind); Specifies the delimiter used between date and time in datetime.\nPossible options include T, t, and a space .\noffset_datetime_format_info # struct offset_datetime_format_info { datetime_delimiter_kind delimiter = datetime_delimiter_kind::upper_T; bool has_seconds = true; std::size_t subsecond_precision = 6; // [us] }; bool operator==(const offset_datetime_format_info\u0026amp;, const offset_datetime_format_info\u0026amp;) noexcept; bool operator!=(const offset_datetime_format_info\u0026amp;, const offset_datetime_format_info\u0026amp;) noexcept; example # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value v(toml::offset_datetime( toml::local_date(2025, toml::month_t::Mar, 29), toml::local_time(1, 23, 45, /*ms=*/678, /*us=*/901, /*ns=*/234), toml::time_offset(9, 0) )); std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 2025-03-29T01:23:45.678901+09:00 v.as_offset_datetime_fmt().subsecond_precision = 9; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 2025-03-29T01:23:45.678901234+09:00 v.as_offset_datetime_fmt().has_seconds = false; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 2025-03-29T01:23+09:00 v.as_offset_datetime_fmt().delimiter = toml::datetime_delimiter_kind::space; std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; // 2025-03-29 01:23+09:00 return 0; } Member Variables # datetime_delimiter_kind delimiter # Specifies the delimiter to use.\nbool has_seconds # Specifies whether to omit seconds.\nstd::size_t subsecond_precision # Specifies how many digits to output for subseconds.\nlocal_datetime_format_info # struct local_datetime_format_info { datetime_delimiter_kind delimiter = datetime_delimiter_kind::upper_T; bool has_seconds = true; std::size_t subsecond_precision = 6; // [us] }; bool operator==(const local_datetime_format_info\u0026amp;, const local_datetime_format_info\u0026amp;) noexcept; bool operator!=(const local_datetime_format_info\u0026amp;, const local_datetime_format_info\u0026amp;) noexcept; Member Variables # datetime_delimiter_kind delimiter # Specifies the delimiter to use.\nbool has_seconds # Specifies whether to omit seconds.\nstd::size_t subsecond_precision # Specifies how many digits to output for subseconds.\nlocal_date_format_info # struct local_date_format_info { // nothing, for now }; bool operator==(const local_date_format_info\u0026amp;, const local_date_format_info\u0026amp;) noexcept; bool operator!=(const local_date_format_info\u0026amp;, const local_date_format_info\u0026amp;) noexcept; No formatting parameters are specified for local_date.\nlocal_time_format_info # struct local_time_format_info { bool has_seconds = true; std::size_t subsecond_precision = 6; // [us] }; bool operator==(const local_time_format_info\u0026amp;, const local_time_format_info\u0026amp;) noexcept; bool operator!=(const local_time_format_info\u0026amp;, const local_time_format_info\u0026amp;) noexcept; Member Variables # bool has_seconds # Specifies whether to omit seconds.\nstd::size_t subsecond_precision # Specifies how many digits to output for subseconds.\narray_format # enum class array_format : std::uint8_t { default_format = 0, oneline = 1, multiline = 2, array_of_tables = 3 // [[format.in.this.way]] }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const array_format f); std::string to_string(const array_format); default_format Automatically selects the appropriate format. Longer arrays may span multiple lines. oneline Formats all elements in a single line. multiline Outputs each element on its own line. array_of_tables Formats in the [[array.of.tables]] style. Cannot contain elements other than table. array_format_info # struct array_format_info { array_format fmt = array_format::default_format; indent_char indent_type = indent_char::space; std::int32_t body_indent = 4; // indent in case of multiline std::int32_t closing_indent = 0; // indent of `]` }; bool operator==(const array_format_info\u0026amp;, const array_format_info\u0026amp;) noexcept; bool operator!=(const array_format_info\u0026amp;, const array_format_info\u0026amp;) noexcept; example # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value a(toml::array{ 3, 1, 4 }); a.as_array_fmt().fmt = toml::array_format::oneline; std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; // a = [3, 1, 4] a.as_array_fmt().fmt = toml::array_format::multiline; std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; // a = [ // 3, // 1, // 4, // ] a.as_array_fmt().body_indent = 4; a.as_array_fmt().closing_indent = 2; std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; // a = [ // 3, // 1, // 4, // ] return 0; } Member Variables # array_format fmt # Specifies the format style.\nindent_char indent_type # Selects the type of character used for indentation.\nstd::int32_t body_indent # Specifies the number of characters to indent before each element in array_format::multiline.\nstd::int32_t closing_indent # Specifies the number of characters to indent before the closing bracket ] in array_format::multiline.\ntable_format # enum class table_format : std::uint8_t { multiline = 0, // [foo] \\n bar = \u0026#34;baz\u0026#34; oneline = 1, // foo = {bar = \u0026#34;baz\u0026#34;} dotted = 2, // foo.bar = \u0026#34;baz\u0026#34; multiline_oneline = 3, // foo = { \\n bar = \u0026#34;baz\u0026#34; \\n } implicit = 4 // [x] defined by [x.y.z]. skip in serializer. }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const table_format f); std::string to_string(const table_format); multiline Formats as a multiline normal table. oneline Formats as an inline table. dotted Formats in the form of a.b.c = \u0026quot;d\u0026quot;. multiline_oneline Formats as a multiline inline table with line breaks. Available from TOML v1.1.0 onwards. cf. spec.hpp implicit Skips implicit definitions like [x.y.z.w], leaving [x], [x.y], [x.y.z] as implicit. According to TOML syntax, dotted table can have sub-tables:\n[fruit] apple.color = \u0026#34;red\u0026#34; apple.taste.sweet = true # [fruit.apple] # INVALID # [fruit.apple.taste] # INVALID [fruit.apple.texture] # you can add sub-tables smooth = true toml11 currently does not support this format. Sub-tables under a dotted table would all be dotted, and tables are forced into inline table format.\ntable_format_info # struct table_format_info { table_format fmt = table_format::multiline; indent_char indent_type = indent_char::space; std::int32_t body_indent = 0; // indent of values std::int32_t name_indent = 0; // indent of [table] std::int32_t closing_indent = 0; // in case of {inline-table} }; bool operator==(const table_format_info\u0026amp;, const table_format_info\u0026amp;) noexcept; bool operator!=(const table_format_info\u0026amp;, const table_format_info\u0026amp;) noexcept; example # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { toml::value t(toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;pi\u0026#34;, 3.14}, {\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;}, { \u0026#34;table\u0026#34;, toml::table{ {\u0026#34;a\u0026#34;, 42}, {\u0026#34;pi\u0026#34;, 3.14}, {\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;} } }, }); std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; // pi = 3.14 // foo = \u0026#34;bar\u0026#34; // a = 42 // // [table] // pi = 3.14 // foo = \u0026#34;bar\u0026#34; // a = 42 // root table cannot be dotted. // t.as_table_fmt().fmt = toml::table_format::dotted; t.at(\u0026#34;table\u0026#34;).as_table_fmt().fmt = toml::table_format::dotted; std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; // table.pi = 3.14 // table.foo = \u0026#34;bar\u0026#34; // table.a = 42 // pi = 3.14 // foo = \u0026#34;bar\u0026#34; // a = 42 t.as_table_fmt().fmt = toml::table_format::oneline; std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; // {table = {pi = 3.14, foo = \u0026#34;bar\u0026#34;, a = 42}, pi = 3.14, foo = \u0026#34;bar\u0026#34;, a = 42} return 0; } Member Variables # table_format fmt # Specifies the formatting method.\nindent_char indent_type # Specifies the character used for indentation.\nstd::int32_t body_indent # Specifies the width of indentation before keys.\nThe indentation width of the super table is not added.\nstd::int32_t name_indent # Specifies the indentation of keys in [table] format.\nThe indentation width of the super table is not added.\nstd::int32_t closing_indent # Specifies the indentation width before the closing brace } in the case of multiline_oneline.\n"},{"id":20,"href":"/toml11/docs/reference/from/","title":"from.hpp","section":"reference","content":" from.hpp # Defines a struct used for conversion from toml::value in toml::get and toml::find.\nYou can achieve the same functionality by adding a from_toml member function, but for classes where you cannot add member functions, use from\u0026lt;T\u0026gt;.\nThis file does not provide specific implementations. Please specialize this struct when using.\nnamespace toml { template\u0026lt;typename T\u0026gt; struct from; } // toml Example # namespace extlib { struct foo { int a; std::string b; }; } // extlib #include \u0026lt;toml11/from.hpp\u0026gt; namespace toml { template\u0026lt;\u0026gt; struct from\u0026lt;extlib::foo\u0026gt; { template\u0026lt;typename TC\u0026gt; static extlib::foo from_toml(const toml::basic_value\u0026lt;TC\u0026gt;\u0026amp; v) { return extlib::foo{toml::find\u0026lt;int\u0026gt;(v, \u0026#34;a\u0026#34;), toml::find\u0026lt;std::string\u0026gt;(v, \u0026#34;b\u0026#34;)}; } }; } // toml Related # conversion.hpp into.hpp "},{"id":21,"href":"/toml11/docs/reference/get/","title":"get.hpp","section":"reference","content":" get.hpp # These are functions for extracting values from toml::value and performing type conversions if necessary.\ntoml::value can change the type it stores, and toml::get accommodates these types. Technically, all functions use toml::basic_value\u0026lt;TC\u0026gt;. However, for simplicity, we refer to it as toml::value in explanations unless a distinction is necessary. In the documentation, if the template parameter TC changes the type, assume that types like toml::value::integer_type will also change accordingly. toml::get\u0026lt;T\u0026gt; # Overview # Generally, toml::get behaves as follows: You specify T as in toml::get\u0026lt;int\u0026gt;(v).\ntemplate\u0026lt;typename T, typename TC\u0026gt; T get(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v); However, depending on the type of T, toml::get can exhibit different behaviors.\nThe types of T can be categorized into:\nTypes that do not require conversion Types that require conversion Detailed conditions and the specific types supported are discussed later.\nTypes that Do Not Require Conversion # No conversion is needed if the provided toml::value is already storing the desired type. For instance, since toml::value::integer_type is an alias for std::int64_t, toml::get\u0026lt;std::int64_t\u0026gt;(v) requires no conversion. In this case, toml::get retrieves the integer value from toml::value and returns a reference to it.\nIf the provided toml::value is a mutable reference (\u0026amp;), the returned value is also a mutable reference (\u0026amp;). If it is an immutable reference (const\u0026amp;), the returned value will also be an immutable reference (const\u0026amp;). Returning a mutable reference allows you to overwrite the value stored in toml::value through that reference.\nTypes that Require Conversion # Types other than the ones mentioned above require conversion. For example, since toml::value::integer_type is an alias for std::int64_t, toml::get\u0026lt;std::size_t\u0026gt;(toml::value\u0026amp;) requires conversion. In this case, toml::get retrieves the integer value from toml::value and casts it to return the appropriate type.\ntoml11 supports not only simple casts but also complex type conversions like converting from toml::array to std::tuple\u0026lt;int, double, std::string\u0026gt;, std::array\u0026lt;double, 4\u0026gt;, or from toml::table to std::map\u0026lt;std::string, int\u0026gt;. For specifics, refer to the subsequent sections.\nWhen Conversion Fails # Sometimes, the expected type conversion cannot be performed. For example, applying toml::get\u0026lt;int\u0026gt;(v) to a toml::value that holds a table.\nIn such cases, an attempt to convert to the type most similar to the desired type (in this case, int using as_integer) fails, and a toml::type_error is thrown.\nWhen parsing from a file, an error message similar to the following is output:\nterminate called after throwing an instance of \u0026#39;toml::type_error\u0026#39; what(): toml::value::as_integer(): bad_cast to integer --\u0026gt; input.toml | 6 | [fruit] | ^^^^^^^-- the actual type is table When T is identical to toml::value # template\u0026lt;typename T, typename TC\u0026gt; T\u0026amp; get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); template\u0026lt;typename T, typename TC\u0026gt; T const\u0026amp; get(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v); template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v); Condition:\nstd::is_same\u0026lt;T, basic_value\u0026lt;TC\u0026gt;\u0026gt; is satisfied. Since this involves retrieving toml::value from toml::value, no conversion is performed, and the value is returned as is. This exists solely to generalize the implementation of other functions.\nThis does not fail.\nWhen T is one of toml::value::{some_type} # template\u0026lt;typename T, typename TC\u0026gt; T\u0026amp; get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); template\u0026lt;typename T, typename TC\u0026gt; T const\u0026amp; get(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v); template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v); Condition:\nT must be the same as one of the types that toml::value can store (e.g., toml::value::boolean_type). If toml::value is storing a type that matches the specified type in toml::get\u0026lt;T\u0026gt;, such as toml::value::integer_type, no type conversion is needed, and a reference can be returned.\nIf a different type is stored, a toml::type_error is thrown.\nWhen T is basic_value\u0026lt;OtherTC\u0026gt; with a different TypeConfig # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nT is not toml::basic_value\u0026lt;TC\u0026gt;. T is toml::basic_value\u0026lt;OtherTC\u0026gt;. When a basic_value that can store different types is specified, conversion is performed.\nSince type conversion occurs, the returned value is a new value and not a reference.\nThis does not fail (except in cases like memory exhaustion).\nWhen T is an integer type # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nstd::is_integral\u0026lt;T\u0026gt; is satisfied T is not bool T is not toml::value::integer_type The function assumes that toml::value holds an integer_type, retrieves its value, converts it to T, and returns it.\nIf a type other than toml::value::integer_type is stored, a toml::type_error is thrown.\nWhen T is a floating-point type # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nstd::is_floating_point\u0026lt;T\u0026gt; is satisfied T is not toml::value::floating_type The function assumes that toml::value holds a floating_type, retrieves its value, converts it to T, and returns it.\nIf a type other than toml::value::floating_type is stored, a toml::type_error is thrown.\nWhen T is std::string_view # This is only available in C++17 and later.\ntemplate\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nstd::is_same\u0026lt;std::string_view, T\u0026gt; is satisfied The function assumes that toml::value holds a string_type, retrieves its value, constructs a std::string_view from it, and returns it.\nIf a type other than toml::value::string_type is stored, a toml::type_error is thrown.\nWhen T is std::chrono::duration # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nT is std::chrono::duration\u0026lt;Rep, Period\u0026gt; The function assumes that toml::value holds a local_time, retrieves its value, converts it to std::chrono::duration, and returns it.\nIf a type other than toml::value::local_time is stored, a toml::type_error is thrown.\nWhen T is std::chrono::system_clock::time_point # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nstd::is_same\u0026lt;T, std::chrono::system_clock::time_point\u0026gt; is satisfied If the toml::value holds a local_date, local_datetime, or offset_datetime, this function retrieves the value and converts it to std::chrono::system_clock::time_point, returning the result.\nIf the value is of a type other than local_date, local_datetime, or offset_datetime, a toml::type_error is thrown.\nWhen T is array-like # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Conditions:\nT has an iterator T has a value_type T supports push_back(x) T is not toml::value::array_type T is not std::string T is not std::string_view T is not map-like T does not have from_toml() member function toml::from\u0026lt;T\u0026gt; is not defined A constructor from toml::basic_value\u0026lt;TC\u0026gt; is not defined This includes types like std::vector\u0026lt;int\u0026gt; and std::deque\u0026lt;std::string\u0026gt;.\nIf the toml::value holds an array, this function retrieves the value and converts it to the specified container type, returning the result.\nIf the value is of a type other than toml::value::array_type, a toml::type_error is thrown.\nWhen T is std::array # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition：\nT is std::array\u0026lt;U, N\u0026gt; If the toml::value holds an array, this function retrieves the value and converts it to the specified container type, returning the result.\nIf the value is of a type other than toml::value::array_type, a toml::type_error is thrown.\nIf the array held by toml::value does not contain enough elements, a std::out_of_range is thrown.\nWhen T is std::forward_list # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nT is std::forward_list\u0026lt;U\u0026gt; If the toml::value holds an array, this function retrieves the value and converts it to a std::forward_list, returning the result.\nIf the value is of a type other than toml::value::array_type, a toml::type_error is thrown.\nWhen T is std::pair # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nT is std::pair\u0026lt;T1, T2\u0026gt; If the toml::value holds an array, this function retrieves the value and converts it to std::pair\u0026lt;T1, T2\u0026gt;, returning the result.\nThe first and second elements are recursively converted.\nIf the value is of a type other than basic_value::array_type, a toml::type_error is thrown.\nIf the array held by toml::value does not contain exactly 2 elements, a std::out_of_range is thrown.\nWhen T is std::tuple # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nT is std::tuple\u0026lt;T1, T2, ... TN\u0026gt; If the toml::value holds an array, this function retrieves the value and converts it to std::tuple\u0026lt;T1, T2, ...TN\u0026gt;, returning the result.\nEach element is recursively converted.\nIf the value is of a type other than basic_value::array_type, a toml::type_error is thrown.\nIf the array held by toml::value does not contain exactly std::tuple_size\u0026lt;T\u0026gt;::value elements, a std::out_of_range is thrown.\nWhen T is map-like # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Conditions:\nT has an iterator T has a key_type T has a value_type T has a mapped_type T is not toml::value::table_type T does not have a from_toml() member function toml::from\u0026lt;T\u0026gt; is not defined A constructor from toml::basic_value\u0026lt;TC\u0026gt; is not defined This includes types like std::map\u0026lt;std::string, int\u0026gt; and std::unordered_map\u0026lt;std::string, float\u0026gt;.\nIf the toml::value holds a table, this function retrieves the value and converts it to T, returning the result.\nElements are recursively converted.\nIf the value is of a type other than basic_value::table_type, a toml::type_error is thrown.\nWhen T is a user-defined type with a specialization of toml::from\u0026lt;T\u0026gt; # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Condition:\nA specialization of toml::from\u0026lt;T\u0026gt; is defined If a specialization of toml::from for T is defined, it is used for type conversion.\nEnsure this does not conflict with individually supported types (std::array, std::pair, std::tuple etc).\nWhen T is a user-defined type with a from_toml member function # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Conditions:\ntoml::from\u0026lt;T\u0026gt; is not defined T has from_toml() member function If T has a from_toml(toml::basic_value\u0026lt;TC\u0026gt;) member function, it is used for type conversion.\nIf toml::from\u0026lt;T\u0026gt; is defined, it takes precedence.\nWhen T is a user-defined type with a constructor that takes toml::basic_value\u0026lt;TC\u0026gt; # template\u0026lt;typename T, typename TC\u0026gt; T get(basic_value\u0026lt;TC\u0026gt;\u0026amp; v); Conditions:\ntoml::from\u0026lt;T\u0026gt; is not defined T does not have from_toml() member function T has a constructor that takes toml::basic_value\u0026lt;TC\u0026gt; If T has a constructor that takes toml::basic_value\u0026lt;TC\u0026gt;, it is used for type conversion.\nIf toml::from\u0026lt;T\u0026gt; or T::from_toml is defined, they take precedence.\ntoml::get_or\u0026lt;T\u0026gt; # get_or takes a default value for use when the conversion fails, avoiding exceptions.\nThe default value must be of the same type as the target type T. Therefore, unlike toml::get\u0026lt;T\u0026gt;, T can be inferred in get_or.\nWhen T is basic_value\u0026lt;TC\u0026gt; # template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; const\u0026amp; get_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const basic_value\u0026lt;TC\u0026gt;\u0026amp; opt) template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; \u0026amp; get_or(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, basic_value\u0026lt;TC\u0026gt;\u0026amp; opt) template\u0026lt;typename TC\u0026gt; basic_value\u0026lt;TC\u0026gt; get_or(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; opt) Since the conversion target is the same toml::value, this never fails.\nIt exists solely to generalize the implementation of other functions.\nWhen T is basic_value\u0026lt;TC\u0026gt;::{some_type} # template\u0026lt;typename T, typename TC\u0026gt; T const\u0026amp; get_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const T\u0026amp; opt) noexcept template\u0026lt;typename T, typename TC\u0026gt; T \u0026amp; get_or(basic_value\u0026lt;TC\u0026gt;\u0026amp; v, T\u0026amp; opt) noexcept template\u0026lt;typename T, typename TC\u0026gt; T get_or(basic_value\u0026lt;TC\u0026gt;\u0026amp;\u0026amp; v, T\u0026amp;\u0026amp; opt) noexcept Performs the same conversion as toml::get\u0026lt;T\u0026gt;. If it fails, the second argument is returned.\nWhen T is const char* # template\u0026lt;typename TC\u0026gt; typename basic_value\u0026lt;TC\u0026gt;::string_type get_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const typename basic_value\u0026lt;TC\u0026gt;::string_type::value_type* opt); When const char* is passed, the conversion target is interpreted as std::string.\nWhen T is something else # template\u0026lt;typename TC\u0026gt; typename std::remove_cv\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026gt;::type get_or(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, T\u0026amp;\u0026amp; opt); Performs the same conversion as toml::get\u0026lt;T\u0026gt;. If it fails, the second argument is returned.\nRelated # find.hpp from.hpp value.hpp "},{"id":22,"href":"/toml11/docs/reference/into/","title":"into.hpp","section":"reference","content":" into.hpp # Defines a struct used for conversion from user-defined types into toml::value constructors.\nYou can achieve the same functionality by adding an into_toml member function, but for classes where you cannot add member functions, use into\u0026lt;T\u0026gt;.\nThis file does not provide specific implementations. Please specialize this struct when using.\nnamespace toml { template\u0026lt;typename T\u0026gt; struct into; } // toml Example # namespace extlib { struct foo { int a; std::string b; }; } // extlib #include \u0026lt;toml11/into.hpp\u0026gt; namespace toml { template\u0026lt;\u0026gt; struct into\u0026lt;extlib::foo\u0026gt; { template\u0026lt;typename TC\u0026gt; static toml::basic_value\u0026lt;TC\u0026gt; into_toml(const extlib::foo\u0026amp; f) { using value_type = toml::basic_value\u0026lt;TC\u0026gt;; using table_type = typename value_type::table_type; return value_type(table_type{{\u0026#34;a\u0026#34;, f.a}, {\u0026#34;b\u0026#34;, f.b}}); } }; } // toml Related # conversion.hpp from.hpp "},{"id":23,"href":"/toml11/docs/reference/literal/","title":"literal.hpp","section":"reference","content":" literal.hpp # In literal.hpp, the _toml literal is defined.\nThe _toml literal parses string literals into toml::value.\nnamespace toml { inline namespace literals { inline namespace toml_literals { toml::value operator\u0026#34;\u0026#34; _toml(const char* str, std::size_t len); toml::value operator\u0026#34;\u0026#34; _toml(const char8_t* str, std::size_t len); // Available in C++20 and later } // toml_literals } // literals } // toml Free Functions # operator\u0026quot;\u0026quot; _toml(const char*) # toml::value operator\u0026#34;\u0026#34; _toml(const char* str, std::size_t len); Converts a string literal into a toml::value by parsing it.\nFor typical TOML files, this performs equivalent parsing to toml::parse.\nconst auto v1 = \u0026#34;a = \u0026#39;foo\u0026#39;\u0026#34;_toml; // v1: {a = \u0026#39;foo\u0026#39;} When dealing with multiline content, raw string literal is convenient.\nconst auto v1 = R\u0026#34;( a = 42 b = \u0026#34;foo\u0026#34; )\u0026#34;_toml; If the value is a standalone entity, it represents that value.\nconst auto v2 = \u0026#34;\u0026#39;foo\u0026#39;\u0026#34;_toml; // v2: \u0026#39;foo\u0026#39; TOML allows keys consisting solely of numbers. When distinguishing between table definitions and arrays is ambiguous (e.g., [1]), table definitions take precedence.\nTo interpret as an array, use a trailing comma.\nconst auto v3 = \u0026#34;[1]\u0026#34;_toml; // v3: {1 = {}} const auto v4 = \u0026#34;[1,]\u0026#34;_toml; // v4: [1,] operator\u0026quot;\u0026quot; _toml(const char8_t*) # Defined when char8_t is available. Otherwise identical in functionality, differing only in argument type.\nExample # #include \u0026lt;toml.hpp\u0026gt; int main() { using namespace toml::literals::toml_literals; const auto v = \u0026#34;a = \\\u0026#34;foo\\\u0026#34;\u0026#34;_toml; assert(v.at(\u0026#34;a\u0026#34;).as_string() == \u0026#34;foo\u0026#34;); return 0; } "},{"id":24,"href":"/toml11/docs/reference/ordered_map/","title":"ordered_map.hpp","section":"reference","content":" ordered_map.hpp # Defines toml::ordered_map, which is used to maintain the order of values in a file.\nclass ordered_map # namespace toml { template\u0026lt;typename Key, typename Val, typename Cmp = std::equal_to\u0026lt;Key\u0026gt;, typename Allocator = std::allocator\u0026lt;std::pair\u0026lt;Key, Val\u0026gt;\u0026gt;\u0026gt; class ordered_map; } The ordered_map is a map type that preserves the insertion order of values, allowing iteration in that order.\nAs a linear container, searches require O(n) time relative to the number of elements. Use this when search operations are infrequent and maintaining the order of values is important.\nNon-Member Types # namespace toml { struct ordered_type_config; using ordered_value = basic_value\u0026lt;ordered_type_config\u0026gt;; using ordered_table = typename ordered_value::table_type; using ordered_array = typename ordered_value::array_type; } Use these in place of toml::type_config and toml::value.\nSince toml::parse defaults to using type_config, specify\nconst auto input = toml::parse\u0026lt;toml::ordered_type_config\u0026gt;(\u0026#34;input.toml\u0026#34;); when parsing.\nMember Types # using key_type = Key; using mapped_type = Val; using value_type = std::pair\u0026lt;Key, Val\u0026gt;; using key_compare = Cmp; using allocator_type = Allocator; using container_type = std::vector\u0026lt;value_type, Allocator\u0026gt;; using reference = typename container_type::reference; using pointer = typename container_type::pointer; using const_reference = typename container_type::const_reference; using const_pointer = typename container_type::const_pointer; using iterator = typename container_type::iterator; using const_iterator = typename container_type::const_iterator; using size_type = typename container_type::size_type; using difference_type = typename container_type::difference_type; Member Functions # Constructors # ordered_map() = default; Constructs an empty ordered_map.\nConstructors (Comparator, Allocator) # explicit ordered_map(const Cmp\u0026amp; cmp, const Allocator\u0026amp; alloc = Allocator()); explicit ordered_map(const Allocator\u0026amp; alloc); Constructs an ordered_map with a specified comparator for key comparison and an allocator for memory management.\nCopy and Move Constructors # ordered_map(const ordered_map\u0026amp;) = default; ordered_map(ordered_map\u0026amp;\u0026amp;) = default; ordered_map(const ordered_map\u0026amp; other, const Allocator\u0026amp; alloc); ordered_map(ordered_map\u0026amp;\u0026amp; other, const Allocator\u0026amp; alloc); Constructs an ordered_map by copying or moving the contents from another ordered_map. An allocator can also be specified for memory management.\nConstructors (Iterator) # template\u0026lt;typename InputIterator\u0026gt; ordered_map(InputIterator first, InputIterator last, const Cmp\u0026amp; cmp = Cmp(), const Allocator\u0026amp; alloc = Allocator()); template\u0026lt;typename InputIterator\u0026gt; ordered_map(InputIterator first, InputIterator last, const Allocator\u0026amp; alloc = Allocator()); Constructs an ordered_map with a range represented by iterators. The order of the elements follows the order of the iterators.\nConstructors (std::initializer_list) # ordered_map(std::initializer_list\u0026lt;value_type\u0026gt; v, const Cmp\u0026amp; cmp = Cmp(), const Allocator\u0026amp; alloc = Allocator()); ordered_map(std::initializer_list\u0026lt;value_type\u0026gt; v, const Allocator\u0026amp; alloc); Initializes the ordered_map using an initializer list.\nCopy and Move Assignment Operators # ordered_map\u0026amp; operator=(const ordered_map\u0026amp;) = default; ordered_map\u0026amp; operator=(ordered_map\u0026amp;\u0026amp;) = default; Assigns the contents of another ordered_map to this one, using copy or move semantics.\nAssignment Operator (std::initializer_list) # ordered_map\u0026amp; operator=(std::initializer_list\u0026lt;value_type\u0026gt; v); Assigns the contents of an initializer list to the ordered_map.\nDestructor # ~ordered_map() = default; Destroys the ordered_map.\nbegin(), end() # iterator begin() noexcept; iterator end() noexcept; const_iterator begin() const noexcept; const_iterator end() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; Returns iterators to the beginning and end of the container, allowing iteration over its contents in order.\nempty() # bool empty() const noexcept; Returns true if the ordered_map is empty, false otherwise.\nsize() # std::size_t size() const noexcept; Returns the number of elements in the ordered_map.\nmax_size() # std::size_t max_size() const noexcept; Returns the maximum number of elements the ordered_map can hold.\nclear() # void clear(); Clears all elements from the ordered_map.\npush_back(kv) # void push_back(const value_type\u0026amp;); void push_back(value_type\u0026amp;\u0026amp;); Appends a key-value pair to the end of the ordered_map.\nemplace_back(k, v) # void emplace_back(key_type, mapped_type); Appends a key-value pair to the end of the ordered_map by constructing it in place.\npop_back() # void pop_back(); Removes the last element from the ordered_map.\ninsert(kv) # void insert(value_type); Inserts a key-value pair at the end of the ordered_map.\nemplace(k, v) # void emplace(key_type, mapped_type); Inserts a key-value pair at the end of the ordered_map by constructing it in place.\ncount(k) # std::size_t count(const key_type\u0026amp;) const noexcept; Returns the number of elements with the specified key. Since duplicate keys are not allowed, this will return either 1 if the key exists or 0 if it does not.\ncontains(k) # bool contains(const key_type\u0026amp;) const noexcept; Returns true if the ordered_map contains an element with the specified key, false otherwise.\nfind(k) # iterator find(const key_type\u0026amp; key) noexcept; const_iterator find(const key_type\u0026amp; key) const noexcept; Finds an element with the specified key and returns an iterator to it. If the key is not found, returns end().\nat(k) # mapped_type\u0026amp; at(const key_type\u0026amp; k); mapped_type const\u0026amp; at(const key_type\u0026amp; k) const; Finds an element with the specified key and returns a reference to its value. Throws std::out_of_range if the key is not found.\noperator[](k) # mapped_type\u0026amp; operator[](const key_type\u0026amp; k); mapped_type const\u0026amp; operator[](const key_type\u0026amp; k) const; Finds an element with the specified key and returns a reference to its value. If the key is not found, a new value is constructed and returned. If the ordered_map is const, throws std::out_of_range instead.\nerase(...) # iterator erase(iterator pos); iterator erase(const_iterator pos); iterator erase(const_iterator first, const_iterator last); size_type erase(const key_type\u0026amp; key); Removes values pointed by an iterator or a value corresponding to a key.\nkey_comp() # key_compare key_comp() const; Returns the comparator used for key comparison.\nNotes # Key Modification # Since ordered_map uses std::pair\u0026lt;Key, Val\u0026gt; for value_type, it is possible to modify the key through an iterator. However, this practice is not recommended.\nIf you modify a key this way and it conflicts with an existing key, one of the conflicting keys will become unsearchable.\nWhen using operator[], push_back, or insert, collisions with existing keys are detected.\nOrder Preservation Details # ordered_map maintains the order of keys, but this order preservation applies only to keys defined within the same table. Order across different tables is not maintained.\nFor example, the order in the following file will be preserved:\napple.type = \u0026#34;fruit\u0026#34; apple.skin = \u0026#34;thin\u0026#34; apple.color = \u0026#34;red\u0026#34; orange.type = \u0026#34;fruit\u0026#34; orange.skin = \u0026#34;thick\u0026#34; orange.color = \u0026#34;orange\u0026#34; In contrast, the order in the following file will not be preserved:\napple.type = \u0026#34;fruit\u0026#34; orange.type = \u0026#34;fruit\u0026#34; apple.skin = \u0026#34;thin\u0026#34; orange.skin = \u0026#34;thick\u0026#34; apple.color = \u0026#34;red\u0026#34; orange.color = \u0026#34;orange\u0026#34; ordered_map preserves the order of the apple and orange definitions at the root table level, and the order of type, skin, color within each apple and orange table.\nRelated # parser.hpp types.hpp value.hpp "},{"id":25,"href":"/toml11/docs/reference/parser/","title":"parser.hpp","section":"reference","content":" parser.hpp # Defines functions for parsing files or strings and the exceptions they use.\nWhile parse throws an exception on failure, try_parse returns error information.\nparse # Parses the content of a given file and returns a toml::basic_value.\nIn case of failure, toml::syntax_error is thrown.\nThe type information of basic_value is provided by a template, and the TOML language version is specified by toml::spec.\nparse(std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(std::string fname, spec s = spec::default_version()); } Parses the content of the given filename.\nIf reading the file fails, toml::file_io_error is thrown.\nIf parsing fails, toml::syntax_error is thrown.\nparse(const char (\u0026amp;)[N] filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config, std::size_t N\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(const char (\u0026amp;fname)[N], spec s = spec::default_version()); } Parses the content of the given filename from a string literal.\nIf reading the file fails, toml::file_io_error is thrown.\nIf parsing fails, toml::syntax_error is thrown.\nparse(std::filesystem::path, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(const std::filesystem::path\u0026amp; fpath, spec s = spec::default_version()); } This is defined only if \u0026lt;filesystem\u0026gt; is available.\nParses the content of the file at the given file path.\nIf reading the file fails, toml::file_io_error is thrown.\nIf parsing fails, toml::syntax_error is thrown.\nparse(std::istream\u0026amp;, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(std::istream\u0026amp; is, std::string fname = \u0026#34;unknown file\u0026#34;, spec s = spec::default_version()); } Parses the content of the given std::istream\u0026amp;.\nOpen a stream in binary mode by passing std::ios::binary to avoid inconsistency between the file size and the number of characters due to automatic conversion of newline characters by the standard library.\nThe filename information is taken as the second argument. If the filename is not provided, it defaults to \u0026quot;unknown file\u0026quot;.\nparse(FILE*, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; parse(FILE* fp, std::string filename, spec s = spec::default_version()); } Parses the content of the file pointed to by FILE*.\nOpen a stream in binary mode by passing \u0026quot;rb\u0026quot; to avoid inconsistency between the file size and the number of characters due to automatic conversion of newline characters by the standard library.\nIf reading the file fails, file_io_error containing errno is thrown.\nIf parsing fails, syntax_error is thrown.\nparse(std::vector\u0026lt;unsigned char\u0026gt;, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse(std::vector\u0026lt;unsigned char\u0026gt; content, std::string filename, spec s = spec::default_version()); } Parses the byte sequence as a TOML file.\nIf parsing fails, toml::syntax_error is thrown.\nparse_str # parse_str(std::string, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; basic_value\u0026lt;TC\u0026gt; parse_str(std::string content, spec s = spec::default_version(), cxx::source_location loc = cxx::source_location::current()); } Parses a string as a TOML file.\nIn case of failure, toml::syntax_error is thrown.\nThe type information of basic_value is provided by a template, and the TOML language version is specified by toml::spec.\nYou generally don\u0026rsquo;t need to manually set the third argument, cxx::source_location. If std::source_location, std::experimental::source_location, or __builtin_FILE is available, the location information where parse_str was called will be stored.\ntry_parse # Parses the contents of the given file and returns a toml::basic_value if successful, or a std::vector\u0026lt;toml::error_info\u0026gt; if it fails.\nThe type information of basic_value is specified by template, and the version of the TOML language is specified by toml::spec.\nUnlike parse, try_parse does not throw exceptions defined in toml11 such as syntax_error. However, please note that exceptions thrown by the standard library will still propagate.\nFor instance, errors occurring internally within std::ifstream or memory exhaustion in std::vector will throw exceptions.\ntry_parse(std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(std::string fname, spec s = spec::default_version()); } Takes a file name and parses its content.\nIf parsing fails, a result holding the error type std::vector\u0026lt;error_info\u0026gt; is returned.\nIf successful, a result holding a basic_value is returned.\ntry_parse(const char (\u0026amp;)[N] filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config, std::size_t N\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(const char (\u0026amp;fname)[N], spec s = spec::default_version()); } Takes a string literal as a file name and parses its content.\nIf parsing fails, a result holding the error type std::vector\u0026lt;error_info\u0026gt; is returned.\nIf successful, a result holding a basic_value is returned.\ntry_parse(std::filesystem::path, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(const std::filesystem::path\u0026amp; fpath, spec s = spec::default_version()); } Takes a file path and parses its content.\nIf parsing fails, a result holding the error type std::vector\u0026lt;error_info\u0026gt; is returned.\nIf successful, a result holding a basic_value is returned.\ntry_parse(std::istream\u0026amp;, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(std::istream\u0026amp; is, std::string fname = \u0026#34;unknown file\u0026#34;, spec s = spec::default_version()); } Takes a std::istream\u0026amp; and parses its content.\nOpen a stream in binary mode by passing std::ios::binary to avoid inconsistency between the file size and the number of characters due to automatic conversion of newline characters by the standard library.\nThe file name information is taken as the second argument. If a file name is not provided, it defaults to \u0026quot;unknown file\u0026quot;.\nIf parsing fails, a result holding the error type std::vector\u0026lt;error_info\u0026gt; is returned.\nIf successful, a result holding a basic_value is returned.\ntry_parse(FILE*, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(FILE* fp, std::string filename, spec s = spec::default_version()); } Takes a FILE* and parses its content.\nOpen a stream in binary mode by passing \u0026quot;rb\u0026quot; to avoid inconsistency between the file size and the number of characters due to automatic conversion of newline characters by the standard library.\nIf parsing fails, a result holding the error type std::vector\u0026lt;error_info\u0026gt; is returned.\nIf successful, a result holding a basic_value is returned.\ntry_parse(std::vector\u0026lt;unsigned char\u0026gt;, std::string filename, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse(std::vector\u0026lt;unsigned char\u0026gt; content, std::string filename, spec s = spec::default_version()); } Takes a byte array and parses its content as a TOML file.\nIf parsing fails, a result holding the error type std::vector\u0026lt;error_info\u0026gt; is returned.\nIf successful, a result holding a basic_value is returned.\ntry_parse_str # try_parse_str(std::string, toml::spec) # namespace toml { template\u0026lt;typename TC = type_config\u0026gt; result\u0026lt;basic_value\u0026lt;TC\u0026gt;, std::vector\u0026lt;error_info\u0026gt;\u0026gt; try_parse_str(std::string content, spec s = spec::default_version(), cxx::source_location loc = cxx::source_location::current()); } Parses a string as a TOML file, returning a toml::basic_value if successful, or a std::vector\u0026lt;toml::error_info\u0026gt; if it fails.\nUnlike parse_str, it does not throw syntax_error, but instead returns error information as the failure type of the result.\nIf std::source_location, std::experimental::source_location, or __builtin_FILE is available, it will record the location information.\nTypically, you do not need to manually set the third argument cxx::source_location. If any of std::source_location, std::experimental::source_location, or __builtin_FILE are available, the information of the location where parse_str was called will be saved as the location information.\nUnlike parse, try_parse does not throw exceptions defined in toml11 such as syntax_error. However, please note that exceptions thrown by the standard library will still propagate.\nFor instance, errors occurring internally within std::ifstream or memory exhaustion in std::vector will throw exceptions.\nsyntax_error # namespace toml { struct syntax_error final : public ::toml::exception { public: syntax_error(std::string what_arg, std::vector\u0026lt;error_info\u0026gt; err); ~syntax_error() noexcept override = default; const char* what() const noexcept override; std::vector\u0026lt;error_info\u0026gt; const\u0026amp; errors() const noexcept }; } An exception thrown when a syntax error is detected in TOML.\nIt is thrown by parse but not by try_parse.\nfile_io_error # namespace toml { struct file_io_error final : public ::toml::exception { public: file_io_error(const std::string\u0026amp; msg, const std::string\u0026amp; fname); file_io_error(int errnum, const std::string\u0026amp; msg, const std::string\u0026amp; fname); ~file_io_error() noexcept override = default; const char* what() const noexcept override; bool has_errno() const noexcept; int get_errno() const noexcept; }; } An exception thrown when reading the contents of a file fails.\nWhen using FILE* to read a file, errno is set.\nhas_errno # If std::ifstream fails, errno is not set.\nIn this case, has_errno returns false.\nget_errno # Particularly when passing a FILE*, retrieves the value of errno.\nIf has_errno is false, it returns 0.\nRelated # error_info.hpp result.hpp spec.hpp value.hpp "},{"id":26,"href":"/toml11/docs/reference/result/","title":"result.hpp","section":"reference","content":" result.hpp # result.hpp defines the result type, which can hold either a success value or a failure value.\nThis is used as the return type for toml::try_parse, which does not throw exceptions.\nsuccess # A type that holds a success value.\nnamespace toml { template\u0026lt;typename T\u0026gt; struct success { using value_type = T; explicit success(value_type v); ~success() = default; success(const success\u0026amp;) = default; success(success\u0026amp;\u0026amp;) = default; success\u0026amp; operator=(const success\u0026amp;) = default; success\u0026amp; operator=(success\u0026amp;\u0026amp;) = default; template\u0026lt;typename U\u0026gt; explicit success(U\u0026amp;\u0026amp; v); template\u0026lt;typename U\u0026gt; explicit success(success\u0026lt;U\u0026gt; v); value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; }; template\u0026lt;typename T\u0026gt; success\u0026lt;typename std::decay\u0026lt;T\u0026gt;::type\u0026gt; ok(T\u0026amp;\u0026amp; v); template\u0026lt;std::size_t N\u0026gt; success\u0026lt;std::string\u0026gt; ok(const char (\u0026amp;literal)[N]) } Member Types # using value_type = T; The type of the success value.\nMember Functions # Constructor # explicit success(value_type v); Constructs with a value_type argument.\ntemplate\u0026lt;typename U\u0026gt; explicit success(U\u0026amp;\u0026amp; v); Constructs with another type that can be converted to value_type.\ntemplate\u0026lt;typename U\u0026gt; explicit success(success\u0026lt;U\u0026gt; v); Constructs with another success type that can be converted to value_type.\nget() # value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; Accesses the stored value.\nNon-Member Functions # ok(T) # template\u0026lt;typename T\u0026gt; success\u0026lt;typename std::decay\u0026lt;T\u0026gt;::type\u0026gt; ok(T\u0026amp;\u0026amp; v); template\u0026lt;std::size_t N\u0026gt; success\u0026lt;std::string\u0026gt; ok(const char (\u0026amp;literal)[N]); Constructs and returns a success type from a success value.\nConverts a string literal into std::string.\nsuccess\u0026lt;reference_wrapper\u0026lt;T\u0026gt;\u0026gt; # Specialization of success for when the success value is a reference.\nnamespace toml { template\u0026lt;typename T\u0026gt; struct success\u0026lt;std::reference_wrapper\u0026lt;T\u0026gt;\u0026gt; { using value_type = T; explicit success(std::reference_wrapper\u0026lt;value_type\u0026gt; v) noexcept; value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; }; } Member Types # using value_type = T; The type of the success value. It is T from std::reference_wrapper\u0026lt;T\u0026gt;, not the reference itself.\nget() # value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; Accesses the stored value.\nfailure # A type that holds a failure value.\nnamespace toml { template\u0026lt;typename T\u0026gt; struct failure { using value_type = T; explicit failure(value_type v); ~failure() = default; failure(const failure\u0026amp;) = default; failure(failure\u0026amp;\u0026amp;) = default; failure\u0026amp; operator=(const failure\u0026amp;) = default; failure\u0026amp; operator=(failure\u0026amp;\u0026amp;) = default; template\u0026lt;typename U\u0026gt; explicit failure(U\u0026amp;\u0026amp; v); template\u0026lt;typename U\u0026gt; explicit failure(failure\u0026lt;U\u0026gt; v); value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; }; template\u0026lt;typename T\u0026gt; failure\u0026lt;typename std::decay\u0026lt;T\u0026gt;::type\u0026gt; err(T\u0026amp;\u0026amp; v); template\u0026lt;std::size_t N\u0026gt; failure\u0026lt;std::string\u0026gt; err(const char (\u0026amp;literal)[N]); } Member Types # using value_type = T; The type of the failure value.\nMember Functions # Constructor # explicit failure(value_type v); Constructs with a value_type argument.\ntemplate\u0026lt;typename U\u0026gt; explicit failure(U\u0026amp;\u0026amp; v); Constructs with another type that can be converted to value_type.\ntemplate\u0026lt;typename U\u0026gt; explicit failure(failure\u0026lt;U\u0026gt; v); Constructs with another failure type that can be converted to value_type.\nget() # value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; Accesses the stored value.\nNon-Member Functions # err(T) # template\u0026lt;typename T\u0026gt; failure\u0026lt;typename std::decay\u0026lt;T\u0026gt;::type\u0026gt; err(T\u0026amp;\u0026amp; v); template\u0026lt;std::size_t N\u0026gt; failure\u0026lt;std::string\u0026gt; err(const char (\u0026amp;literal)[N]); Constructs and returns a failure type from a failure value.\nConverts a string literal into std::string.\nfailure\u0026lt;reference_wrapper\u0026lt;T\u0026gt;\u0026gt; # Specialization of failure for when the failure value is a reference.\nnamespace toml { template\u0026lt;typename T\u0026gt; struct failure\u0026lt;std::reference_wrapper\u0026lt;T\u0026gt;\u0026gt; { using value_type = T; explicit failure(std::reference_wrapper\u0026lt;value_type\u0026gt; v) noexcept; value_type\u0026amp; get() noexcept {return value.get();} value_type const\u0026amp; get() const noexcept {return value.get();} }; } Member Types # using value_type = T; The type of the failure value. It is T from std::reference_wrapper\u0026lt;T\u0026gt;, not the reference itself.\nget() # value_type\u0026amp; get() noexcept; value_type const\u0026amp; get() const noexcept; Accesses the stored value.\nresult # A type that holds either a success value or a failure value.\nnamespace toml { template\u0026lt;typename T, typename E\u0026gt; struct result { using success_type = success\u0026lt;T\u0026gt;; using failure_type = failure\u0026lt;E\u0026gt;; using value_type = typename success_type::value_type; using error_type = typename failure_type::value_type; result(success_type s); result(failure_type f); template\u0026lt;typename U\u0026gt; result(success\u0026lt;U\u0026gt; s); template\u0026lt;typename U\u0026gt; result(failure\u0026lt;U\u0026gt; f); result\u0026amp; operator=(success_type s); result\u0026amp; operator=(failure_type f); template\u0026lt;typename U\u0026gt; result\u0026amp; operator=(success\u0026lt;U\u0026gt; s); template\u0026lt;typename U\u0026gt; result\u0026amp; operator=(failure\u0026lt;U\u0026gt; f); ~result() noexcept; result(const result\u0026amp; other); result(result\u0026amp;\u0026amp; other); result\u0026amp; operator=(const result\u0026amp; other); result\u0026amp; operator=(result\u0026amp;\u0026amp; other); template\u0026lt;typename U, typename F\u0026gt; result(result\u0026lt;U, F\u0026gt; other); template\u0026lt;typename U, typename F\u0026gt; result\u0026amp; operator=(result\u0026lt;U, F\u0026gt; other); bool is_ok() const noexcept; bool is_err() const noexcept; explicit operator bool() const noexcept; value_type\u0026amp; unwrap(cxx::source_location loc = cxx::source_location::current()); value_type const\u0026amp; unwrap(cxx::source_location loc = cxx::source_location::current()) const; value_type\u0026amp; unwrap_or(value_type\u0026amp; opt) noexcept; value_type const\u0026amp; unwrap_or(value_type const\u0026amp; opt) const noexcept; error_type\u0026amp; unwrap_err(cxx::source_location loc = cxx::source_location::current()); error_type const\u0026amp; unwrap_err(cxx::source_location loc = cxx::source_location::current()) const; value_type\u0026amp; as_ok() noexcept; value_type const\u0026amp; as_ok() const noexcept; error_type\u0026amp; as_err() noexcept; error_type const\u0026amp; as_err() const noexcept; }; } Member Types # success_type # success\u0026lt;T\u0026gt;.\nfailure_type # failure\u0026lt;E\u0026gt;.\nvalue_type # The type T of the success value, alias for success_type::value_type.\nIf T is std::reference_wrapper\u0026lt;U\u0026gt;, then it is U.\nerror_type # The type E of the failure value, alias for failure_type::value_type.\nIf E is std::reference_wrapper\u0026lt;F\u0026gt;, then it is F.\nMember Functions # Constructor # result() = delete; Cannot construct result type by default. Needs to be given either a success or failure type.\nresult(success_type s); result(failure_type f); Constructs with a success_type or failure_type.\ntemplate\u0026lt;typename U\u0026gt; result(success\u0026lt;U\u0026gt; s); template\u0026lt;typename U\u0026gt; result(failure\u0026lt;U\u0026gt; f); Constructs with a success\u0026lt;U\u0026gt; or failure\u0026lt;U\u0026gt; that is convertible to value_type or error_type.\ntemplate\u0026lt;typename U, typename F\u0026gt; result(result\u0026lt;U, F\u0026gt; other); template\u0026lt;typename U, typename F\u0026gt; result\u0026amp; operator=(result\u0026lt;U, F\u0026gt; other); Constructs from or assigns to another result with convertible success or failure types.\nCopy and Move Constructors # result(const result\u0026amp; other); result(result\u0026amp;\u0026amp; other); Can be copy or move constructed.\noperator= # result\u0026amp; operator=(const result\u0026amp; other); result\u0026amp; operator=(result\u0026amp;\u0026amp; other); Can be copy or move assigned.\ntemplate\u0026lt;typename U\u0026gt; result\u0026amp; operator=(success\u0026lt;U\u0026gt; s); template\u0026lt;typename U\u0026gt; result\u0026amp; operator=(failure\u0026lt;U\u0026gt; f); Can be assigned from convertible success or failure types.\nis_ok() # bool is_ok() const noexcept; Returns true if it holds a success value, false otherwise.\nis_err() # bool is_err() const noexcept; Returns true if it holds a failure value, false otherwise.\noperator bool() # explicit operator bool() const noexcept; Returns true if it holds a success value, false otherwise.\nunwrap() # value_type\u0026amp; unwrap(cxx::source_location loc = cxx::source_location::current()); value_type const\u0026amp; unwrap(cxx::source_location loc = cxx::source_location::current()) const; Returns the stored success value.\nThrows toml::bad_result_access if it holds a failure value.\nIf std::source_location or equivalent compiler extension is available, the file name and line number where unwrap() occurred are included in the what() string.\nunwrap_or() # value_type\u0026amp; unwrap_or(value_type\u0026amp; opt) noexcept; value_type const\u0026amp; unwrap_or(value_type const\u0026amp; opt) const noexcept; Returns the stored success value if present, otherwise returns the provided default value.\nunwrap_err() # error_type\u0026amp; unwrap_err(cxx::source_location loc = cxx::source_location::current()); error_type const\u0026amp; unwrap_err(cxx::source_location loc = cxx::source_location::current()) const; Returns the stored failure value.\nThrows toml::bad_result_access if it holds a success value.\nIf std::source_location or equivalent compiler extension is available, the file name and line number where unwrap_err() occurred are included in the what() string.\nas_ok() # value_type\u0026amp; as_ok() noexcept; value_type const\u0026amp; as_ok() const noexcept; Returns the success value without checking.\nBehavior is undefined if it holds a failure value.\nas_err() # error_type\u0026amp; as_err() noexcept; error_type const\u0026amp; as_err() const noexcept; Returns the failure value without checking.\nBehavior is undefined if it holds a success value.\nbad_result_access # An exception thrown when unwrap or unwrap_err fails in a result.\nnamespace toml { struct bad_result_access : public ::toml::exception { public: explicit bad_result_access(const std::string\u0026amp; what_arg); virtual ~bad_result_access() noexcept override = default; virtual const char* what() const noexcept override; protected: std::string what_; }; } "},{"id":27,"href":"/toml11/docs/reference/serializer/","title":"serializer.hpp","section":"reference","content":" serializer.hpp # format # Serializes the data.\nnamespace toml { template\u0026lt;typename TC\u0026gt; std::string format(const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const spec s = spec::default_version()); template\u0026lt;typename TC\u0026gt; std::string format(const typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026amp; k, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const spec s = spec::default_version()); template\u0026lt;typename TC\u0026gt; std::string format(const std::vector\u0026lt;typename basic_value\u0026lt;TC\u0026gt;::key_type\u0026gt;\u0026amp; ks, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, const spec s = spec::default_version()); } If there\u0026rsquo;s a conflict between the format information and the spec, for example, when using v1.0.0 with table_format::multiline_oneline, the spec takes precedence.\nformat(v, spec) # Formats a toml::value according to its format information and the provided spec.\nIf it\u0026rsquo;s a table_type, it\u0026rsquo;s formatted as if it were the root table. Otherwise, only the value is formatted.\nformat(k, v, spec) # Formats a toml::value along with the given key.\nv is interpreted as being defined under that key.\nformat([k,...], v, spec) # v is interpreted as being defined under those keys. If multiple keys are provided, it\u0026rsquo;s interpreted as a recursively defined table.\nserialization_error # Reports errors that occurred during serialization.\nnamespace toml { struct serialization_error final : public ::toml::exception { public: explicit serialization_error(std::string what_arg, source_location loc); ~serialization_error() noexcept override = default; const char* what() const noexcept override; source_location const\u0026amp; location() const noexcept; }; } "},{"id":28,"href":"/toml11/docs/reference/source_location/","title":"source_location.hpp","section":"reference","content":" source_location.hpp # source_location.hpp defines a class representing a specific area within a TOML file.\nThis class is used to represent problematic areas in error messages.\ntoml::source_location # source_location is a class representing a specific area within a TOML file.\nnamespace toml { struct source_location { public: explicit source_location(/* implementation-defined */); ~source_location() = default; source_location(source_location const\u0026amp;) = default; source_location(source_location \u0026amp;\u0026amp;) = default; source_location\u0026amp; operator=(source_location const\u0026amp;) = default; source_location\u0026amp; operator=(source_location \u0026amp;\u0026amp;) = default; bool is_ok() const noexcept; std::size_t length() const noexcept; std::size_t first_line_number() const noexcept; std::size_t first_column_number() const noexcept; std::size_t last_line_number() const noexcept; std::size_t last_column_number() const noexcept; std::string const\u0026amp; file_name() const noexcept; std::size_t num_lines() const noexcept; std::string const\u0026amp; first_line() const; std::string const\u0026amp; last_line() const; std::vector\u0026lt;std::string\u0026gt; const\u0026amp; lines() const noexcept; }; template\u0026lt;typename ... Ts\u0026gt; std::string format_location(const source_location\u0026amp; loc, const std::string\u0026amp; msg, const Ts\u0026amp; ... locs_and_msgs); } //toml Member Functions # Constructor # explicit source_location(/* implementation-defined */); toml::source_location can only be constructed via toml::parse or the _toml literal.\nis_ok() # bool is_ok() const noexcept; Returns true if the source_location holds a valid value, false otherwise.\nThe result of location() from toml::value constructed outside of toml::parse or _toml literals returns false for is_ok as it points to nothing.\nlength() # std::size_t length() const noexcept; Returns the length of the area pointed to by the source_location.\nReturns 0 if it does not hold a valid value.\nfirst_line_number() # std::size_t first_line_number() const noexcept; Returns the line number of the first line of the area pointed to by the source_location.\nReturns 1 if it does not hold a valid value.\nfirst_column_number() # std::size_t first_column_number() const noexcept; Returns the column number of the first column of the area pointed to by the source_location.\nReturns 1 if it does not hold a valid value.\nlast_line_number() # std::size_t last_line_number() const noexcept; Returns the line number of the last line of the area pointed to by the source_location.\nReturns 1 if it does not hold a valid value.\nlast_column_number() # std::size_t last_column_number() const noexcept; Returns the column number of the last column of the area pointed to by the source_location.\nReturns 1 if it does not hold a valid value.\nfile_name() # std::string const\u0026amp; file_name() const noexcept; Returns the file name containing the area pointed to by the source_location.\nReturns \u0026quot;unknown file\u0026quot; if it does not hold a valid value.\nnum_lines() # std::size_t num_lines() const noexcept; Returns the number of lines in the area pointed to by the source_location.\nReturns 0 if it does not hold a valid value.\nfirst_line() # std::string const\u0026amp; first_line() const; Returns the first line of the area pointed to by the source_location.\nThrows std::out_of_range if it does not hold a valid value.\nlast_line() # std::string const\u0026amp; last_line() const; Returns the last line of the area pointed to by the source_location.\nThrows std::out_of_range if it does not hold a valid value.\nlines() # std::vector\u0026lt;std::string\u0026gt; const\u0026amp; lines() const noexcept; Returns all lines in the area pointed to by the source_location.\nReturns a reference to an empty std::vector if it does not hold a valid value.\nNon-Member Functions # format_location # template\u0026lt;typename ... Ts\u0026gt; std::string format_location(const source_location\u0026amp; loc, const std::string\u0026amp; msg, const Ts\u0026amp; ... locs_and_msgs); Formats the specified source_location and its associated message as follows:\n-\u0026gt; {filename.toml} | 1 | a = 42 | ^-- {message} If colorization is enabled, ANSI escape sequences will be added for coloring.\nWhen multiple locs_and_msgs are provided, they must be in the order of const source_location\u0026amp; followed by const std::string\u0026amp;, and the next pair in the same order, and so on.\nExample: Multiple source_location and std::string # When multiple source_location and std::string pairs are provided, they are formatted as follows:\nsource_location\u0026amp; loc0; source_location\u0026amp; loc1; source_location\u0026amp; loc2; std::string msg0; std::string msg1; std::string msg2; format_location(loc0, msg0, loc1, msg1, loc2, msg2); -\u0026gt; {filename0.toml} | 1 | a = 42 | ^-- {message0} | -\u0026gt; {filename1.toml} | 2 | b = 3.14 | ^-- {message1} | -\u0026gt; {filename2.toml} | 3 | c = \u0026#34;foo\u0026#34; | ^-- {message2} Related # error_info.hpp value.hpp "},{"id":29,"href":"/toml11/docs/reference/spec/","title":"spec.hpp","section":"reference","content":" spec.hpp # spec.hpp defines classes for specifying the version of TOML.\ntoml::semantic_version # semantic_version is a class that stores version information.\nnamespace toml { struct semantic_version { constexpr semantic_version(std::uint32_t mjr, std::uint32_t mnr, std::uint32_t p) noexcept; std::uint32_t major; std::uint32_t minor; std::uint32_t patch; }; constexpr semantic_version make_semver(std::uint32_t major, std::uint32_t minor, std::uint32_t patch) noexcept; constexpr bool operator==(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator!=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026lt; (const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026lt;=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026gt; (const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026gt;=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const semantic_version\u0026amp; ver); } //toml Member Functions # Constructor # constexpr semantic_version(std::uint32_t mjr, std::uint32_t mnr, std::uint32_t p) noexcept; Constructs a semantic_version instance with the specified major, minor, and patch version numbers.\nNon-Member Functions # Comparison Operators # constexpr bool operator==(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator!=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026lt; (const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026lt;=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026gt; (const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; constexpr bool operator\u0026gt;=(const semantic_version\u0026amp;, const semantic_version\u0026amp;) noexcept; Compares two semantic_version instances according to semantic versioning rules.\nStream Operator # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const semantic_version\u0026amp; ver); Outputs the version in the format {major}.{minor}.{patch}.\nto_string # std::string to_string(const semantic_version\u0026amp; ver); Converts the version to a string in the format {major}.{minor}.{patch}.\ntoml::spec # spec is a class that stores TOML version information.\nstruct spec { constexpr static spec default_version() noexcept; constexpr static spec v(std::uint32_t mjr, std::uint32_t mnr, std::uint32_t p) noexcept; constexpr explicit spec(const semantic_version\u0026amp; semver) noexcept; semantic_version version; // toml version // diff from v1.0.0 -\u0026gt; v1.1.0 bool v1_1_0_allow_control_characters_in_comments; bool v1_1_0_allow_newlines_in_inline_tables; bool v1_1_0_allow_trailing_comma_in_inline_tables; bool v1_1_0_allow_non_english_in_bare_keys; bool v1_1_0_add_escape_sequence_e; bool v1_1_0_add_escape_sequence_x; bool v1_1_0_make_seconds_optional; // library extensions bool ext_hex_float; // allow hex float bool ext_num_suffix; // allow number suffix bool ext_null_value; // allow null value }; Member Functions # Constructor # constexpr explicit spec(const semantic_version\u0026amp; semver) noexcept; Constructs a spec with the specified TOML version.\nSupports TOML v1.0.0 and TOML v1.1.0.\ndefault_version() # constexpr static spec default_version() noexcept; Constructs a spec with the default version.\nUsed as the default value for toml::parse and toml::format.\nIn toml11 v4.4.0, the value is v1.0.0.\nv(major, minor, patch) # constexpr static spec v(std::uint32_t mjr, std::uint32_t mnr, std::uint32_t p) noexcept; Constructs a spec with the specified version.\nMember Variables # Each flag is automatically set to true when the specified version includes the corresponding feature.\nYou can modify these flags to change the behavior of toml::parse and toml::format.\nSome features of TOML v1.1.0 are still under fairly lengthy discussion and may still be reverted.\nIf they are indeed reverted, toml11 will remove those features in a minor version upgrade or move them to a corresponding later version.\nAs such, any features related to future versions should be considered unstable.\nExample # auto spec = toml::spec::v(1, 0, 0); // Allow newlines in inline tables in addition to v1.0.0 features. // Other v1.1.0 features are not enabled. spec.v1_1_0_allow_newlines_in_inline_tables = true; auto input = toml::parse(\u0026#34;input_file.toml\u0026#34;, spec); v1_1_0_allow_control_characters_in_comments # bool v1_1_0_allow_control_characters_in_comments; Allows most control characters in comments.\nAdded in TOML v1.1.0.\nv1_1_0_allow_newlines_in_inline_tables # bool v1_1_0_allow_newlines_in_inline_tables; Allows newlines in inline tables.\nAdded in TOML v1.1.0.\nv1_1_0_allow_trailing_comma_in_inline_tables # bool v1_1_0_allow_trailing_comma_in_inline_tables; Allows trailing commas in inline tables.\nAdded in TOML v1.1.0.\nv1_1_0_add_escape_sequence_e # bool v1_1_0_add_escape_sequence_e; Allows \\e to represent the ESC character.\nAdded in TOML v1.1.0.\nv1_1_0_add_escape_sequence_x # bool v1_1_0_add_escape_sequence_x; Allows \\xHH to represent a single byte character.\nAdded in TOML v1.1.0.\nv1_1_0_make_seconds_optional # bool v1_1_0_make_seconds_optional; Makes the seconds component in time optional.\nUnspecified seconds default to 0.\nAdded in TOML v1.1.0.\next_hex_float # bool ext_hex_float; This is a language extension specific to toml11.\nIt is initialized to false regardless of the specified version. You must explicitly set it to true if you want to use it.\nAllows hexadecimal representation of floating-point numbers.\nThe hexadecimal representation conforms to the printf format specifier %a/%A.\nhexf = 0xC0FFEEp-10 toml::format will format using hexadecimal notation only if the passed toml::spec has ext_hex_float set to true. If the format specifier indicates hex but the toml::spec passed to toml::format has ext_hex_float set to false, the hexadecimal specification is ignored, and the number is output in decimal notation with maximum precision.\next_num_suffix # bool ext_num_suffix; This is a language extension specific to toml11.\nIt is initialized to false regardless of the specified version. You must explicitly set it to true if you want to use it.\nAllows the addition of suffixes to decimal integers and floating-point numbers. This does not apply to hexadecimal, octal, or binary notations.\nThere must be an _ separator between the number and the suffix.\nThe suffix cannot start with a digit to avoid confusion with the numeric part.\ndistance = 10_m # valid distance = 10_2m # invalid distance = 10_2_m # valid The suffix is stored in the format information as std::string suffix. The _ separating the number from the suffix is not included in the suffix.\ntoml::value distance = toml::find(input, \u0026#34;distance\u0026#34;); assert(distance.as_integer_fmt().suffix == std::string(\u0026#34;m\u0026#34;)); toml::format will format the value with the suffix only if the passed toml::spec has ext_num_suffix set to true.\nThe suffix follows the grammar defined as:\nnon-digit-graph = ALPHA / non-ascii graph = ALPHA / DIGIT / non-ascii suffix = _ non-digit-graph *( graph / ( _ graph ) ) ext_null_value # bool ext_null_value; This is a language extension specific to toml11.\nAllows the use of null as a value.\nA toml::value specified as null will have no value, and is_empty() will return true.\ntoml::format will format it as null only if the passed toml::spec has ext_null_value set to true. Otherwise, toml::format will terminate with an error.\n"},{"id":30,"href":"/toml11/docs/reference/toml_fwd/","title":"toml_fwd.hpp","section":"reference","content":" toml_fwd.hpp # toml_fwd.hpp contains forward declarations of structures defined in toml11 and macro definitions.\nWhen only forward declarations of toml11 structures are needed and implementation is not required, including toml_fwd.hpp instead of toml.hpp can reduce compilation time.\nSince this file only contains forward declarations, you cannot use toml::table, defined as toml::basic_value\u0026lt;toml::type_config\u0026gt;::table_type, and similarly defined toml::array. This is because they require the implementation of basic_value. This header file and toml.hpp are located under ${TOML11_INCLUDE_DIR}/, while other header files are located under ${TOML11_INCLUDE_DIR}/toml11/.\n"},{"id":31,"href":"/toml11/docs/reference/toml/","title":"toml.hpp","section":"reference","content":" toml.hpp # toml.hpp includes all other headers.\nThis allows access to all features of toml11.\nThis header file and toml_fwd.hpp are located under ${TOML11_INCLUDE_DIR}/, while other header files are located under ${toml11_include_dir}/toml11/.\n"},{"id":32,"href":"/toml11/docs/reference/types/","title":"types.hpp","section":"reference","content":" types.hpp # This document defines classes that specifies type information.\ntype_config # type_config is a type that encapsulates parameters given to toml::basic_value.\nWhen using different types within toml::basic_value\u0026lt;T\u0026gt;, you need to define and pass this type separately. All elements listed are required.\nIf you use numerical types that cannot use standard stream operators, define and replace the equivalents for read_int and read_float.\nnamespace toml { struct type_config { using comment_type = preserve_comments; using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = std::unordered_map\u0026lt;K, T\u0026gt;; static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base); static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex); }; using value = basic_value\u0026lt;type_config\u0026gt;; using table = typename value::table_type; using array = typename value::array_type; } // toml static Member Functions # parse_int(str, src, base) # static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base); If you use a type as integer_type that cannot utilize standard stream operators, implement this function. Otherwise, use read_int described later.\nThe str parameter receives a string with prefixes, leading zeros, and underscores removed.\nThe src parameter receives a source_location pointing to where the string was defined.\nThe base parameter receives one of 10, 2, 8, or 16.\nparse_float(str, src, is_hex) # static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex); If you use a type as floating_type that cannot utilize standard stream operators, implement this function. Otherwise, use read_float described later.\nThe str parameter receives a string with prefixes, leading zeros, and underscores removed.\nThe src parameter receives a source_location pointing to where the string was defined.\nThe is_hex parameter indicates whether the format is hexfloat. If you don\u0026rsquo;t use the hexfloat extension, you don\u0026rsquo;t need to implement this.\nFor details on the hexfloat extension, refer to spec.hpp.\nNon-member Functions # read_int # template\u0026lt;typename T\u0026gt; result\u0026lt;T, error_info\u0026gt; read_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base); This is the default function used. It parses using std::istringstream.\nIf operator\u0026gt;\u0026gt; and manipulators like std::hex, and std::numeric_limits\u0026lt;T\u0026gt; are defined (such as for boost::multiprecision), you can use this without modifications.\nread_float # template\u0026lt;typename T\u0026gt; result\u0026lt;T, error_info\u0026gt; read_float(const std::string\u0026amp; str, const source_location src, const bool is_hex); This is the default function used. It parses decimals using std::istringstream and hexfloats using sscanf().\nIt supports double and float.\nFor other types, if operator\u0026gt;\u0026gt; is defined and hex is not used, you can use this function.\nordered_type_config # ordered_type_config is a variation of toml::type_config where the table type is replaced with toml::ordered_map. Additionally, it defines the toml::ordered_value alias.\nOther than these changes, it is identical to type_config.\nnamespace toml { struct ordered_type_config { using comment_type = preserve_comments; using boolean_type = bool; using integer_type = std::int64_t; using floating_type = double; using string_type = std::string; template\u0026lt;typename T\u0026gt; using array_type = std::vector\u0026lt;T\u0026gt;; template\u0026lt;typename K, typename T\u0026gt; using table_type = ordered_map\u0026lt;K, T\u0026gt;; static result\u0026lt;integer_type, error_info\u0026gt; parse_int(const std::string\u0026amp; str, const source_location src, const std::uint8_t base) { return read_int\u0026lt;integer_type\u0026gt;(str, src, base); } static result\u0026lt;floating_type, error_info\u0026gt; parse_float(const std::string\u0026amp; str, const source_location src, const bool is_hex) { return read_float\u0026lt;floating_type\u0026gt;(str, src, is_hex); } }; using ordered_value = basic_value\u0026lt;ordered_type_config\u0026gt;; using ordered_table = typename ordered_value::table_type; using ordered_array = typename ordered_value::array_type; } // toml "},{"id":33,"href":"/toml11/docs/reference/value_t/","title":"value_t.hpp","section":"reference","content":" value_t.hpp # value_t # value_t is used to handle the type information of toml::value.\nnamespace toml { enum class value_t : std::uint8_t { empty = 0, boolean = 1, integer = 2, floating = 3, string = 4, offset_datetime = 5, local_datetime = 6, local_date = 7, local_time = 8, array = 9, table = 10 }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, value_t t); std::string to_string(value_t t); } // toml Non-member Functions # Stream Operator # std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, value_t t); Outputs the string representation of the value_t to the stream.\nto_string # std::string to_string(value_t t); Returns the string representation of the value_t.\n"},{"id":34,"href":"/toml11/docs/reference/value/","title":"value.hpp","section":"reference","content":" value.hpp # value.hpp defines basic_value.\ntoml::basic_value # basic_value is a class that stores TOML values.\nnamespace toml { template \u0026lt;class TypeConfig\u0026gt; class basic_value; // Defined in types.hpp // using value = basic_value\u0026lt;type_config\u0026gt;; // using table = typename basic_value\u0026lt;type_config\u0026gt;::table_type; // using array = typename basic_value\u0026lt;type_config\u0026gt;::array_type; template\u0026lt;typename TC\u0026gt; bool operator==(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator!=(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator\u0026lt; (const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator\u0026lt;=(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator\u0026gt; (const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); template\u0026lt;typename TC\u0026gt; bool operator\u0026gt;=(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); } //toml Member Types # The following member types are defined.\nYou can modify the member types using TypeConfig.\nSee also: types.hpp\nName Definition char_type typename TypeConfig::char_type key_type typename TypeConfig::string_type value_type basic_value\u0026lt;TypeConfig\u0026gt; boolean_type typename TypeConfig::boolean_type integer_type typename TypeConfig::integer_type floating_type typename TypeConfig::floating_type string_type typename TypeConfig::string_type local_time_type toml::local_time local_date_type toml::local_date local_datetime_type toml::local_datetime offset_datetime_type toml::offset_datetime array_type typename TypeConfig::template array_type\u0026lt;value_type\u0026gt; table_type typename TypeConfig::template table_type\u0026lt;key_type, value_type\u0026gt; comment_type typename TypeConfig::comment_type Member Functions # Default Constructor # basic_value() noexcept Constructs an empty toml::value.\nThe constructed toml::value will be empty.\nCopy and Move Constructors # basic_value(const basic_value\u0026amp; v) basic_value(basic_value\u0026amp;\u0026amp; v) Copies or moves all information including values, format information, comments, and file regions.\nCopy and Move Constructors with Comments # basic_value(basic_value v, std::vector\u0026lt;std::string\u0026gt; com) Copies or moves the object while overwriting comments.\nConversion Constructors # template\u0026lt;typename TI\u0026gt; basic_value(basic_value\u0026lt;TI\u0026gt; other) template\u0026lt;typename TI\u0026gt; basic_value(basic_value\u0026lt;TI\u0026gt; other, std::vector\u0026lt;std::string\u0026gt; com) Copies or moves from a basic_value with a different type_config.\nConstructor (boolean) # basic_value(boolean_type x) basic_value(boolean_type x, boolean_format_info fmt) basic_value(boolean_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(boolean_type x, boolean_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with a bool, its format information, and comments.\nConstructor (integer) # template\u0026lt;typename T, /* std::is_integral\u0026lt;T\u0026gt; is true */\u0026gt; basic_value(T x) template\u0026lt;typename T, /* std::is_integral\u0026lt;T\u0026gt; is true */\u0026gt; basic_value(T x, integer_format_info fmt) template\u0026lt;typename T, /* std::is_integral\u0026lt;T\u0026gt; is true */\u0026gt; basic_value(T x, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* std::is_integral\u0026lt;T\u0026gt; is true */\u0026gt; basic_value(T x, integer_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with an integer, its format information, and comments.\nConstructor (floating) # template\u0026lt;typename T, /* std::is_floating_point\u0026lt;T\u0026gt; is true */\u0026gt; basic_value(T x) template\u0026lt;typename T, /* std::is_floating_point\u0026lt;T\u0026gt; is true */\u0026gt; basic_value(T x, floating_format_info fmt) template\u0026lt;typename T, /* std::is_floating_point\u0026lt;T\u0026gt; is true */\u0026gt; basic_value(T x, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* std::is_floating_point\u0026lt;T\u0026gt; is true */\u0026gt; basic_value(T x, floating_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with a floating point number, its format information, and comments.\nConstructor (string) # basic_value(string_type x) basic_value(string_type x, string_format_info fmt) basic_value(string_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(string_type x, string_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) basic_value(const string_type::value_type* x) basic_value(const string_type::value_type* x, string_format_info fmt) basic_value(const string_type::value_type* x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(const string_type::value_type* x, string_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) // C++17以降 basic_value(string_view_type x) basic_value(string_view_type x, string_format_info fmt) basic_value(string_view_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(string_view_type x, string_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with a string, its format information, and comments.\nstring_view_type shares the same value_type and traits_type as string_type.\nConstructor (local_date) # basic_value(local_date_type x) basic_value(local_date_type x, local_date_format_info fmt) basic_value(local_date_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(local_date_type x, local_date_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with a local_date_type, its format information, and comments.\nConstructor (local_time) # basic_value(local_time_type x) basic_value(local_time_type x, local_time_format_info fmt) basic_value(local_time_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(local_time_type x, local_time_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename Rep, typename Period\u0026gt; basic_value(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; x) template\u0026lt;typename Rep, typename Period\u0026gt; basic_value(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; x, local_time_format_info fmt) template\u0026lt;typename Rep, typename Period\u0026gt; basic_value(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; x, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename Rep, typename Period\u0026gt; basic_value(const std::chrono::duration\u0026lt;Rep, Period\u0026gt;\u0026amp; x, local_time_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with a local_time_type, its format information, and comments.\nFor std::chrono::duration, constructs as a time span from 00:00:00.\nConstructor (local_datetime) # basic_value(local_datetime_type x) basic_value(local_datetime_type x, local_date_format_info fmt) basic_value(local_datetime_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(local_datetime_type x, local_date_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with a local_datetime_type, its format information, and comments.\nConstructor (offset_datetime) # basic_value(offset_datetime_type x) basic_value(offset_datetime_type x, offset_date_format_info fmt) basic_value(offset_datetime_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(offset_datetime_type x, offset_date_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) basic_value(std::chrono::system_clock::time_point x) basic_value(std::chrono::system_clock::time_point x, offset_date_format_info fmt) basic_value(std::chrono::system_clock::time_point x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(std::chrono::system_clock::time_point x, offset_date_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with an offset_datetime_type, its format information, and comments.\nFor std::chrono::system_clock::time_point, constructs for the pointed time.\nConstructor (array) # basic_value(array_type x) basic_value(array_type x, integer_format_info fmt) basic_value(array_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(array_type x, integer_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* T is array-like */\u0026gt; basic_value(T x) template\u0026lt;typename T, /* T is array-like */\u0026gt; basic_value(T x, array_format_info fmt) template\u0026lt;typename T, /* T is array-like */\u0026gt; basic_value(T x, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* T is array-like */\u0026gt; basic_value(T x, array_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with an array, its format information, and comments.\narray-like types must meet the following criteria:\nHas T::iterator. Has T::value_type. Does not have T::key_type. Does not have T::mapped_type. Is not std::string. Is not std::string_view (since C++17). Constructor (table) # basic_value(table_type x) basic_value(table_type x, integer_format_info fmt) basic_value(table_type x, std::vector\u0026lt;std::string\u0026gt; com) basic_value(table_type x, integer_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* T is table-like */\u0026gt; basic_value(T x) template\u0026lt;typename T, /* T is table-like */\u0026gt; basic_value(T x, table_format_info fmt) template\u0026lt;typename T, /* T is table-like */\u0026gt; basic_value(T x, std::vector\u0026lt;std::string\u0026gt; com) template\u0026lt;typename T, /* T is table-like */\u0026gt; basic_value(T x, table_format_info fmt, std::vector\u0026lt;std::string\u0026gt; com) Constructs an object with a table, its format information, and comments.\ntable-like types must meet the following criteria:\nHas T::iterator. Has T::value_type. Has T::key_type. Has T::mapped_type. Constructor (user-defined) # template\u0026lt;typename T /* toml::into\u0026lt;T\u0026gt; is defined */\u0026gt; basic_value(const T\u0026amp; ud); template\u0026lt;typename T /* toml::into\u0026lt;T\u0026gt; is defined */\u0026gt; basic_value(const T\u0026amp; ud, std::vector\u0026lt;std::string\u0026gt; com); template\u0026lt;typename T /* toml::into\u0026lt;T\u0026gt; is not defined, but T{}.into_toml() exists */\u0026gt; basic_value(const T\u0026amp; ud); template\u0026lt;typename T /* toml::into\u0026lt;T\u0026gt; is not defined, but T{}.into_toml() exists */\u0026gt; basic_value(const T\u0026amp; ud, std::vector\u0026lt;std::string\u0026gt; com); If toml::into\u0026lt;T\u0026gt; is defined, constructs from the result of toml::into\u0026lt;T\u0026gt;(ud).\nIf toml::into\u0026lt;T\u0026gt; is not defined but T has a into_toml() member function, constructs from the result of ud.into_toml().\noperator=(basic_value) # basic_value\u0026amp; operator=(const basic_value\u0026amp; v) basic_value\u0026amp; operator=(basic_value\u0026amp;\u0026amp; v) template\u0026lt;typename TI\u0026gt; basic_value\u0026amp; operator=(basic_value\u0026lt;TI\u0026gt; other) Assigns the right-hand side basic_value to the current object.\noperator=(T) # template\u0026lt;typename T\u0026gt; basic_value\u0026amp; operator=(T x) Assigns a value corresponding to T.\nThe contents pointed to by source_location are discarded.\nIf the object already holds a value of the same type, the original format information is retained.\nis\u0026lt;T\u0026gt;() # bool is\u0026lt;T\u0026gt;() const noexcept Requirements # T must be an exact TOML type, meaning it corresponds to one of the toml::value::xxx_type.\nReturn Value # Returns true if the stored type matches T, otherwise returns false.\nis(toml::value_t) # bool is(toml::value_t t) const noexcept Return Value # Returns true if the tag of the stored type matches t, otherwise returns false.\nis_xxx() # bool is_boolean() const noexcept; bool is_integer() const noexcept; bool is_floating() const noexcept; bool is_string() const noexcept; bool is_offset_datetime() const noexcept; bool is_local_datetime() const noexcept; bool is_local_date() const noexcept; bool is_local_time() const noexcept; bool is_array() const noexcept; bool is_table() const noexcept; Return Value # Returns true if the stored type matches the corresponding type, otherwise returns false.\nis_empty() # bool is_empty() const noexcept; Return Value # Returns true if the object is default constructed and no value is assigned, otherwise returns false.\nis_array_of_tables() # bool is_array_of_tables() const noexcept; Return Value # Returns true if the stored type is an array that is not empty and all elements are tables, otherwise returns false.\ntype() # toml::value_t type() const noexcept Return Value # Returns the tag corresponding to the stored type.\nas_xxx() # boolean_type const\u0026amp; as_boolean () const; integer_type const\u0026amp; as_integer () const; floating_type const\u0026amp; as_floating () const; string_type const\u0026amp; as_string () const; offset_datetime_type const\u0026amp; as_offset_datetime() const; local_datetime_type const\u0026amp; as_local_datetime () const; local_date_type const\u0026amp; as_local_date () const; local_time_type const\u0026amp; as_local_time () const; array_type const\u0026amp; as_array () const; table_type const\u0026amp; as_table () const; boolean_type \u0026amp; as_boolean (); integer_type \u0026amp; as_integer (); floating_type \u0026amp; as_floating (); string_type \u0026amp; as_string (); offset_datetime_type\u0026amp; as_offset_datetime(); local_datetime_type \u0026amp; as_local_datetime (); local_date_type \u0026amp; as_local_date (); local_time_type \u0026amp; as_local_time (); array_type \u0026amp; as_array (); table_type \u0026amp; as_table (); Return Value # Returns a reference to the value of the specified type.\nException # Throws toml::type_error if the stored value\u0026rsquo;s type does not match the specified type.\nas_xxx(std::nothrow) # Invoke with a std::nothrow object.\nboolean_type const\u0026amp; as_boolean (const std::nothrow_t\u0026amp;) const noexcept; integer_type const\u0026amp; as_integer (const std::nothrow_t\u0026amp;) const noexcept; floating_type const\u0026amp; as_floating (const std::nothrow_t\u0026amp;) const noexcept; string_type const\u0026amp; as_string (const std::nothrow_t\u0026amp;) const noexcept; offset_datetime_type const\u0026amp; as_offset_datetime(const std::nothrow_t\u0026amp;) const noexcept; local_datetime_type const\u0026amp; as_local_datetime (const std::nothrow_t\u0026amp;) const noexcept; local_date_type const\u0026amp; as_local_date (const std::nothrow_t\u0026amp;) const noexcept; local_time_type const\u0026amp; as_local_time (const std::nothrow_t\u0026amp;) const noexcept; array_type const\u0026amp; as_array (const std::nothrow_t\u0026amp;) const noexcept; table_type const\u0026amp; as_table (const std::nothrow_t\u0026amp;) const noexcept; boolean_type \u0026amp; as_boolean (const std::nothrow_t\u0026amp;) noexcept; integer_type \u0026amp; as_integer (const std::nothrow_t\u0026amp;) noexcept; floating_type \u0026amp; as_floating (const std::nothrow_t\u0026amp;) noexcept; string_type \u0026amp; as_string (const std::nothrow_t\u0026amp;) noexcept; offset_datetime_type\u0026amp; as_offset_datetime(const std::nothrow_t\u0026amp;) noexcept; local_datetime_type \u0026amp; as_local_datetime (const std::nothrow_t\u0026amp;) noexcept; local_date_type \u0026amp; as_local_date (const std::nothrow_t\u0026amp;) noexcept; local_time_type \u0026amp; as_local_time (const std::nothrow_t\u0026amp;) noexcept; array_type \u0026amp; as_array (const std::nothrow_t\u0026amp;) noexcept; table_type \u0026amp; as_table (const std::nothrow_t\u0026amp;) noexcept; Return Value # Returns a reference to the value of the specified type.\nNote # If the type of the stored value does not match the specified type, the behavior is undefined.\nas_xxx_fmt() # Accesses format information.\nboolean_format_info \u0026amp; as_boolean_fmt (); integer_format_info \u0026amp; as_integer_fmt (); floating_format_info \u0026amp; as_floating_fmt (); string_format_info \u0026amp; as_string_fmt (); offset_datetime_format_info\u0026amp; as_offset_datetime_fmt(); local_datetime_format_info \u0026amp; as_local_datetime_fmt (); local_date_format_info \u0026amp; as_local_date_fmt (); local_time_format_info \u0026amp; as_local_time_fmt (); array_format_info \u0026amp; as_array_fmt (); table_format_info \u0026amp; as_table_fmt (); boolean_format_info const\u0026amp; as_boolean_fmt () const; integer_format_info const\u0026amp; as_integer_fmt () const; floating_format_info const\u0026amp; as_floating_fmt () const; string_format_info const\u0026amp; as_string_fmt () const; offset_datetime_format_info const\u0026amp; as_offset_datetime_fmt() const; local_datetime_format_info const\u0026amp; as_local_datetime_fmt () const; local_date_format_info const\u0026amp; as_local_date_fmt () const; local_time_format_info const\u0026amp; as_local_time_fmt () const; array_format_info const\u0026amp; as_array_fmt () const; table_format_info const\u0026amp; as_table_fmt () const; Return Value # Returns a reference to the structure holding the format information for the specified type.\nException # Throws toml::type_error if the stored value\u0026rsquo;s type does not match the specified type.\nas_xxx_fmt(std::nothrow) # Invoke with a std::nothrow object.\nboolean_format_info \u0026amp; as_boolean_fmt (const std::nothrow_t\u0026amp;) noexcept; integer_format_info \u0026amp; as_integer_fmt (const std::nothrow_t\u0026amp;) noexcept; floating_format_info \u0026amp; as_floating_fmt (const std::nothrow_t\u0026amp;) noexcept; string_format_info \u0026amp; as_string_fmt (const std::nothrow_t\u0026amp;) noexcept; offset_datetime_format_info\u0026amp; as_offset_datetime_fmt(const std::nothrow_t\u0026amp;) noexcept; local_datetime_format_info \u0026amp; as_local_datetime_fmt (const std::nothrow_t\u0026amp;) noexcept; local_date_format_info \u0026amp; as_local_date_fmt (const std::nothrow_t\u0026amp;) noexcept; local_time_format_info \u0026amp; as_local_time_fmt (const std::nothrow_t\u0026amp;) noexcept; array_format_info \u0026amp; as_array_fmt (const std::nothrow_t\u0026amp;) noexcept; table_format_info \u0026amp; as_table_fmt (const std::nothrow_t\u0026amp;) noexcept; boolean_format_info const\u0026amp; as_boolean_fmt (const std::nothrow_t\u0026amp;) const noexcept; integer_format_info const\u0026amp; as_integer_fmt (const std::nothrow_t\u0026amp;) const noexcept; floating_format_info const\u0026amp; as_floating_fmt (const std::nothrow_t\u0026amp;) const noexcept; string_format_info const\u0026amp; as_string_fmt (const std::nothrow_t\u0026amp;) const noexcept; offset_datetime_format_info const\u0026amp; as_offset_datetime_fmt(const std::nothrow_t\u0026amp;) const noexcept; local_datetime_format_info const\u0026amp; as_local_datetime_fmt (const std::nothrow_t\u0026amp;) const noexcept; local_date_format_info const\u0026amp; as_local_date_fmt (const std::nothrow_t\u0026amp;) const noexcept; local_time_format_info const\u0026amp; as_local_time_fmt (const std::nothrow_t\u0026amp;) const noexcept; array_format_info const\u0026amp; as_array_fmt (const std::nothrow_t\u0026amp;) const noexcept; table_format_info const\u0026amp; as_table_fmt (const std::nothrow_t\u0026amp;) const noexcept; Return Value # Returns a reference to the structure holding the format information for the specified type.\nNote # If the type of the stored value does not match the specified type, the behavior is undefined.\nat(key) # value_type\u0026amp; at(const key_type\u0026amp; key); value_type const\u0026amp; at(const key_type\u0026amp; key) const; Return Value # Casts the current value to a table and returns the element specified by key.\nException # Throws toml::type_error if the stored value is not a table.\nThrows std::out_of_range if the table does not contain the specified element.\noperator[](key) # value_type\u0026amp; operator[](const key_type\u0026amp; k); Return Value # Casts the current value to a table and returns a reference to the element specified by key.\nIf the element specified by key does not exist, it is default-constructed.\nException # Throws toml::type_error if the stored value is not a table.\ncount(key) # std::size_t count(const key_type\u0026amp; key) const; Return Value # Casts the current value to a table and returns 1 if the element corresponding to key is present, otherwise returns 0.\nException # Throws toml::type_error if the stored value is not a table.\ncontains(key) # bool contains(const key_type\u0026amp; key) const; Return Value # Casts the current value to a table and returns true if the element corresponding to key is present, otherwise returns false.\nException # Throws toml::type_error if the stored value is not a table.\nat(idx) # value_type\u0026amp; at(const std::size_t idx); value_type const\u0026amp; at(const std::size_t idx) const; Return Value # Casts the current value to an array and returns the element specified by idx.\nException # Throws toml::type_error if the stored value is not an array.\nThrows std::out_of_range if the specified element does not exist in the array.\noperator[](idx) # value_type\u0026amp; operator[](const std::size_t idx) noexcept; value_type const\u0026amp; operator[](const std::size_t idx) const noexcept; Return Value # Casts the current value to an array and returns a reference to the element specified by idx.\nNote # Performs no checks. Behavior is undefined if the stored value is not an array or if the specified element does not exist.\npush_back(value) # void push_back(const value_type\u0026amp; x); void push_back(value_type\u0026amp;\u0026amp; x); Casts the current value to an array and performs push_back on the array.\nReturn Value # None.\nException # Throws toml::type_error if the stored value is not an array.\nemplace_back(args...) # template\u0026lt;typename ... Ts\u0026gt; value_type\u0026amp; emplace_back(Ts\u0026amp;\u0026amp; ... args) Casts the current value to an array and performs emplace_back on the array.\nReturn Value # A reference to the constructed value.\nException # Throws toml::type_error if the stored value is not an array.\nsize() # std::size_t size() const; Return Value # Casts the current value to an array, string, or table and returns the number of elements. For a string, it returns the number of characters.\nException # Throws toml::type_error if the stored value is not an array, string, or table.\nlocation() # source_location location() const; Return Value # Returns a source_location object representing the position within the TOML document where the value is defined.\nIf the value was not constructed by parsing a TOML document, returns a source_location that points to nowhere.\ncomments() # comment_type const\u0026amp; comments() const noexcept; comment_type\u0026amp; comments() noexcept; Return Value # Returns a reference to the comment container.\naccessed() # bool accessed() const; Return Value # Returns true only if the value has been accessed via as_xxx or is_xxx. Otherwise, it returns false.\nRemarks # It exists only when TOML11_ENABLE_ACCESS_CHECK is defined.\nNon-Member Functions # operator== # template\u0026lt;typename TC\u0026gt; bool operator==(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); Two basic_value\u0026lt;T\u0026gt; instances are considered equal if they satisfy the following conditions:\nThe contained type is the same. The contained values are identical. The comments are identical at the byte level. operator!= # template\u0026lt;typename TC\u0026gt; bool operator!=(const basic_value\u0026lt;TC\u0026gt;\u0026amp; lhs, const basic_value\u0026lt;TC\u0026gt;\u0026amp; rhs) { return !(lhs == rhs); } operator\u0026lt; # Defined only if array_type and table_type have operator\u0026lt;.\ntemplate\u0026lt;typename TC\u0026gt; bool operator\u0026lt;(const basic_value\u0026lt;TC\u0026gt;\u0026amp;, const basic_value\u0026lt;TC\u0026gt;\u0026amp;); Comparison order:\nTOML type If TOML types are the same, their values If both the TOML types and values are the same, the comments TOML types have the following order (from smallest to largest):\ntoml::value_t::empty toml::value_t::boolean toml::value_t::integer toml::value_t::floating toml::value_t::string toml::value_t::offset_datetime toml::value_t::local_datetime toml::value_t::local_date toml::value_t::local_time toml::value_t::array toml::value_t::table operator\u0026lt;= # Defined only if array_type and table_type have operator\u0026lt;.\ntemplate\u0026lt;typename TC\u0026gt; bool operator\u0026lt;=(const basic_value\u0026lt;TC\u0026gt;\u0026amp; lhs, const basic_value\u0026lt;TC\u0026gt;\u0026amp; rhs) { return (lhs \u0026lt; rhs) || (lhs == rhs); } operator\u0026gt; # Defined only if array_type and table_type have operator\u0026lt;.\ntemplate\u0026lt;typename TC\u0026gt; bool operator\u0026gt;(const basic_value\u0026lt;TC\u0026gt;\u0026amp; lhs, const basic_value\u0026lt;TC\u0026gt;\u0026amp; rhs) { return !(lhs \u0026lt;= rhs); } operator\u0026gt;= # Defined only if array_type and table_type have operator\u0026lt;.\ntemplate\u0026lt;typename TC\u0026gt; bool operator\u0026gt;=(const basic_value\u0026lt;TC\u0026gt;\u0026amp; lhs, const basic_value\u0026lt;TC\u0026gt;\u0026amp; rhs) { return !(lhs \u0026lt; rhs); } toml::type_error # Exception thrown in case of a type error.\nContains the location information of the value that caused the type error.\nstruct type_error final : public ::toml::exception { public: type_error(std::string what_arg, source_location loc); ~type_error() noexcept override = default; const char* what() const noexcept override; source_location const\u0026amp; location() const noexcept; }; toml::make_error_info # template\u0026lt;typename TC, typename ... Ts\u0026gt; error_info make_error_info( std::string title, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, std::string msg, Ts\u0026amp;\u0026amp; ... tail); Calls location() on a basic_value, passes the resulting source_location to make_error_info to create an error_info.\nRefer to error_info for more details.\ntoml::format_error # template\u0026lt;typename TC, typename ... Ts\u0026gt; std::string format_error(std::string title, const basic_value\u0026lt;TC\u0026gt;\u0026amp; v, std::string msg, Ts\u0026amp;\u0026amp; ... tail); Calls location() on a basic_value, passes the resulting source_location to format_error to create an error_info, then converts it to a string and returns it.\nRefer to error_info for more details.\nRelated # comments.hpp source_location.hpp types.hpp visit.hpp "},{"id":35,"href":"/toml11/docs/reference/version/","title":"version.hpp","section":"reference","content":" version.hpp # In version.hpp, macros related to the version information of toml11 are defined.\nMacros # TOML11_VERSION_MAJOR # The major version of toml11.\nTOML11_VERSION_MINOR # The minor version of toml11.\nTOML11_VERSION_PATCH # The patch version of toml11.\nFunction # license_notice # namespace toml { const char* license_notice() noexcept; } Returns the license notice.\nProvided for convenience when redistributing without source code.\n"},{"id":36,"href":"/toml11/docs/reference/visit/","title":"visit.hpp","section":"reference","content":" visit.hpp # In visit.hpp, toml::visit is defined.\ntoml::visit # Functions # namespace toml { template\u0026lt;typename Visitor, typename ... Args\u0026gt; /* Return value when Visitor is called with a value of basic_value\u0026lt;TC\u0026gt; */ visit(Visitor\u0026amp;\u0026amp; visitor, Args\u0026amp;\u0026amp; ... args); } toml::visit calls the overload of Visitor corresponding to the type held by basic_value\u0026lt;TC\u0026gt;, and returns the result.\nRequirements # Visitor must be a function or function object callable with any type held by basic_value\u0026lt;TC\u0026gt;.\nAdditionally, the return value must be consistent across all overloads.\nExample # #include \u0026lt;toml.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; struct type_name_of { std::string operator()(const toml::value::boolean_type \u0026amp;) const {return \u0026#34;boolean\u0026#34;;} std::string operator()(const toml::value::integer_type \u0026amp;) const {return \u0026#34;integer\u0026#34;;} std::string operator()(const toml::value::floating_type \u0026amp;) const {return \u0026#34;floating\u0026#34;;} std::string operator()(const toml::value::string_type \u0026amp;) const {return \u0026#34;string\u0026#34;;} std::string operator()(const toml::value::local_time_type \u0026amp;) const {return \u0026#34;local_time\u0026#34;;} std::string operator()(const toml::value::local_date_type \u0026amp;) const {return \u0026#34;local_date\u0026#34;;} std::string operator()(const toml::value::local_datetime_type \u0026amp;) const {return \u0026#34;local_datetime\u0026#34;;} std::string operator()(const toml::value::offset_datetime_type\u0026amp;) const {return \u0026#34;offset_datetime\u0026#34;;} std::string operator()(const toml::value::array_type \u0026amp;) const {return \u0026#34;array\u0026#34;;} std::string operator()(const toml::value::table_type \u0026amp;) const {return \u0026#34;table\u0026#34;;} }; int main() { toml::value v(3.14); std::cout \u0026lt;\u0026lt; toml::visit(type_name_of{}, v) \u0026lt;\u0026lt; std::endl; // floating return 0; } Related # value.hpp "}]